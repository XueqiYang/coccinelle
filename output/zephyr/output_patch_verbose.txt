
Please check for false positives in the output before submitting a patch.
When using "patch" mode, carefully review the patch before submitting it.

Processing array_size.cocci
with option(s) " --no-includes --include-headers"

Message example to submit a patch:
 Use ARRAY_SIZE instead of dividing sizeof array with sizeof an element

 The semantic patch that makes this change is available
 in scripts/coccinelle//array_size.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Semantic patch information:
 This makes an effort to find cases where ARRAY_SIZE can be used such as
 where there is a division of sizeof the array by the sizeof its first
 element or by any indexed element or the element type. It replaces the
 division of the two sizeofs by ARRAY_SIZE.

Running (4 in parallel): /usr/local/bin/spatch -D patch --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//array_size.cocci --no-includes --include-headers --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
-------------------------------------------------------------------------

Processing const_config_info.cocci
with option(s) " --include-headers"

Message example to submit a patch:
 The semantic patch that makes this report is available
 in scripts/coccinelle//const_config_info.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//const_config_info.cocci --include-headers --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
-------------------------------------------------------------------------

Processing deref_null.cocci
with option(s) ""

Message example to submit a patch:

 A variable is dereferenced under a NULL test.
 Even though it is known to be NULL.

 The semantic patch that makes this report is available
 in scripts/coccinelle//deref_null.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//deref_null.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2913:11-15: ERROR: sock is NULL but dereferenced.
-------------------------------------------------------------------------

Processing find_functions.cocci
with option(s) ""

Message example to submit a patch:
/////////////////
/////////////////
////////
////////
///////////////
///////////////
 The semantic patch that makes this report is available
 in scripts/coccinelle//find_functions.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//find_functions.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
-------------------------------------------------------------------------

Processing identifier_length.cocci
with option(s) ""

Message example to submit a patch:
 The semantic patch that makes this report is available
 in scripts/coccinelle//identifier_length.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//identifier_length.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:181:1-37: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:483:2-38: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:588:3-39: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:593:2-38: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:197:1-40: WARNING: Identifier wifi_mgmt_raise_disconnect_result_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:486:2-41: WARNING: Identifier wifi_mgmt_raise_disconnect_result_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.c:585:3-42: WARNING: Identifier wifi_mgmt_raise_disconnect_result_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/eswifi/eswifi_core.c:337:2-38: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/eswifi/eswifi_core.c:341:2-41: WARNING: Identifier wifi_mgmt_raise_disconnect_result_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c:314:4-41: WARNING: Identifier ieee802154_cc13xx_cc26xx_convert_rssi length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c:489:1-35: WARNING: Identifier ieee802154_cc13xx_cc26xx_data_init length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c:339:2-34: WARNING: Identifier ieee802154_cc13xx_cc26xx_rx_done length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:417:10-48: WARNING: Identifier mcp2515_convert_canmode_to_mcp2515mode length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:608:1-42: WARNING: Identifier mcp2515_convert_mcp2515frame_to_zcanframe length 41 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:468:1-42: WARNING: Identifier mcp2515_convert_zcanframe_to_mcp2515frame length 41 > 31
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_arcv2_irq_unit.c:35:16-51: WARNING: Identifier _arc_v2_irq_unit_device_power_state length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_exti_stm32.c:149:3-35: WARNING: Identifier LL_EXTI_IsActiveFallingFlag_0_31 length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:631:1-33: WARNING: Identifier optimize_regulator_voltage_scale length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_mcux_lpi2c.c:216:1-33: WARNING: Identifier LPI2C_MasterTransferCreateHandle length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:535:1-38: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:123:1-38: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:83:1-38: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:514:1-37: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:132:2-38: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:647:1-37: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:625:1-37: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:469:2-38: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:268:3-37: WARNING: Identifier stm32_i2c_generate_start_condition length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:173:2-36: WARNING: Identifier stm32_i2c_generate_start_condition length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:859:3-37: WARNING: Identifier stm32_i2c_generate_start_condition length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_stm32_hal.c:740:1-36: WARNING: Identifier enable_canbus_eth_translator_filter length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_nrfx.c:816:29-61: WARNING: Identifier nrf_usbd_setup_bmrequesttype_get length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_nrfx.c:1514:1-33: WARNING: Identifier nrfx_usbd_ep_max_packet_size_set length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_flexcomm.c:290:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_flexcomm.c:276:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sifive.c:158:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sifive.c:231:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_lpspi.c:194:1-33: WARNING: Identifier LPSPI_MasterTransferCreateHandle length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_lpspi.c:272:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_lpspi.c:260:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_dspi.c:278:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_mcux_dspi.c:264:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xlnx_axi_quadspi.c:451:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xlnx_axi_quadspi.c:381:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:633:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:605:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_wwdg_stm32.c:151:2-34: WARNING: Identifier LL_DBGMCU_APB1_GRP1_FreezePeriph length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcux_adc12.c:236:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcux_adc16.c:265:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcp320x.c:311:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mchp_xec.c:303:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_nrfx_adc.c:268:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dsl/lsm6dsl_shub.c:257:5-37: WARNING: Identifier lsm6dsl_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dsl/lsm6dsl_shub.c:339:5-37: WARNING: Identifier lsm6dsl_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dsl/lsm6dsl_shub.c:350:5-37: WARNING: Identifier lsm6dsl_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dsl/lsm6dsl_shub.c:286:6-38: WARNING: Identifier lsm6dsl_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dsl/lsm6dsl_shub.c:294:6-38: WARNING: Identifier lsm6dsl_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dsl/lsm6dsl_shub.c:313:5-37: WARNING: Identifier lsm6dsl_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx.c:178:6-38: WARNING: Identifier ism330dhcx_accel_range_to_fs_val length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx.c:749:5-37: WARNING: Identifier ism330dhcx_block_data_update_set length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx.c:653:2-34: WARNING: Identifier ism330dhcx_gyro_channel_get_temp length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx.c:355:5-40: WARNING: Identifier ism330dhcx_shub_fetch_external_devs length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:108:12-48: WARNING: Identifier stm32_dma_is_unexpected_irq_happened length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_sam0_tc32.c:214:2-34: WARNING: Identifier counter_sam0_tc32_relative_alarm length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_intel_apl.c:496:8-42: WARNING: Identifier gpio_intel_apl_port_set_masked_raw length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_intel_apl.c:490:8-42: WARNING: Identifier gpio_intel_apl_port_set_masked_raw length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc13xx_cc26xx.c:100:3-41: WARNING: Identifier gpio_cc13xx_cc26xx_port_clear_bits_raw length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc13xx_cc26xx.c:47:11-49: WARNING: Identifier gpio_cc13xx_cc26xx_port_clear_bits_raw length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc13xx_cc26xx.c:98:3-39: WARNING: Identifier gpio_cc13xx_cc26xx_port_set_bits_raw length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc13xx_cc26xx.c:45:11-47: WARNING: Identifier gpio_cc13xx_cc26xx_port_set_bits_raw length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_rv32m1.c:230:16-50: WARNING: Identifier get_port_pcr_irqc_value_from_flags length 34 > 31
/Users/yangxueqi/Documents/zephyr/soc/arm/nxp_lpc/lpc54xxx/soc.c:54:1-34: WARNING: Identifier CLOCK_SetFLASHAccessCyclesForFreq length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/power/policy/policy_residency_cc13x2_cc26x2.c:47:1-39: WARNING: Identifier SysCtrl_DCDC_VoltageConditionalControl length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/tracing/cpu_stats.c:155:27-67: WARNING: Identifier cpu_stats_non_idle_and_sched_get_percent length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ieee802154/ieee802154_mgmt.c:522:5-38: WARNING: Identifier ieee802154_security_setup_session length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:371:2-35: WARNING: Identifier gptp_md_compute_pdelay_rate_ratio length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:557:2-39: WARNING: Identifier gptp_md_init_pdelay_req_state_machine length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:558:2-40: WARNING: Identifier gptp_md_init_pdelay_resp_state_machine length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:559:2-37: WARNING: Identifier gptp_md_init_sync_rcv_state_machine length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:560:2-38: WARNING: Identifier gptp_md_init_sync_send_state_machine length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:680:3-37: WARNING: Identifier gptp_md_pdelay_check_multiple_resp length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:894:1-33: WARNING: Identifier gptp_md_pdelay_req_state_machine length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:895:1-34: WARNING: Identifier gptp_md_pdelay_resp_state_machine length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_md.c:896:1-35: WARNING: Identifier gptp_md_sync_receive_state_machine length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/openthread/platform/radio.c:398:3-35: WARNING: Identifier openthread_handle_received_frame length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/sockets.c:775:2-39: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/sockets.c:798:2-39: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/sockets.c:881:2-36: WARNING: Identifier net_stats_update_tc_rx_time_detail length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:396:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:50:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:52:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:54:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:56:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:58:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:60:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c:62:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/mqtt/mqtt_rx.c:264:12-44: WARNING: Identifier mqtt_read_and_parse_fixed_header length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/coap/coap_link_format.c:518:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/coap/coap_link_format.c:696:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_context.c:1523:11-43: WARNING: Identifier net_pkt_available_payload_buffer length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp.c:2620:1-34: WARNING: Identifier net_stats_update_tcp_seg_conndrop length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_shell.c:3189:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_shell.c:3054:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_shell.c:385:2-39: WARNING: Identifier print_supported_ethernet_capabilities length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:1387:3-38: WARNING: Identifier bt_test_mesh_trans_incomp_timer_exp length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/conn.c:2404:8-40: WARNING: Identifier bt_conn_create_pdu_timeout_debug length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/gatt.c:513:8-41: WARNING: Identifier bt_gatt_write_without_response_cb length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c:446:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c:204:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_test.c:120:1-34: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_test.c:263:1-34: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_sync.c:148:1-34: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:56:12-46: WARNING: Identifier ticker_update_latency_cancel_op_cb length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/tinycrypt/src/main.c:48:12-44: WARNING: Identifier test_aes_fixed_key_variable_text length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/tinycrypt/src/main.c:49:12-44: WARNING: Identifier test_aes_variable_key_fixed_text length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/tinycrypt/src/main.c:18:12-47: WARNING: Identifier test_cbc_sp_800_38a_encrypt_decrypt length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/tinycrypt/src/main.c:17:12-47: WARNING: Identifier test_ctr_sp_800_38a_encrypt_decrypt length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/ethernet_mgmt/src/main.c:185:3-38: WARNING: Identifier eth_fake_recalc_qav_delta_bandwidth length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/traffic_class/src/main.c:793:2-38: WARNING: Identifier traffic_class_recv_packets_with_prio length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/traffic_class/src/main.c:498:2-38: WARNING: Identifier traffic_class_send_packets_with_prio length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_clock_calibration/src/test_nrf_clock_calibration.c:168:1-36: WARNING: Identifier z_nrf_clock_calibration_force_start length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_clock_calibration/src/test_nrf_clock_calibration.c:67:12-47: WARNING: Identifier z_nrf_clock_calibration_skips_count length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_clock_calibration/src/test_nrf_clock_calibration.c:72:12-47: WARNING: Identifier z_nrf_clock_calibration_skips_count length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_irq_advanced_features/src/main.c:10:12-46: WARNING: Identifier test_arm_dynamic_direct_interrupts length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_interrupt/src/arm_interrupt.c:410:1-39: WARNING: Identifier z_impl_test_arm_user_interrupt_syscall length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/boards/altera_max10/msgdma/src/dma.c:91:1-34: WARNING: Identifier z_nios2_dcache_flush_no_writeback length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/bayes/src/f32.c:56:3-39: WARNING: Identifier arm_gaussian_naive_bayes_predict_f32 length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_pool/mem_pool_concept/src/main.c:11:12-53: WARNING: Identifier test_mpool_alloc_merge_failed_diff_parent length 41 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_pool/mem_pool_concept/src/main.c:10:12-51: WARNING: Identifier test_mpool_alloc_merge_failed_diff_size length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/threads/thread_apis/src/main.c:27:12-51: WARNING: Identifier test_threads_suspend_resume_cooperative length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/threads/thread_apis/src/main.c:28:12-51: WARNING: Identifier test_threads_suspend_resume_preemptible length 39 > 31
/Users/yangxueqi/Documents/zephyr/samples/drivers/spi_flash/src/main.c:32:13-45: WARNING: Identifier DT_NODE_BY_FIXED_PARTITION_LABEL length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/subsys/usb/webusb/src/main.c:291:1-33: WARNING: Identifier webusb_register_request_handlers length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:228:2-35: WARNING: Identifier level_move_lightness_work_handler length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/ti/cc13x2_cc26x2/system_off/src/main.c:26:12-46: WARNING: Identifier CC1352R1_LAUNCHXL_shutDownExtFlash length 34 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/ti/cc13x2_cc26x2/system_off/src/main.c:36:1-35: WARNING: Identifier CC1352R1_LAUNCHXL_shutDownExtFlash length 34 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/irq_manage.c:320:1-38: WARNING: Identifier z_arm_irq_dynamic_direct_isr_dispatch length 37 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/irq_manage.c:327:1-38: WARNING: Identifier z_arm_irq_dynamic_direct_isr_dispatch length 37 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_mpu.c:110:1-42: WARNING: Identifier get_region_attr_from_k_mem_partition_info length 41 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_mpu.c:287:5-38: WARNING: Identifier mpu_configure_dynamic_mpu_regions length 33 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_mpu.c:256:5-37: WARNING: Identifier mpu_configure_static_mpu_regions length 32 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_mpu.c:272:5-39: WARNING: Identifier mpu_mark_areas_for_dynamic_regions length 34 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/cmse/arm_core_cmse.c:131:8-45: WARNING: Identifier arm_cmse_addr_nonsecure_read_write_ok length 37 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/cmse/arm_core_cmse.c:136:8-45: WARNING: Identifier arm_cmse_addr_nonsecure_read_write_ok length 37 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/cmse/arm_core_cmse.c:162:8-51: WARNING: Identifier arm_cmse_addr_range_nonsecure_read_write_ok length 43 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/cmse/arm_core_cmse.c:169:8-51: WARNING: Identifier arm_cmse_addr_range_nonsecure_read_write_ok length 43 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/cmse/arm_core_cmse.c:65:8-41: WARNING: Identifier arm_cmse_addr_range_read_write_ok length 33 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/cmse/arm_core_cmse.c:70:8-41: WARNING: Identifier arm_cmse_addr_range_read_write_ok length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/native_posix/irq_handler.c:85:19-51: WARNING: Identifier hw_irq_ctrl_get_highest_prio_irq length 32 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/native_posix/irq_handler.c:126:5-37: WARNING: Identifier hw_irq_ctrl_get_highest_prio_irq length 32 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/nrf52_bsim/main.c:84:1-37: WARNING: Identifier bs_read_function_names_from_Tsymbols length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/nrf52_bsim/main.c:73:1-35: WARNING: Identifier bs_trace_register_cleanup_function length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/nrf52_bsim/time_machine.c:144:2-35: WARNING: Identifier bs_trace_warning_manual_time_line length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:92:32-66: WARNING: Identifier IOMUXC_I2C1_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:93:32-66: WARNING: Identifier IOMUXC_I2C1_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:117:32-66: WARNING: Identifier IOMUXC_I2C2_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:118:32-66: WARNING: Identifier IOMUXC_I2C2_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:142:32-66: WARNING: Identifier IOMUXC_I2C3_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:143:32-66: WARNING: Identifier IOMUXC_I2C3_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:167:32-66: WARNING: Identifier IOMUXC_I2C4_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:168:32-66: WARNING: Identifier IOMUXC_I2C4_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:63:2-44: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_EPDC_DATA08_MUX_MODE length 42 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:65:2-44: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_EPDC_DATA09_MUX_MODE length 42 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:111:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:114:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:136:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C3_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:139:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C3_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:39:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C4_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:41:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C4_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:164:2-45: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_SAI1_RX_BCLK_MUX_MODE length 43 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:161:2-45: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_SAI1_RX_SYNC_MUX_MODE length 43 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:86:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:89:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:17:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART2_RX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:19:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART2_TX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:71:2-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_EPDC_DATA08_DSE length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:69:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_EPDC_DATA08_PS length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:77:2-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_EPDC_DATA09_DSE length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:75:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_EPDC_DATA09_PS length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:123:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:122:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:129:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:128:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:148:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:147:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:154:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:153:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:47:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:45:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:53:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:51:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:179:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SAI1_RX_BCLK_DSE length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:178:2-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SAI1_RX_BCLK_PS length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:173:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SAI1_RX_SYNC_DSE length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:172:2-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SAI1_RX_SYNC_PS length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:98:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_RX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:97:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_RX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:104:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_TX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:103:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_TX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:24:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:22:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:30:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:28:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:33:2-41: WARNING: Identifier IOMUXC_UART2_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:56:2-41: WARNING: Identifier IOMUXC_UART5_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/pico_pi_m4/pinmux.c:80:2-41: WARNING: Identifier IOMUXC_UART6_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/kernel/thread.c:982:8-45: WARNING: Identifier z_impl_k_thread_timeout_expires_ticks length 37 > 31
/Users/yangxueqi/Documents/zephyr/kernel/thread.c:974:8-47: WARNING: Identifier z_impl_k_thread_timeout_remaining_ticks length 39 > 31
/Users/yangxueqi/Documents/zephyr/kernel/init.c:485:1-38: WARNING: Identifier ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING length 37 > 31
/Users/yangxueqi/Documents/zephyr/kernel/mem_slab.c:139:2-37: WARNING: Identifier z_thread_return_value_set_with_data length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:679:8-50: WARNING: Identifier nrf_802154_dbm_from_energy_level_calculate length 42 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:558:8-45: WARNING: Identifier nrf_802154_pending_bit_for_addr_clear length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:564:3-40: WARNING: Identifier nrf_802154_pending_bit_for_addr_reset length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:548:8-43: WARNING: Identifier nrf_802154_pending_bit_for_addr_set length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:529:4-43: WARNING: Identifier nrf_802154_src_addr_matching_method_set length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:534:4-43: WARNING: Identifier nrf_802154_src_addr_matching_method_set length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_led_esp32.c:225:1-33: WARNING: Identifier pwm_led_esp32_bind_channel_timer length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_nrf.c:511:3-39: WARNING: Identifier z_nrf_clock_calibration_done_handler length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_nrf.c:505:3-40: WARNING: Identifier z_nrf_clock_calibration_lfclk_started length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_nrf.c:210:2-39: WARNING: Identifier z_nrf_clock_calibration_lfclk_stopped length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/timer/altera_avalon_timer_hal.c:40:1-33: WARNING: Identifier IOWR_ALTERA_AVALON_TIMER_PERIODH length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/timer/altera_avalon_timer_hal.c:38:1-33: WARNING: Identifier IOWR_ALTERA_AVALON_TIMER_PERIODL length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_handlers.c:67:8-40: WARNING: Identifier z_impl_i2c_slave_driver_register length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_handlers.c:74:8-42: WARNING: Identifier z_vrfy_i2c_slave_driver_unregister length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32.c:282:1-33: WARNING: Identifier STM32_I2C_IRQ_CONNECT_AND_ENABLE length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:241:1-38: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:311:3-40: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:98:1-38: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:142:2-39: WARNING: Identifier stm32_i2c_disable_transfer_interrupts length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:444:1-37: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:395:1-37: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v2.c:172:2-38: WARNING: Identifier stm32_i2c_enable_transfer_interrupts length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_handlers.c:66:8-41: WARNING: Identifier z_impl_flash_get_page_info_by_idx length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_handlers.c:54:8-42: WARNING: Identifier z_impl_flash_get_page_info_by_offs length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_handlers.c:43:8-41: WARNING: Identifier z_impl_flash_get_write_block_size length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_handlers.c:35:8-41: WARNING: Identifier z_impl_flash_write_protection_set length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_nrfx_spim.c:324:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_nrfx_spim.c:276:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sam0.c:715:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sam0.c:677:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_nrfx_spis.c:247:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_nrfx_spis.c:208:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:18:24-60: WARNING: Identifier pdm_decim_int32_02_4288_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:17:24-60: WARNING: Identifier pdm_decim_int32_02_4375_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:20:24-60: WARNING: Identifier pdm_decim_int32_03_3850_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:19:24-60: WARNING: Identifier pdm_decim_int32_03_4375_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:21:24-60: WARNING: Identifier pdm_decim_int32_04_4375_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:22:24-60: WARNING: Identifier pdm_decim_int32_05_4331_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:23:24-60: WARNING: Identifier pdm_decim_int32_06_4156_5100_010_095 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/decimation/pdm_decim_table.c:24:24-60: WARNING: Identifier pdm_decim_int32_08_4156_5380_010_090 length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_nrfx_saadc.c:406:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_stm32.c:262:1-34: WARNING: Identifier LL_ADC_REG_StartConversionSWStart length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_stm32.c:457:1-37: WARNING: Identifier LL_ADC_SetSamplingTimeCommonChannels length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_stm32.c:696:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/iis2dh/iis2dh_trigger.c:180:5-42: WARNING: Identifier iis2dh_int1_pin_notification_mode_set length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/iis3dhhc/iis3dhhc_trigger.c:163:5-40: WARNING: Identifier iis3dhhc_drdy_notification_mode_set length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:528:5-37: WARNING: Identifier lsm6dso_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:635:5-37: WARNING: Identifier lsm6dso_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:570:6-38: WARNING: Identifier lsm6dso_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:578:6-38: WARNING: Identifier lsm6dso_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:603:5-37: WARNING: Identifier lsm6dso_shub_write_embedded_regs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_stm32.c:69:2-34: WARNING: Identifier LL_DAC_ConvertData12RightAligned length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_handlers.c:135:8-45: WARNING: Identifier z_impl_counter_get_max_relative_alarm length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_handlers.c:128:8-40: WARNING: Identifier z_impl_counter_get_max_top_value length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_handlers.c:38:8-42: WARNING: Identifier z_impl_counter_get_num_of_channels length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_handlers.c:86:8-40: WARNING: Identifier z_impl_counter_set_channel_alarm length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_handlers.c:97:8-43: WARNING: Identifier z_vrfy_counter_cancel_channel_alarm length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lmp90xxx.c:115:8-41: WARNING: Identifier lmp90xxx_gpio_port_clear_bits_raw length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lmp90xxx.c:99:8-41: WARNING: Identifier lmp90xxx_gpio_port_set_masked_raw length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cc13xx_cc26xx.c:599:1-35: WARNING: Identifier UART_CC13XX_CC26XX_DEVICE_API_INIT length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cc13xx_cc26xx.c:591:1-33: WARNING: Identifier UART_CC13XX_CC26XX_DEVICE_DEFINE length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cc13xx_cc26xx.c:460:9-43: WARNING: Identifier uart_cc13xx_cc26xx_set_power_state length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uarte.c:747:16-48: WARNING: Identifier nrf_uarte_errorsrc_get_and_clear length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uarte.c:371:8-40: WARNING: Identifier nrf_uarte_errorsrc_get_and_clear length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uarte.c:1239:3-35: WARNING: Identifier uarte_nrfx_irq_tx_ready_complete length 32 > 31
/Users/yangxueqi/Documents/zephyr/soc/posix/inf_clock/soc.c:232:15-47: WARNING: Identifier __native_FIRST_SLEEP_tasks_start length 32 > 31
/Users/yangxueqi/Documents/zephyr/soc/xtensa/esp32/esp32-mp.c:188:1-35: WARNING: Identifier esp32_rom_ets_set_appcpu_boot_addr length 34 > 31
/Users/yangxueqi/Documents/zephyr/soc/arm/nxp_lpc/lpc55xxx/soc.c:53:1-34: WARNING: Identifier CLOCK_SetFLASHAccessCyclesForFreq length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/power/power.c:128:2-40: WARNING: Identifier _sys_pm_idle_exit_notification_disable length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/power/power.c:190:2-35: WARNING: Identifier _sys_pm_power_state_exit_post_ops length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/power/power.c:164:2-35: WARNING: Identifier _sys_pm_power_state_exit_post_ops length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp.c:523:3-35: WARNING: Identifier gptp_mi_port_bmca_state_machines length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp.c:522:3-35: WARNING: Identifier gptp_mi_port_sync_state_machines length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/sockets_tls.c:861:1-38: WARNING: Identifier mbedtls_ssl_conf_legacy_renegotiation length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/sockets_tls.c:540:10-45: WARNING: Identifier mbedtls_ssl_set_client_transport_id length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:3099:7-40: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:2925:7-40: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6.c:54:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6.c:86:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6.c:392:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6.c:493:7-39: WARNING: Identifier net_if_ipv6_addr_lookup_by_iface length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6.c:501:7-44: WARNING: Identifier net_ipv6_is_addr_mcast_link_all_nodes length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6.c:643:1-36: WARNING: Identifier net_stats_update_ip_errors_protoerr length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/udp.c:64:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:1516:2-34: WARNING: Identifier net_if_ipv6_addr_update_lifetime length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:909:1-39: WARNING: Identifier net_ipv6_addr_create_ll_allnodes_mcast length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:925:1-36: WARNING: Identifier net_ipv6_addr_create_solicited_node length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:1616:2-37: WARNING: Identifier net_ipv6_addr_create_solicited_node length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:3716:1-33: WARNING: Identifier net_stats_add_suspend_start_time length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:374:1-34: WARNING: Identifier net_stats_update_tc_sent_priority length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:294:4-38: WARNING: Identifier net_stats_update_tc_tx_time_detail length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:3223:8-44: WARNING: Identifier z_impl_net_if_ipv4_addr_add_by_index length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:2964:8-47: WARNING: Identifier z_impl_net_if_ipv4_addr_lookup_by_index length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:3259:18-53: WARNING: Identifier z_impl_net_if_ipv4_addr_rm_by_index length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:3061:8-42: WARNING: Identifier z_impl_net_if_ipv4_set_gw_by_index length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:3013:8-47: WARNING: Identifier z_impl_net_if_ipv4_set_netmask_by_index length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:1672:8-44: WARNING: Identifier z_impl_net_if_ipv6_addr_add_by_index length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:1318:8-47: WARNING: Identifier z_impl_net_if_ipv6_addr_lookup_by_index length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:1708:8-43: WARNING: Identifier z_impl_net_if_ipv6_addr_rm_by_index length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv4.c:34:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv4.c:68:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv4.c:201:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv6.c:89:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv6.c:73:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv6.c:365:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv6.c:304:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv6.c:190:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv6.c:205:2-39: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/hci_core.c:7428:8-40: WARNING: Identifier bt_le_per_adv_sync_create_cancel length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/hci_core.c:5683:2-38: WARNING: Identifier le_read_resolving_list_size_complete length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/hci_core.c:5423:1-33: WARNING: Identifier read_supported_commands_complete length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_conn.c:233:3-36: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_test.c:117:1-34: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_test.c:260:1-34: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:619:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:653:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:1524:18-61: WARNING: Identifier USDHC_CLK_TUNE_CTRL_STATUS_DLY_CELL_SET_PRE length 43 > 31
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:1540:24-63: WARNING: Identifier USDHC_HOST_CTRL_CAP_TIME_COUNT_RETUNING length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:1497:18-52: WARNING: Identifier USDHC_TUNING_CTRL_TUNING_START_TAP length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_output_syst.c:134:1-34: WARNING: Identifier MIPI_SYST_ENABLE_HANDLE_TIMESTAMP length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/posix/common/src/main.c:20:12-50: WARNING: Identifier test_posix_multiple_threads_single_key length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/posix/common/src/main.c:21:12-50: WARNING: Identifier test_posix_single_thread_multiple_keys length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/6lo/src/main.c:325:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/6lo/src/main.c:279:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/6lo/src/main.c:302:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/coap/src/main.c:641:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/coap/src/main.c:925:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/coap/src/main.c:1239:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/coap/src/main.c:137:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/ipv6/src/main.c:202:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/ipv6/src/main.c:979:1-33: WARNING: Identifier net_if_ipv6_addr_update_lifetime length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:15:12-52: WARNING: Identifier test_socketpair_AF_LOCAL__SOCK_STREAM__0 length 40 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:16:12-51: WARNING: Identifier test_socketpair_AF_UNIX__SOCK_STREAM__0 length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:36:12-65: WARNING: Identifier test_socketpair_close_one_end_and_read_from_the_other length 53 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:37:12-64: WARNING: Identifier test_socketpair_close_one_end_and_write_to_the_other length 52 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:19:12-45: WARNING: Identifier test_socketpair_expected_failures length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:44:12-56: WARNING: Identifier test_socketpair_poll_close_remote_end_POLLIN length 44 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:45:12-57: WARNING: Identifier test_socketpair_poll_close_remote_end_POLLOUT length 45 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:43:12-45: WARNING: Identifier test_socketpair_poll_delayed_data length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:42:12-47: WARNING: Identifier test_socketpair_poll_immediate_data length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:41:12-52: WARNING: Identifier test_socketpair_poll_timeout_nonblocking length 40 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/main.c:22:12-45: WARNING: Identifier test_socketpair_unsupported_calls length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_basic_api/src/main.c:68:4-45: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_RGMII2_RD2_MUX_MODE length 41 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_basic_api/src/main.c:78:4-45: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_RGMII2_RD3_MUX_MODE length 41 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_basic_api/src/main.c:74:4-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD2_DSE length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_basic_api/src/main.c:73:4-42: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD2_SPEED length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_basic_api/src/main.c:84:4-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD3_DSE length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_basic_api/src/main.c:83:4-42: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_RGMII2_RD3_SPEED length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/shell/src/main.c:330:1-33: WARNING: Identifier shell_backend_dummy_clear_output length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:895:1-34: WARNING: Identifier bst_ticker_set_next_tick_absolute length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_app/src/test_empty.c:20:1-34: WARNING: Identifier bst_ticker_set_next_tick_absolute length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:529:8-42: WARNING: Identifier mbedtls_chachapoly_encrypt_and_tag length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:697:2-44: WARNING: Identifier mbedtls_ctr_drbg_set_prediction_resistance length 42 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:734:2-45: WARNING: Identifier mbedtls_hmac_drbg_set_prediction_resistance length 43 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:762:2-45: WARNING: Identifier mbedtls_hmac_drbg_set_prediction_resistance length 43 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:190:1-36: WARNING: Identifier mbedtls_memory_buffer_alloc_cur_get length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:195:1-36: WARNING: Identifier mbedtls_memory_buffer_alloc_max_get length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/mbedtls/src/benchmark.c:191:1-38: WARNING: Identifier mbedtls_memory_buffer_alloc_max_reset length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:25:12-46: WARNING: Identifier test_mbox_async_put_to_waiting_get length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:21:12-44: WARNING: Identifier test_mbox_block_get_buff_to_pool length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:22:12-52: WARNING: Identifier test_mbox_block_get_buff_to_smaller_pool length 40 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:19:12-44: WARNING: Identifier test_mbox_block_get_invalid_pool length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:26:12-51: WARNING: Identifier test_mbox_get_waiting_put_incorrect_tid length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:16:12-44: WARNING: Identifier test_mbox_incorrect_receiver_tid length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:17:12-44: WARNING: Identifier test_mbox_incorrect_transmit_tid length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:15:12-48: WARNING: Identifier test_mbox_target_source_thread_block length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mbox/mbox_api/src/main.c:14:12-49: WARNING: Identifier test_mbox_target_source_thread_buffer length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/smp/src/main.c:386:10-44: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:268:2-38: WARNING: Identifier _load_then_store_all_float_registers length 36 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_client/src/coap-client.c:166:6-39: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_client/src/coap-client.c:612:5-45: WARNING: Identifier send_simple_coap_msgs_and_wait_for_reply length 40 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:310:1-36: WARNING: Identifier lwm2m_engine_register_exec_callback length 35 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:311:1-36: WARNING: Identifier lwm2m_engine_register_exec_callback length 35 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:356:2-43: WARNING: Identifier lwm2m_engine_register_post_write_callback length 41 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:365:1-42: WARNING: Identifier lwm2m_engine_register_post_write_callback length 41 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:342:1-41: WARNING: Identifier lwm2m_engine_register_pre_write_callback length 40 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:351:1-36: WARNING: Identifier lwm2m_engine_register_read_callback length 35 > 31
/Users/yangxueqi/Documents/zephyr/samples/drivers/counter/maxim_ds3231/src/main.c:241:25-57: WARNING: Identifier maxim_ds3231_syncclock_frequency length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/drivers/counter/maxim_ds3231/src/main.c:123:25-57: WARNING: Identifier maxim_ds3231_syncclock_frequency length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/drivers/counter/maxim_ds3231/src/main.c:185:25-57: WARNING: Identifier maxim_ds3231_syncclock_frequency length 32 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:17:4-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_NAND_DATA02_MUX_MODE length 42 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:28:4-44: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_SD4_DATA4_MUX_MODE length 40 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:30:4-44: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_SD4_DATA5_MUX_MODE length 40 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:22:4-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_NAND_DATA02_DSE length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:21:4-43: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_NAND_DATA02_SPEED length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:36:4-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SD4_DATA4_DSE length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:34:4-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SD4_DATA4_PUS length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:35:4-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SD4_DATA4_SPEED length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:44:4-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SD4_DATA5_DSE length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:42:4-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SD4_DATA5_PUS length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:43:4-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_SD4_DATA5_SPEED length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/udoo_neo_full_m4/pinmux.c:48:3-51: WARNING: Identifier IOMUXC_UART5_IPP_UART_RXD_MUX_SELECT_INPUT_DAISY length 48 > 31
/Users/yangxueqi/Documents/zephyr/kernel/mem_domain.c:275:18-52: WARNING: Identifier arch_mem_domain_max_partitions_get length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/mem_domain.c:226:1-33: WARNING: Identifier arch_mem_domain_partition_remove length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/winc1500/wifi_winc1500.c:617:3-39: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/winc1500/wifi_winc1500.c:632:2-38: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/winc1500/wifi_winc1500.c:625:2-41: WARNING: Identifier wifi_mgmt_raise_disconnect_result_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_kw41z.c:1043:22-54: WARNING: Identifier ZLL_CCA_LQI_CTRL_LQI_OFFSET_COMP length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_kw41z.c:408:9-42: WARNING: Identifier ZLL_MACSHORTADDRS0_MACSHORTADDRS0 length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_kw41z.c:999:24-58: WARNING: Identifier ZLL_RX_FRAME_FILTER_FRM_VER_FILTER length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:344:10-44: WARNING: Identifier FLEXCAN_TransferReceiveNonBlocking length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:575:11-45: WARNING: Identifier FLEXCAN_TransferReceiveNonBlocking length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:27:2-52: WARNING: Identifier FSL_FEATURE_FLEXCAN_HAS_MESSAGE_BUFFER_MAX_NUMBERn length 50 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:566:2-35: WARNING: Identifier mcux_flexcan_copy_frame_to_zframe length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:330:1-38: WARNING: Identifier mcux_flexcan_copy_zfilter_to_mbconfig length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:281:1-34: WARNING: Identifier mcux_flexcan_copy_zframe_to_frame length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:596:2-36: WARNING: Identifier mcux_flexcan_transfer_error_status length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/led/ht16k33.c:255:4-36: WARNING: Identifier ht16k33_process_keyscan_row_data length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/timer/stm32_lptim_timer.c:164:1-33: WARNING: Identifier LL_DBGMCU_APB1_GRP1_FreezePeriph length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_rv32m1_lpi2c.c:243:1-33: WARNING: Identifier LPI2C_MasterTransferCreateHandle length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:384:9-42: WARNING: Identifier i2c_cc13xx_cc26xx_set_power_state length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/entropy/fake_entropy_native_posix.c:61:8-40: WARNING: Identifier entropy_native_posix_get_entropy length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_sam.c:105:8-40: WARNING: Identifier entropy_sam_get_entropy_internal length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_sam.c:145:3-35: WARNING: Identifier entropy_sam_get_entropy_internal length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_mcux.c:554:2-34: WARNING: Identifier eth_mcux_decode_duplex_and_speed length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_stm32.c:306:1-34: WARNING: Identifier LL_AHB1_GRP1_DisableClockLowPower length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nrf.c:323:2-36: WARNING: Identifier nrf_flash_sync_get_timestamp_begin length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nrf.c:384:2-36: WARNING: Identifier nrf_flash_sync_get_timestamp_begin length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nrf.c:343:6-43: WARNING: Identifier nrfx_nvmc_page_partial_erase_continue length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nrf.c:338:3-36: WARNING: Identifier nrfx_nvmc_page_partial_erase_init length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:222:9-49: WARNING: Identifier LL_FLASH_IsActiveFlag_OperationSuspended length 40 > 31
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:93:9-49: WARNING: Identifier LL_FLASH_IsActiveFlag_OperationSuspended length 40 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_oc_simple.c:194:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_oc_simple.c:174:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_cc13xx_cc26xx.c:265:9-42: WARNING: Identifier spi_cc13xx_cc26xx_set_power_state length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_cc13xx_cc26xx.c:363:2-36: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_cc13xx_cc26xx.c:209:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_dw.c:535:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_dw.c:475:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_rv32m1_lpspi.c:191:1-33: WARNING: Identifier LPSPI_MasterTransferCreateHandle length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_rv32m1_lpspi.c:273:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_rv32m1_lpspi.c:257:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/intel_dmic.c:776:2-34: WARNING: Identifier OUTCONTROL0_NUMBER_OF_DECIMATORS length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/audio/intel_dmic.c:791:2-34: WARNING: Identifier OUTCONTROL1_NUMBER_OF_DECIMATORS length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam0.c:495:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam_afec.c:299:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl362/adxl362.c:650:1-33: WARNING: Identifier adxl362_setup_activity_detection length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl362/adxl362.c:672:1-35: WARNING: Identifier adxl362_setup_inactivity_detection length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/spi.c:185:2-45: WARNING: Identifier bt_spi_send_aci_config_data_controller_mode length 43 > 31
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/spi.c:126:11-54: WARNING: Identifier bt_spi_send_aci_config_data_controller_mode length 43 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:47:3-36: WARNING: Identifier LL_C1_IPCC_DisableTransmitChannel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:43:3-35: WARNING: Identifier LL_C1_IPCC_EnableTransmitChannel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:45:3-35: WARNING: Identifier LL_C2_IPCC_DisableReceiveChannel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:73:3-35: WARNING: Identifier LL_C2_IPCC_DisableReceiveChannel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:75:3-36: WARNING: Identifier LL_C2_IPCC_DisableTransmitChannel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:71:3-35: WARNING: Identifier LL_C2_IPCC_EnableTransmitChannel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_nrfx_ipc.c:94:2-38: WARNING: Identifier nrfx_ipc_receive_event_group_disable length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_nrfx_ipc.c:91:2-37: WARNING: Identifier nrfx_ipc_receive_event_group_enable length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_mcux_lpc.c:114:22-57: WARNING: Identifier FSL_FEATURE_DMA_NUMBER_OF_CHANNELSn length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_mcux_lpc.c:320:22-57: WARNING: Identifier FSL_FEATURE_DMA_NUMBER_OF_CHANNELSn length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_nios2_msgdma.c:114:11-60: WARNING: Identifier alt_msgdma_construct_standard_mm_to_mm_descriptor length 49 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_nios2_msgdma.c:121:11-60: WARNING: Identifier alt_msgdma_construct_standard_mm_to_st_descriptor length 49 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_nios2_msgdma.c:127:11-60: WARNING: Identifier alt_msgdma_construct_standard_st_to_mm_descriptor length 49 > 31
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_nios2_msgdma.c:166:10-55: WARNING: Identifier alt_msgdma_standard_descriptor_async_transfer length 45 > 31
/Users/yangxueqi/Documents/zephyr/drivers/display/ssd16xx.c:611:1-34: WARNING: Identifier ssd16xx_set_orientation_internall length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:859:25-57: WARNING: Identifier maxim_ds3231_syncclock_frequency length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:1345:6-39: WARNING: Identifier z_impl_maxim_ds3231_get_syncpoint length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:1364:8-41: WARNING: Identifier z_impl_maxim_ds3231_req_syncpoint length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_xlnx_axi.c:261:3-45: WARNING: Identifier GPIO_XLNX_AXI_GPIO2_HAS_COMPAT_STATUS_OKAY length 42 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_pca95xx.c:423:8-40: WARNING: Identifier gpio_pca95xx_port_set_masked_raw length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_pca95xx.c:417:8-40: WARNING: Identifier gpio_pca95xx_port_set_masked_raw length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_dw.c:472:9-41: WARNING: Identifier gpio_dw_resume_from_suspend_port length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cmsdk_ahb.c:125:3-37: WARNING: Identifier gpio_cmsdk_ahb_port_clear_bits_raw length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cmsdk_ahb.c:123:3-35: WARNING: Identifier gpio_cmsdk_ahb_port_set_bits_raw length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux.c:214:16-50: WARNING: Identifier get_port_pcr_irqc_value_from_flags length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_litex.c:27:19-53: WARNING: Identifier LITEX_LOG_REG_SIZE_NGPIOS_MISMATCH length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_msp432p4xx.c:127:1-47: WARNING: Identifier MAP_GPIO_setAsPeripheralModuleFunctionInputPin length 46 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_msp432p4xx.c:292:14-48: WARNING: Identifier MAP_UART_getEnabledInterruptStatus length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_msp432p4xx.c:328:14-48: WARNING: Identifier MAP_UART_getEnabledInterruptStatus length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_altera_jtag_hal.c:45:1-37: WARNING: Identifier IOWR_ALTERA_AVALON_JTAG_UART_CONTROL length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/tracing/sysview/sysview.c:57:1-40: WARNING: Identifier SEGGER_SYSVIEW_RecordExitISRToScheduler length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/updatehub/updatehub.c:324:8-41: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:486:7-41: WARNING: Identifier ethernet_fill_in_dst_on_ipv4_mcast length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:507:7-41: WARNING: Identifier ethernet_fill_in_dst_on_ipv4_mcast length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:487:7-41: WARNING: Identifier ethernet_fill_in_dst_on_ipv6_mcast length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:508:7-41: WARNING: Identifier ethernet_fill_in_dst_on_ipv6_mcast length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:344:5-44: WARNING: Identifier ethernet_ipv4_dst_is_broadcast_or_mcast length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:1015:1-38: WARNING: Identifier ethernet_mgmt_raise_carrier_off_event length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:1002:1-37: WARNING: Identifier ethernet_mgmt_raise_carrier_on_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:980:1-40: WARNING: Identifier ethernet_mgmt_raise_vlan_disabled_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:938:2-40: WARNING: Identifier ethernet_mgmt_raise_vlan_enabled_event length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/ethernet.c:1087:8-45: WARNING: Identifier z_impl_net_eth_get_ptp_clock_by_index length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:1139:16-55: WARNING: Identifier gptp_get_current_master_time_nanosecond length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:1171:3-42: WARNING: Identifier gptp_get_current_master_time_nanosecond length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:1018:17-56: WARNING: Identifier gptp_get_current_master_time_nanosecond length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:953:16-55: WARNING: Identifier gptp_get_current_master_time_nanosecond length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:366:10-42: WARNING: Identifier gptp_get_current_time_nanosecond length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:398:34-66: WARNING: Identifier gptp_get_current_time_nanosecond length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2014:1-45: WARNING: Identifier gptp_mi_clk_master_sync_offset_state_machine length 44 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2018:1-42: WARNING: Identifier gptp_mi_clk_master_sync_rcv_state_machine length 41 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2016:1-42: WARNING: Identifier gptp_mi_clk_master_sync_snd_state_machine length 41 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2012:1-37: WARNING: Identifier gptp_mi_clk_slave_sync_state_machine length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:330:1-38: WARNING: Identifier gptp_mi_init_clock_master_sync_rcv_sm length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:328:1-33: WARNING: Identifier gptp_mi_init_clock_slave_sync_sm length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:322:2-36: WARNING: Identifier gptp_mi_init_port_announce_info_sm length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:321:2-35: WARNING: Identifier gptp_mi_init_port_announce_rcv_sm length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:323:2-40: WARNING: Identifier gptp_mi_init_port_announce_transmit_sm length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:329:1-36: WARNING: Identifier gptp_mi_init_port_role_selection_sm length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:319:2-36: WARNING: Identifier gptp_mi_init_port_sync_sync_rcv_sm length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:320:2-37: WARNING: Identifier gptp_mi_init_port_sync_sync_send_sm length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2005:1-48: WARNING: Identifier gptp_mi_port_announce_information_state_machine length 47 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2004:1-44: WARNING: Identifier gptp_mi_port_announce_receive_state_machine length 43 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2006:1-45: WARNING: Identifier gptp_mi_port_announce_transmit_state_machine length 44 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2013:1-42: WARNING: Identifier gptp_mi_port_role_selection_state_machine length 41 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:672:4-36: WARNING: Identifier gptp_mi_site_ss_prepare_pss_send length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ethernet/gptp/gptp_mi.c:2011:1-37: WARNING: Identifier gptp_mi_site_sync_sync_state_machine length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_rd_client.c:685:8-41: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/mqtt/mqtt.c:718:12-46: WARNING: Identifier mqtt_read_publish_payload_blocking length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_tc.c:197:2-35: WARNING: Identifier net_stats_update_tc_recv_priority length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_tc.c:187:2-35: WARNING: Identifier net_stats_update_tc_sent_priority length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_fragment.c:52:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_fragment.c:228:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_fragment.c:468:1-33: WARNING: Identifier net_pkt_set_ipv6_fragment_offset length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/connection.c:757:3-35: WARNING: Identifier net_stats_update_tcp_seg_connrst length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1716:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1149:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:2282:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:774:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1052:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1829:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1789:10-42: WARNING: Identifier net_if_ipv6_addr_lookup_by_iface length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1237:11-43: WARNING: Identifier net_if_ipv6_addr_lookup_by_iface length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1352:11-43: WARNING: Identifier net_if_ipv6_addr_lookup_by_iface length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:2178:3-35: WARNING: Identifier net_if_ipv6_addr_update_lifetime length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:2186:3-35: WARNING: Identifier net_if_ipv6_addr_update_lifetime length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:2440:3-37: WARNING: Identifier net_if_ipv6_router_update_lifetime length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:2329:2-37: WARNING: Identifier net_if_ipv6_set_base_reachable_time length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1317:2-40: WARNING: Identifier net_ipv6_addr_create_ll_allnodes_mcast length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1972:1-41: WARNING: Identifier net_ipv6_addr_create_ll_allrouters_mcast length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1839:2-37: WARNING: Identifier net_ipv6_addr_create_solicited_node length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1628:3-35: WARNING: Identifier net_ipv6_nbr_set_reachable_timer length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:1671:3-35: WARNING: Identifier net_ipv6_nbr_set_reachable_timer length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_ops.c:91:12-47: WARNING: Identifier column_span_with_buffer_offsets_get length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_ops.c:88:12-44: WARNING: Identifier row_span_with_buffer_offsets_get length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_ops.c:353:2-38: WARNING: Identifier shell_op_cursor_position_synchronize length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/usb/usb_descriptor.c:427:4-38: WARNING: Identifier usb_fix_ascii_sn_string_descriptor length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c:228:3-36: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c:711:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:670:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:705:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c:715:2-35: WARNING: Identifier radio_switch_complete_and_disable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1564:22-55: WARNING: Identifier GENFSK_DSM_CTRL_GEN_SLEEP_REQUEST length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:528:20-54: WARNING: Identifier GENFSK_IRQ_CTRL_GENERIC_FSK_IRQ_EN length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:529:6-41: WARNING: Identifier GENFSK_IRQ_CTRL_RX_WATERMARK_IRQ_EN length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:688:4-36: WARNING: Identifier GENFSK_NTW_ADR_CTRL_NTW_ADR_THR0 length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:728:2-34: WARNING: Identifier GENFSK_PACKET_CFG_LENGTH_BIT_ORD length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:517:24-56: WARNING: Identifier GENFSK_PB_PARTITION_PB_PARTITION length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:745:24-56: WARNING: Identifier GENFSK_RX_WATERMARK_RX_WATERMARK length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:670:5-37: WARNING: Identifier GENFSK_WHITEN_CFG_MANCHESTER_INV length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:671:5-39: WARNING: Identifier GENFSK_WHITEN_CFG_MANCHESTER_START length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:667:5-44: WARNING: Identifier GENFSK_WHITEN_CFG_WHITEN_PAYLOAD_REINIT length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:665:5-39: WARNING: Identifier GENFSK_WHITEN_CFG_WHITEN_POLY_TYPE length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:536:26-58: WARNING: Identifier GENFSK_WHITEN_SZ_THR_REC_BAD_PKT length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:678:26-60: WARNING: Identifier GENFSK_WHITEN_SZ_THR_WHITEN_SZ_THR length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1561:23-61: WARNING: Identifier RSIM_DSM_CONTROL_MAN_WAKEUP_REQUEST_EN length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:507:25-59: WARNING: Identifier XCVR_CTRL_XCVR_CTRL_RADIO0_IRQ_SEL length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:459:3-49: WARNING: Identifier XCVR_PLL_DIG_HPMCAL_CTRL_HPM_CAL_FACTOR_MANUAL length 46 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:470:3-41: WARNING: Identifier XCVR_TSM_TIMING38_SIGMA_DELTA_EN_TX_HI length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots.c:183:3-37: WARNING: Identifier bt_gatt_ots_obj_manager_obj_delete length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots.c:213:7-41: WARNING: Identifier bt_gatt_ots_obj_manager_obj_delete length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_olcp.c:46:7-44: WARNING: Identifier bt_gatt_ots_obj_manager_first_obj_get length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_olcp.c:63:7-43: WARNING: Identifier bt_gatt_ots_obj_manager_last_obj_get length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_olcp.c:104:7-43: WARNING: Identifier bt_gatt_ots_obj_manager_next_obj_get length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_olcp.c:83:7-43: WARNING: Identifier bt_gatt_ots_obj_manager_prev_obj_get length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:573:1-33: WARNING: Identifier otPlatRadioAddSrcMatchShortEntry length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:597:1-35: WARNING: Identifier otPlatRadioClearSrcMatchExtEntries length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:590:1-33: WARNING: Identifier otPlatRadioClearSrcMatchExtEntry length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:594:1-37: WARNING: Identifier otPlatRadioClearSrcMatchShortEntries length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:586:1-35: WARNING: Identifier otPlatRadioClearSrcMatchShortEntry length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:517:20-52: WARNING: Identifier otPlatRadioGetReceiveSensitivity length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_app/src/test_connect2.c:56:1-34: WARNING: Identifier bst_ticker_set_next_tick_absolute length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_app/src/test_connect1.c:77:1-34: WARNING: Identifier bst_ticker_set_next_tick_absolute length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/boards/intel_s1000_crb/main/src/i2s_test.c:169:1-42: WARNING: Identifier test_i2s_bidirectional_transfer_configure length 41 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_q31.c:92:1-34: WARNING: Identifier arm_biquad_cas_df1_32x64_init_q31 length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_f64.c:40:1-33: WARNING: Identifier arm_biquad_cascade_df2T_init_f64 length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_f64.c:97:2-34: WARNING: Identifier arm_biquad_cascade_df2T_init_f64 length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/gui/lvgl/src/main.c:132:27-62: WARNING: Identifier ztest_user_unit_test_setup_teardown length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:966:15-47: WARNING: Identifier DT_INST_IO_CHANNELS_INPUT_BY_IDX length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:967:15-47: WARNING: Identifier DT_INST_IO_CHANNELS_INPUT_BY_IDX length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:968:15-48: WARNING: Identifier DT_INST_IO_CHANNELS_INPUT_BY_NAME length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:969:15-48: WARNING: Identifier DT_INST_IO_CHANNELS_INPUT_BY_NAME length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:942:22-54: WARNING: Identifier DT_INST_IO_CHANNELS_LABEL_BY_IDX length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:945:22-54: WARNING: Identifier DT_INST_IO_CHANNELS_LABEL_BY_IDX length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:948:22-55: WARNING: Identifier DT_INST_IO_CHANNELS_LABEL_BY_NAME length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:951:22-55: WARNING: Identifier DT_INST_IO_CHANNELS_LABEL_BY_NAME length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_server/src/coap-server.c:1179:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_server/src/coap-server.c:749:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_server/src/coap-server.c:248:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_server/src/coap-server.c:512:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_server/src/coap-server.c:1059:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/coap_server/src/coap-server.c:663:5-38: WARNING: Identifier coap_packet_append_payload_marker length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c:79:5-37: WARNING: Identifier audio_core_is_tuning_reply_ready length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c:57:1-33: WARNING: Identifier audio_core_tuning_interface_init length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/ti/cc13x2_cc26x2/system_off/src/ext_flash.c:100:1-35: WARNING: Identifier CC1352R1_LAUNCHXL_sendExtFlashByte length 34 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/ti/cc13x2_cc26x2/system_off/src/ext_flash.c:98:1-33: WARNING: Identifier CC1352R1_LAUNCHXL_wakeUpExtFlash length 32 > 31
/Users/yangxueqi/Documents/zephyr/arch/x86/core/x86_mmu.c:1120:2-34: WARNING: Identifier arch_mem_domain_partition_remove length 32 > 31
/Users/yangxueqi/Documents/zephyr/arch/arc/core/mpu/arc_core_mpu.c:32:8-53: WARNING: Identifier arc_core_mpu_get_max_domain_partition_regions length 45 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/nrf52_bsim/irq_handler.c:142:19-51: WARNING: Identifier hw_irq_ctrl_get_highest_prio_irq length 32 > 31
/Users/yangxueqi/Documents/zephyr/boards/posix/nrf52_bsim/irq_handler.c:185:5-37: WARNING: Identifier hw_irq_ctrl_get_highest_prio_irq length 32 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:80:32-66: WARNING: Identifier IOMUXC_I2C1_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:81:32-66: WARNING: Identifier IOMUXC_I2C1_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:104:32-66: WARNING: Identifier IOMUXC_I2C2_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:105:32-66: WARNING: Identifier IOMUXC_I2C2_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:128:32-66: WARNING: Identifier IOMUXC_I2C3_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:129:32-66: WARNING: Identifier IOMUXC_I2C3_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:152:32-66: WARNING: Identifier IOMUXC_I2C4_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:153:32-66: WARNING: Identifier IOMUXC_I2C4_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:54:2-44: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_ECSPI1_MOSI_MUX_MODE length 42 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:52:2-44: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_ECSPI1_SCLK_MUX_MODE length 42 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:15:2-48: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_ENET1_RGMII_RD0_MUX_MODE length 46 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:25:2-48: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_ENET1_RGMII_RD1_MUX_MODE length 46 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:74:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:77:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:98:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:101:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:122:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C3_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:125:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C3_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:146:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C4_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:149:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C4_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:30:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART2_RX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:32:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART2_TX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:65:2-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_DSE length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:63:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ECSPI1_MOSI_PS length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:59:2-39: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_DSE length 37 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:57:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ECSPI1_SCLK_PS length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:20:2-43: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ENET1_RGMII_RD0_DSE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:18:2-42: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ENET1_RGMII_RD0_PS length 40 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:86:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:85:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:92:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:91:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:110:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:109:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:116:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:115:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:134:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:133:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:140:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:139:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:158:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:157:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:164:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:163:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C4_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:37:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:35:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:43:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:41:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:47:2-41: WARNING: Identifier IOMUXC_UART2_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/warp7_m4/pinmux.c:69:2-41: WARNING: Identifier IOMUXC_UART6_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:31:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:33:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:38:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_RX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:36:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_RX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:44:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_TX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:42:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART1_TX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/96b_meerkat96/pinmux.c:48:2-41: WARNING: Identifier IOMUXC_UART1_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:59:32-66: WARNING: Identifier IOMUXC_I2C1_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:60:32-66: WARNING: Identifier IOMUXC_I2C1_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:83:32-66: WARNING: Identifier IOMUXC_I2C2_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:84:32-66: WARNING: Identifier IOMUXC_I2C2_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:107:32-66: WARNING: Identifier IOMUXC_I2C3_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:108:32-66: WARNING: Identifier IOMUXC_I2C3_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:131:32-66: WARNING: Identifier IOMUXC_I2C4_SCL_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:132:32-66: WARNING: Identifier IOMUXC_I2C4_SDA_SELECT_INPUT_DAISY length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:125:2-48: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_ENET1_RGMII_TD2_MUX_MODE length 46 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:128:2-48: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_ENET1_RGMII_TD3_MUX_MODE length 46 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:149:2-43: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08_MUX_MODE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:159:2-43: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09_MUX_MODE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:169:2-43: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO10_MUX_MODE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:179:2-43: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO11_MUX_MODE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:53:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C1_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:56:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C1_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:77:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C2_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:80:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C2_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:101:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C3_SCL_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:104:2-41: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_I2C3_SDA_MUX_MODE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:31:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART2_RX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:33:2-46: WARNING: Identifier IOMUXC_SW_MUX_CTL_PAD_UART2_TX_DATA_MUX_MODE length 44 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:137:2-43: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ENET1_RGMII_TD2_DSE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:136:2-42: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ENET1_RGMII_TD2_PS length 40 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:143:2-43: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ENET1_RGMII_TD3_DSE length 41 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:142:2-42: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_ENET1_RGMII_TD3_PS length 40 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:24:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_EPDC_GDRL_PS length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:153:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO08_DSE length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:152:2-37: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO08_PS length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:163:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO09_DSE length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:162:2-37: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO09_PS length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:173:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO10_DSE length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:172:2-37: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO10_PS length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:183:2-38: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO11_DSE length 36 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:182:2-37: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO11_PS length 35 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:65:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:64:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:71:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:70:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C1_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:89:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:88:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:95:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:94:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C2_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:113:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SCL_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:112:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SCL_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:119:2-36: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SDA_DSE length 34 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:118:2-35: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_I2C3_SDA_PS length 33 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:38:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:36:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:44:2-41: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA_DSE length 39 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:42:2-40: WARNING: Identifier IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA_PS length 38 > 31
/Users/yangxueqi/Documents/zephyr/boards/arm/colibri_imx7d_m4/pinmux.c:48:2-41: WARNING: Identifier IOMUXC_UART2_RX_DATA_SELECT_INPUT_DAISY length 39 > 31
/Users/yangxueqi/Documents/zephyr/kernel/timeout.c:38:8-52: WARNING: Identifier z_impl_z_clock_hw_cycles_per_sec_runtime_get length 44 > 31
/Users/yangxueqi/Documents/zephyr/kernel/queue.c:103:1-36: WARNING: Identifier z_thread_return_value_set_with_data length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/simplelink/simplelink.c:60:2-38: WARNING: Identifier wifi_mgmt_raise_connect_result_event length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/simplelink/simplelink.c:66:2-41: WARNING: Identifier wifi_mgmt_raise_disconnect_result_event length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/wifi/simplelink/simplelink_support.c:566:5-40: WARNING: Identifier SL_WLAN_SCAN_RESULT_SEC_TYPE_BITMAP length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/crypto/crypto_stm32.c:308:11-48: WARNING: Identifier crypto_stm32_get_unused_session_index length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/led/lp5562.c:843:10-43: WARNING: Identifier lp5562_update_blinking_brightness length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nios2.c:120:12-55: WARNING: Identifier alt_avalon_i2c_interrupt_transaction_status length 43 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nios2.c:97:12-58: WARNING: Identifier alt_avalon_i2c_master_receive_using_interrupts length 46 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nios2.c:93:2-34: WARNING: Identifier alt_avalon_i2c_master_target_set length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nios2.c:102:12-59: WARNING: Identifier alt_avalon_i2c_master_transmit_using_interrupts length 47 > 31
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nios2.c:72:1-45: WARNING: Identifier alt_avalon_i2c_register_optional_irq_handler length 44 > 31
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_cc13xx_cc26xx.c:310:9-46: WARNING: Identifier entropy_cc13xx_cc26xx_set_power_state length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_nrf5.c:361:2-34: WARNING: Identifier nrf_rng_error_correction_disable length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1098:1-37: WARNING: Identifier disable_all_priority_queue_interrupt length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:2083:9-45: WARNING: Identifier eth_sam_gmac_get_qav_delta_bandwidth length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:2017:9-47: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1123:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1135:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1136:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1138:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1139:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1140:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1142:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1143:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1144:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1145:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1147:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1148:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1149:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1150:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1151:1-39: WARNING: Identifier eth_sam_gmac_setup_qav_delta_bandwidth length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:2025:9-42: WARNING: Identifier eth_sam_gmac_setup_qav_idle_slope length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:1039:8-41: WARNING: Identifier eth_sam_gmac_setup_qav_idle_slope length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_ll_stm32.c:371:1-33: WARNING: Identifier ll_func_disable_int_rx_not_empty length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_ll_stm32.c:827:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_ll_stm32.c:552:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_nrfx_spi.c:282:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_nrfx_spi.c:234:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sam.c:439:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sam.c:425:1-35: WARNING: Identifier spi_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_iwdg_stm32.c:77:2-34: WARNING: Identifier LL_DBGMCU_APB1_GRP1_FreezePeriph length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:168:2-35: WARNING: Identifier wdt_gecko_get_persel_from_timeout length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:62:6-39: WARNING: Identifier wdt_gecko_get_timeout_from_persel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:156:24-57: WARNING: Identifier wdt_gecko_get_timeout_from_persel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:157:21-54: WARNING: Identifier wdt_gecko_get_timeout_from_persel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:170:21-54: WARNING: Identifier wdt_gecko_get_timeout_from_persel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:1058:1-35: WARNING: Identifier adc_context_unlock_unconditionally length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/vl53l0x/vl53l0x.c:122:7-39: WARNING: Identifier VL53L0X_PerformRefSpadManagement length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/vl53l0x/vl53l0x.c:58:7-46: WARNING: Identifier VL53L0X_PerformSingleRangingMeasurement length 39 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/vl53l0x/vl53l0x.c:170:7-53: WARNING: Identifier VL53L0X_SetMeasurementTimingBudgetMicroSeconds length 46 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/stts751/stts751_trigger.c:160:1-39: WARNING: Identifier stts751_high_temperature_threshold_set length 38 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/stts751/stts751_trigger.c:163:1-38: WARNING: Identifier stts751_low_temperature_threshold_set length 37 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso.c:355:5-37: WARNING: Identifier lsm6dso_shub_fetch_external_devs length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:648:5-38: WARNING: Identifier ism330dhcx_sh_slave_connected_set length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:503:5-39: WARNING: Identifier ism330dhcx_shub_read_embedded_regs length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:790:1-33: WARNING: Identifier ism330dhcx_shub_set_data_channel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:530:5-40: WARNING: Identifier ism330dhcx_shub_write_embedded_regs length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:638:5-40: WARNING: Identifier ism330dhcx_shub_write_embedded_regs length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:573:6-41: WARNING: Identifier ism330dhcx_shub_write_embedded_regs length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:581:6-41: WARNING: Identifier ism330dhcx_shub_write_embedded_regs length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:606:5-40: WARNING: Identifier ism330dhcx_shub_write_embedded_regs length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl372/adxl372.c:431:10-43: WARNING: Identifier ADXL372_POWER_CTL_FIL_SETTLE_MODE length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl372/adxl372.c:362:4-40: WARNING: Identifier ADXL372_POWER_CTL_INSTANT_ON_TH_MODE length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl372/adxl372.c:384:10-42: WARNING: Identifier ADXL372_TIMING_WAKE_UP_RATE_MODE length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl372/adxl372.c:677:9-43: WARNING: Identifier adxl372_set_activity_threshold_xyz length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl372/adxl372.c:833:7-41: WARNING: Identifier adxl372_set_activity_threshold_xyz length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl372/adxl372.c:839:7-41: WARNING: Identifier adxl372_set_activity_threshold_xyz length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/ipm_stm32wb.c:254:1-33: WARNING: Identifier LL_C1_IPCC_DisableReceiveChannel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/ipm_stm32wb.c:244:1-34: WARNING: Identifier LL_C1_IPCC_DisableTransmitChannel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/ipm_stm32wb.c:259:1-33: WARNING: Identifier LL_C2_IPCC_DisableReceiveChannel length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/ipm_stm32wb.c:249:1-34: WARNING: Identifier LL_C2_IPCC_DisableTransmitChannel length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1889:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1890:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1891:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1892:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1893:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1894:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1895:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1896:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1897:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2278:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2279:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2280:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2281:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2282:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2283:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2284:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:2285:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1859:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1860:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1861:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1826:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1827:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1828:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1829:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1830:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1831:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1832:2-36: WARNING: Identifier PREFIXED_SWITCH_CASE_RETURN_STRING length 34 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_handlers.c:70:8-43: WARNING: Identifier z_impl_gpio_pin_interrupt_configure length 35 > 31
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_sam.c:264:8-41: WARNING: Identifier gpio_sam_port_interrupt_configure length 33 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_mcux_flexcomm.c:304:11-47: WARNING: Identifier UART_MCUX_FLEXCOMM_IRQ_CFG_FUNC_INIT length 36 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cmsdk_apb.c:463:12-44: WARNING: Identifier uart_cmsdk_apb_irq_config_func_0 length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cmsdk_apb.c:528:12-44: WARNING: Identifier uart_cmsdk_apb_irq_config_func_1 length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cmsdk_apb.c:593:12-44: WARNING: Identifier uart_cmsdk_apb_irq_config_func_2 length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cmsdk_apb.c:658:12-44: WARNING: Identifier uart_cmsdk_apb_irq_config_func_3 length 32 > 31
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cmsdk_apb.c:723:12-44: WARNING: Identifier uart_cmsdk_apb_irq_config_func_4 length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ieee802154/ieee802154_frame.c:453:3-39: WARNING: Identifier ieee802154_validate_aux_security_hdr length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ppp/ppp_l2.c:280:1-33: WARNING: Identifier ppp_mgmt_raise_carrier_off_event length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/canbus/6locan.c:1241:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/canbus/6locan.c:1242:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/canbus/6locan.c:1244:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/canbus/6locan.c:1347:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/getaddrinfo.c:312:7-42: WARNING: Identifier z_impl_z_zsock_getaddrinfo_internal length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:304:3-35: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:249:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:256:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:206:3-35: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:224:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:226:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:231:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_firmware.c:233:2-34: WARNING: Identifier lwm2m_firmware_set_update_result length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_core.c:124:1-36: WARNING: Identifier net_stats_update_ip_errors_protoerr length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_core.c:125:1-34: WARNING: Identifier net_stats_update_ip_errors_vhlerr length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_core.c:82:2-35: WARNING: Identifier net_stats_update_processing_error length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_core.c:92:4-37: WARNING: Identifier net_stats_update_processing_error length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_core.c:368:1-34: WARNING: Identifier net_stats_update_tc_recv_priority length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv4.c:35:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv4.c:53:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv4.c:666:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv4.c:504:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv4.c:574:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/icmpv4.c:588:2-39: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:521:5-37: WARNING: Identifier net_6lo_addr_16_bit_compressible length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:566:5-37: WARNING: Identifier net_6lo_addr_16_bit_compressible length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:379:5-37: WARNING: Identifier net_6lo_addr_16_bit_compressible length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:427:5-37: WARNING: Identifier net_6lo_addr_16_bit_compressible length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:755:5-40: WARNING: Identifier net_6lo_ll_prefix_padded_with_zeros length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:777:5-40: WARNING: Identifier net_6lo_ll_prefix_padded_with_zeros length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:469:5-38: WARNING: Identifier net_6lo_maddr_32_bit_compressible length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:484:5-38: WARNING: Identifier net_6lo_maddr_48_bit_compressible length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:457:5-37: WARNING: Identifier net_6lo_maddr_8_bit_compressible length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_mld.c:303:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_pkt.c:431:9-42: WARNING: Identifier net_pkt_get_reserve_rx_data_debug length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_pkt.c:439:8-41: WARNING: Identifier net_pkt_get_reserve_tx_data_debug length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_telnet.c:161:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/pb_adv.c:509:3-35: WARNING: Identifier bt_test_mesh_prov_invalid_bearer length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/audio/iso.c:341:8-40: WARNING: Identifier bt_conn_create_pdu_timeout_debug length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/audio/iso.c:319:8-40: WARNING: Identifier bt_conn_create_pdu_timeout_debug length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/smp.c:5084:8-48: WARNING: Identifier compute_and_check_and_send_slave_dhcheck length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/smp.c:3430:8-48: WARNING: Identifier compute_and_check_and_send_slave_dhcheck length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/smp.c:4202:9-49: WARNING: Identifier compute_and_check_and_send_slave_dhcheck length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:437:3-39: WARNING: Identifier HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:488:4-40: WARNING: Identifier HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:435:6-39: WARNING: Identifier HAL_SW_SWITCH_RADIO_ENABLE_S2_PPI length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:485:4-37: WARNING: Identifier HAL_SW_SWITCH_RADIO_ENABLE_S2_PPI length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:684:1-33: WARNING: Identifier hal_event_timer_start_ppi_config length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:733:1-33: WARNING: Identifier hal_event_timer_start_ppi_config length 32 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:803:1-37: WARNING: Identifier hal_radio_disable_on_hcto_ppi_config length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:687:1-47: WARNING: Identifier hal_radio_enable_on_tick_ppi_config_and_enable length 46 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:758:1-47: WARNING: Identifier hal_radio_enable_on_tick_ppi_config_and_enable length 46 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:736:1-47: WARNING: Identifier hal_radio_enable_on_tick_ppi_config_and_enable length 46 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:751:1-47: WARNING: Identifier hal_radio_enable_on_tick_ppi_config_and_enable length 46 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:843:1-38: WARNING: Identifier hal_radio_end_time_capture_ppi_config length 37 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:707:1-39: WARNING: Identifier hal_radio_group_task_disable_ppi_setup length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:970:1-35: WARNING: Identifier hal_radio_nrf_ppi_channels_disable length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:637:1-35: WARNING: Identifier hal_radio_nrf_ppi_channels_disable length 34 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:1124:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:1019:2-35: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:1046:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:964:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:813:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:844:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:804:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:685:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:734:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:506:1-34: WARNING: Identifier hal_radio_nrf_ppi_channels_enable length 33 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:811:1-40: WARNING: Identifier hal_radio_ready_time_capture_ppi_config length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:812:1-41: WARNING: Identifier hal_radio_recv_timeout_cancel_ppi_config length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:802:1-41: WARNING: Identifier hal_radio_recv_timeout_cancel_ppi_config length 40 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:468:3-41: WARNING: Identifier hal_radio_sw_switch_coded_config_clear length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:491:3-41: WARNING: Identifier hal_radio_sw_switch_coded_config_clear length 38 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:463:3-42: WARNING: Identifier hal_radio_sw_switch_coded_tx_config_set length 39 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:119:1-36: WARNING: Identifier hal_radio_sw_switch_ppi_group_setup length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:702:1-37: WARNING: Identifier hal_sw_switch_timer_clear_ppi_config length 36 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:1018:2-37: WARNING: Identifier hal_trigger_rateoverride_ppi_config length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/hci/hci.c:2574:1-36: WARNING: Identifier hci_vendor_read_key_hierarchy_roots length 35 > 31
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/hci/hci.c:1699:10-45: WARNING: Identifier ll_adv_set_by_hci_handle_get_or_new length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/mbedtls/src/mbedtls.c:409:1-33: WARNING: Identifier mbedtls_memory_buffer_alloc_free length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/mbedtls/src/mbedtls.c:198:1-33: WARNING: Identifier mbedtls_memory_buffer_alloc_init length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/mbedtls/src/mbedtls.c:410:5-42: WARNING: Identifier mbedtls_memory_buffer_alloc_self_test length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/mbedtls/src/mbedtls.c:404:2-36: WARNING: Identifier mbedtls_memory_buffer_alloc_status length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/mbedtls/src/mbedtls.c:134:10-43: WARNING: Identifier mbedtls_platform_std_nv_seed_read length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/crypto/mbedtls/src/mbedtls.c:152:1-35: WARNING: Identifier mbedtls_platform_std_nv_seed_write length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/context/src/main.c:239:1-39: WARNING: Identifier net_ipv6_addr_create_ll_allnodes_mcast length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:641:7-39: WARNING: Identifier net_if_ipv4_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:644:7-39: WARNING: Identifier net_if_ipv4_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:681:7-39: WARNING: Identifier net_if_ipv4_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:684:7-39: WARNING: Identifier net_if_ipv4_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:799:7-39: WARNING: Identifier net_if_ipv4_set_netmask_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:725:7-39: WARNING: Identifier net_if_ipv6_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:728:7-39: WARNING: Identifier net_if_ipv6_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:768:7-39: WARNING: Identifier net_if_ipv6_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/iface/src/main.c:771:7-39: WARNING: Identifier net_if_ipv6_addr_lookup_by_index length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/icmpv4/src/main.c:489:7-44: WARNING: Identifier prepare_echo_request_with_bad_options length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/icmpv4/src/main.c:474:7-40: WARNING: Identifier prepare_echo_request_with_options length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/tcp/src/main.c:129:1-38: WARNING: Identifier NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:834:6-39: WARNING: Identifier test_chunked_content_length_error length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:859:6-39: WARNING: Identifier test_chunked_content_length_error length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:829:6-38: WARNING: Identifier test_double_content_length_error length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:854:6-38: WARNING: Identifier test_double_content_length_error length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:849:6-45: WARNING: Identifier test_invalid_header_field_content_error length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:874:6-45: WARNING: Identifier test_invalid_header_field_content_error length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:844:6-43: WARNING: Identifier test_invalid_header_field_token_error length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/lib/http_header_fields/src/main.c:869:6-43: WARNING: Identifier test_invalid_header_field_token_error length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/mld/src/main.c:441:1-33: WARNING: Identifier join_mldv2_capable_routers_group length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/mld/src/main.c:463:1-34: WARNING: Identifier leave_mldv2_capable_routers_group length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/mld/src/main.c:498:1-39: WARNING: Identifier net_ipv6_addr_create_ll_allnodes_mcast length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/mld/src/main.c:515:1-36: WARNING: Identifier net_ipv6_addr_create_solicited_node length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/net_mgmt/src/main.c:150:3-38: WARNING: Identifier eth_fake_recalc_qav_delta_bandwidth length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/net_mgmt/src/main.c:523:1-33: WARNING: Identifier test_ethernet_get_unknown_option length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/net_mgmt/src/main.c:528:1-33: WARNING: Identifier test_ethernet_get_unknown_option length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/net_mgmt/src/main.c:548:1-33: WARNING: Identifier test_ethernet_set_unknown_option length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/net_mgmt/src/main.c:553:1-33: WARNING: Identifier test_ethernet_set_unknown_option length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/test_socketpair_poll.c:76:1-36: WARNING: Identifier test_socketpair_poll_timeout_common length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/net/socket/socketpair/src/test_socketpair_poll.c:98:1-36: WARNING: Identifier test_socketpair_poll_timeout_common length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:109:6-42: WARNING: Identifier ec_host_cmd_periph_sim_data_received length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:284:6-42: WARNING: Identifier ec_host_cmd_periph_sim_data_received length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:327:6-42: WARNING: Identifier ec_host_cmd_periph_sim_data_received length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:306:6-42: WARNING: Identifier ec_host_cmd_periph_sim_data_received length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:506:1-39: WARNING: Identifier ec_host_cmd_periph_sim_install_send_cb length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_thread_swap/src/arm_thread_arch.c:38:16-56: WARNING: Identifier ztest_thread_callee_saved_regs_container length 40 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_f32.c:89:1-33: WARNING: Identifier arm_biquad_cascade_df2T_init_f32 length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_f32.c:202:2-34: WARNING: Identifier arm_biquad_cascade_df2T_init_f32 length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_f32.c:263:2-36: WARNING: Identifier arm_biquad_cascade_stereo_df2T_f32 length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/filtering/src/biquad_f32.c:259:2-41: WARNING: Identifier arm_biquad_cascade_stereo_df2T_init_f32 length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/portability/cmsis_rtos_v2/src/main.c:24:12-44: WARNING: Identifier test_event_flags_no_wait_timeout length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/portability/cmsis_rtos_v2/src/main.c:27:12-45: WARNING: Identifier test_thread_flags_no_wait_timeout length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/pipe/pipe_api/src/main.c:23:12-47: WARNING: Identifier test_half_pipe_saturating_block_put length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:38:12-51: WARNING: Identifier test_access_kobject_without_init_access length 39 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:39:12-56: WARNING: Identifier test_access_kobject_without_init_with_access length 44 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:47:12-54: WARNING: Identifier test_create_new_essential_thread_from_user length 42 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:48:12-56: WARNING: Identifier test_create_new_higher_prio_thread_from_user length 44 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:49:12-57: WARNING: Identifier test_create_new_invalid_prio_thread_from_user length 45 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:46:12-55: WARNING: Identifier test_create_new_supervisor_thread_from_user length 43 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:41:12-44: WARNING: Identifier test_create_new_thread_from_user length 32 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:45:12-59: WARNING: Identifier test_create_new_thread_from_user_huge_stacksize length 47 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:44:12-62: WARNING: Identifier test_create_new_thread_from_user_invalid_stacksize length 50 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:43:12-60: WARNING: Identifier test_create_new_thread_from_user_no_access_stack length 48 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:36:12-55: WARNING: Identifier test_kobject_access_grant_to_invalid_thread length 43 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:37:12-47: WARNING: Identifier test_kobject_access_invalid_kobject length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:32:12-50: WARNING: Identifier test_kobject_grant_access_kobj_invalid length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:40:12-49: WARNING: Identifier test_kobject_reinitialize_thread_kobj length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:51:12-47: WARNING: Identifier test_mark_thread_exit_uninitialized length 35 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:23:12-50: WARNING: Identifier test_mem_domain_add_partitions_invalid length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:24:12-49: WARNING: Identifier test_mem_domain_add_partitions_simple length 37 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:22:12-52: WARNING: Identifier test_mem_domain_partitions_supervisor_rw length 40 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:21:12-46: WARNING: Identifier test_mem_domain_partitions_user_ro length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:20:12-46: WARNING: Identifier test_mem_domain_partitions_user_rw length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:26:12-45: WARNING: Identifier test_mem_domain_remove_partitions length 33 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:25:12-52: WARNING: Identifier test_mem_domain_remove_partitions_simple length 40 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:42:12-54: WARNING: Identifier test_new_user_thread_with_in_use_stack_obj length 42 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:35:12-48: WARNING: Identifier test_thread_has_residual_permissions length 36 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/main.c:29:12-50: WARNING: Identifier test_thread_without_kobject_permission length 38 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/mem_domain.c:350:35-69: WARNING: Identifier arch_mem_domain_max_partitions_get length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/mem_domain.c:410:35-69: WARNING: Identifier arch_mem_domain_max_partitions_get length 34 > 31
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_protect/src/mem_domain.c:496:35-69: WARNING: Identifier arch_mem_domain_max_partitions_get length 34 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/framework.c:28:2-37: WARNING: Identifier audio_core_process_background_tasks length 35 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/audio_driver.c:417:1-33: WARNING: Identifier audio_driver_config_host_streams length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/audio_driver.c:420:1-35: WARNING: Identifier audio_driver_config_periph_streams length 34 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/audio_driver.c:434:2-34: WARNING: Identifier audio_driver_process_audio_input length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/audio_driver.c:436:2-35: WARNING: Identifier audio_driver_process_audio_output length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/audio_driver.c:388:1-34: WARNING: Identifier audio_driver_start_periph_streams length 33 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/audio_driver.c:405:1-33: WARNING: Identifier audio_driver_stop_periph_streams length 32 > 31
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/main.c:184:1-45: WARNING: Identifier short_time_multireset_bt_mesh_unprovisioning length 44 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/thread.c:405:1-36: WARNING: Identifier z_arm_configure_dynamic_mpu_regions length 35 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/thread.c:384:1-35: WARNING: Identifier z_arm_configure_static_mpu_regions length 34 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_core_mpu.c:323:8-46: WARNING: Identifier ARM_CORE_MPU_MAX_DOMAIN_PARTITIONS_GET length 38 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_core_mpu.c:305:1-43: WARNING: Identifier arm_core_mpu_configure_dynamic_mpu_regions length 42 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_core_mpu.c:132:1-42: WARNING: Identifier arm_core_mpu_configure_static_mpu_regions length 41 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_core_mpu.c:313:25-67: WARNING: Identifier arm_core_mpu_get_max_available_dyn_regions length 42 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_core_mpu.c:151:1-44: WARNING: Identifier arm_core_mpu_mark_areas_for_dynamic_regions length 43 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/nxp_mpu.c:167:1-42: WARNING: Identifier get_region_attr_from_k_mem_partition_info length 41 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/nxp_mpu.c:585:5-38: WARNING: Identifier mpu_configure_dynamic_mpu_regions length 33 > 31
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/nxp_mpu.c:571:5-37: WARNING: Identifier mpu_configure_static_mpu_regions length 32 > 31
/Users/yangxueqi/Documents/zephyr/arch/nios2/core/timing.c:13:3-35: WARNING: Identifier IORD_ALTERA_AVALON_TIMER_PERIODH length 32 > 31
/Users/yangxueqi/Documents/zephyr/arch/nios2/core/timing.c:14:4-36: WARNING: Identifier IORD_ALTERA_AVALON_TIMER_PERIODL length 32 > 31
/Users/yangxueqi/Documents/zephyr/lib/os/mutex.c:77:8-40: WARNING: Identifier z_impl_z_sys_mutex_kernel_unlock length 32 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:1426:6-40: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:194:7-41: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:233:15-49: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:131:5-39: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:898:5-39: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:1005:5-39: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:963:5-39: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
/Users/yangxueqi/Documents/zephyr/kernel/sched.c:1339:6-40: WARNING: Identifier z_is_thread_prevented_from_running length 34 > 31
-------------------------------------------------------------------------

Invalid mode "report" supplied!
Available modes for "ignore_return.cocci" are: patch
Using random available mode: "patch"

Processing ignore_return.cocci
with option(s) ""

Message example to submit a patch:
 Cast void to memset to ignore its return value

 The semantic patch that makes this change is available
 in scripts/coccinelle//ignore_return.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Semantic patch information:
 The return of memset and memcpy is never checked and therefore
 cast it to void to explicitly ignore while adhering to MISRA-C.

Running (4 in parallel): /usr/local/bin/spatch -D patch --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//ignore_return.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
diff -u -p a/drivers/wifi/winc1500/wifi_winc1500.c b/drivers/wifi/winc1500/wifi_winc1500.c
--- a/drivers/wifi/winc1500/wifi_winc1500.c
+++ b/drivers/wifi/winc1500/wifi_winc1500.c
@@ -687,7 +687,7 @@ static void handle_scan_result(void *pvM
 		goto out;
 	}
 
-	memcpy(result.ssid, pstrScanResult->au8SSID, WIFI_SSID_MAX_LEN);
+	(void) memcpy(result.ssid, pstrScanResult->au8SSID, WIFI_SSID_MAX_LEN);
 	result.ssid_length = strlen(result.ssid);
 
 	result.channel = pstrScanResult->u8ch;
@@ -882,7 +882,7 @@ static void handle_socket_msg_accept(str
 
 		a_sd = &w1500_data.socket_data[accept_msg->sock];
 
-		memcpy(a_sd, sd, sizeof(struct socket_data));
+		(void) memcpy(a_sd, sd, sizeof(struct socket_data));
 
 		ret = net_context_get(AF_INET, SOCK_STREAM,
 				      IPPROTO_TCP, &a_sd->context);
@@ -983,11 +983,11 @@ static int winc1500_mgmt_connect(const s
 	uint16_t channel;
 	void *auth;
 
-	memcpy(ssid, params->ssid, params->ssid_length);
+	(void) memcpy(ssid, params->ssid, params->ssid_length);
 	ssid[params->ssid_length] = '\0';
 
 	if (params->security == WIFI_SECURITY_TYPE_PSK) {
-		memcpy(psk.au8PSK, params->psk, params->psk_length);
+		(void) memcpy(psk.au8PSK, params->psk, params->psk_length);
 		psk.au8PSK[params->psk_length] = '\0';
 		auth = &psk;
 
diff -u -p a/drivers/wifi/eswifi/eswifi_socket_offload.c b/drivers/wifi/eswifi/eswifi_socket_offload.c
--- a/drivers/wifi/eswifi/eswifi_socket_offload.c
+++ b/drivers/wifi/eswifi/eswifi_socket_offload.c
@@ -180,7 +180,7 @@ static int map_credentials(int sd, const
 			snprintk(eswifi->buf, sizeof(eswifi->buf),
 				 "PG=%d,%d,%d\r", 0, id, cert->len);
 			bytes = strlen(eswifi->buf);
-			memcpy(&eswifi->buf[bytes], cert->buf, cert->len);
+			(void) memcpy(&eswifi->buf[bytes], cert->buf, cert->len);
 			bytes += cert->len;
 			LOG_DBG("cert write len %d\n", cert->len);
 			ret = eswifi_request(eswifi, eswifi->buf, bytes + 1,
@@ -261,7 +261,7 @@ static ssize_t eswifi_socket_send(void *
 	offset = strlen(eswifi->buf);
 
 	/* copy payload */
-	memcpy(&eswifi->buf[offset], buf, len);
+	(void) memcpy(&eswifi->buf[offset], buf, len);
 	offset += len;
 
 	ret = eswifi_request(eswifi, eswifi->buf, offset + 1, eswifi->buf,
@@ -383,7 +383,7 @@ static int eswifi_socket_close(void *obj
 	}
 
 	if (--socket->usage <= 0) {
-		memset(socket, 0, sizeof(*socket));
+		(void) memset(socket, 0, sizeof(*socket));
 	}
 
 done:
diff -u -p a/drivers/ieee802154/ieee802154_cc2520.c b/drivers/ieee802154/ieee802154_cc2520.c
--- a/drivers/ieee802154/ieee802154_cc2520.c
+++ b/drivers/ieee802154/ieee802154_cc2520.c
@@ -1239,7 +1239,7 @@ static inline void generate_nonce(uint8_
 {
 	nonce[0] = 0 | (apkt->ad_len ? 0x40 : 0) | (m << 3) | 1;
 
-	memcpy(&nonce[1], ccm_nonce, 13);
+	(void) memcpy(&nonce[1], ccm_nonce, 13);
 
 	nonce[14] = (uint8_t)(apkt->pkt->in_len >> 8);
 	nonce[15] = (uint8_t)(apkt->pkt->in_len);
@@ -1296,9 +1296,9 @@ static int insert_crypto_parameters(stru
 	} else {
 		in_buf = data;
 
-		memcpy(in_buf, apkt->ad, apkt->ad_len);
-		memcpy(in_buf + apkt->ad_len,
-		       apkt->pkt->in_buf, apkt->pkt->in_len);
+		(void) memcpy(in_buf, apkt->ad, apkt->ad_len);
+		(void) memcpy(in_buf + apkt->ad_len,
+				apkt->pkt->in_buf, apkt->pkt->in_len);
 		in_len = apkt->ad_len + apkt->pkt->in_len;
 
 		*auth_crypt = !apkt->tag ? apkt->pkt->in_len :
@@ -1377,8 +1377,9 @@ static int cc2520_crypto_ccm(struct ciph
 	}
 
 	if (apkt->tag) {
-		memcpy(apkt->tag, apkt->pkt->out_buf + apkt->pkt->in_len,
-					ctx->mode_params.ccm_info.tag_len);
+		(void) memcpy(apkt->tag,
+				apkt->pkt->out_buf + apkt->pkt->in_len,
+				ctx->mode_params.ccm_info.tag_len);
 	}
 
 	return 0;
diff -u -p a/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c b/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c
--- a/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c
+++ b/drivers/ieee802154/ieee802154_cc13xx_cc26xx.c
@@ -127,9 +127,9 @@ ieee802154_cc13xx_cc26xx_filter(const st
 	}
 
 	if (type == IEEE802154_FILTER_TYPE_IEEE_ADDR) {
-		memcpy((uint8_t *)&drv_data->cmd_ieee_rx.localExtAddr,
-		       filter->ieee_addr,
-		       sizeof(drv_data->cmd_ieee_rx.localExtAddr));
+		(void) memcpy((uint8_t *)&drv_data->cmd_ieee_rx.localExtAddr,
+				filter->ieee_addr,
+				sizeof(drv_data->cmd_ieee_rx.localExtAddr));
 	} else if (type == IEEE802154_FILTER_TYPE_SHORT_ADDR) {
 		drv_data->cmd_ieee_rx.localShortAddr = filter->short_addr;
 	} else if (type == IEEE802154_FILTER_TYPE_PAN_ID) {
@@ -410,11 +410,11 @@ static void ieee802154_cc13xx_cc26xx_dat
 		mac = (uint8_t *)(FCFG1_BASE + FCFG1_O_MAC_15_4_0);
 	}
 
-	memcpy(&drv_data->mac, mac, sizeof(drv_data->mac));
+	(void) memcpy(&drv_data->mac, mac, sizeof(drv_data->mac));
 
 	/* Setup circular RX queue (TRM 25.3.2.7) */
-	memset(&drv_data->rx_entry[0], 0, sizeof(drv_data->rx_entry[0]));
-	memset(&drv_data->rx_entry[1], 0, sizeof(drv_data->rx_entry[1]));
+	(void) memset(&drv_data->rx_entry[0], 0, sizeof(drv_data->rx_entry[0]));
+	(void) memset(&drv_data->rx_entry[1], 0, sizeof(drv_data->rx_entry[1]));
 
 	drv_data->rx_entry[0].pNextEntry = (uint8_t *)&drv_data->rx_entry[1];
 	drv_data->rx_entry[0].config.type = DATA_ENTRY_TYPE_PTR;
diff -u -p a/drivers/crypto/crypto_mtls_shim.c b/drivers/crypto/crypto_mtls_shim.c
--- a/drivers/crypto/crypto_mtls_shim.c
+++ b/drivers/crypto/crypto_mtls_shim.c
@@ -119,11 +119,11 @@ int mtls_cbc_encrypt(struct cipher_ctx *
 		 * crypto API, unless CAP_NO_IV_PREFIX is requested.
 		 */
 		iv_bytes = 16;
-		memcpy(pkt->out_buf, iv, 16);
+		(void) memcpy(pkt->out_buf, iv, 16);
 		p_iv = iv;
 	} else {
 		iv_bytes = 0;
-		memcpy(iv_loc, iv, 16);
+		(void) memcpy(iv_loc, iv, 16);
 		p_iv = iv_loc;
 	}
 
@@ -150,7 +150,7 @@ int mtls_cbc_decrypt(struct cipher_ctx *
 		p_iv = iv;
 	} else {
 		iv_bytes = 0;
-		memcpy(iv_loc, iv, 16);
+		(void) memcpy(iv_loc, iv, 16);
 		p_iv = iv_loc;
 	}
 
diff -u -p a/drivers/led/ht16k33.c b/drivers/led/ht16k33.c
--- a/drivers/led/ht16k33.c
+++ b/drivers/led/ht16k33.c
@@ -336,7 +336,7 @@ static int ht16k33_init(const struct dev
 		return -EINVAL;
 	}
 
-	memset(&data->buffer, 0, sizeof(data->buffer));
+	(void) memset(&data->buffer, 0, sizeof(data->buffer));
 
 	/* Hardware specific limits */
 	dev_data->min_period = 0U;
@@ -354,7 +354,7 @@ static int ht16k33_init(const struct dev
 	}
 
 	/* Clear display RAM */
-	memset(cmd, 0, sizeof(cmd));
+	(void) memset(cmd, 0, sizeof(cmd));
 	cmd[0] = HT16K33_CMD_DISP_DATA_ADDR;
 	err = i2c_write(data->i2c, cmd, sizeof(cmd), config->i2c_addr);
 	if (err) {
@@ -379,7 +379,7 @@ static int ht16k33_init(const struct dev
 	}
 
 #ifdef CONFIG_HT16K33_KEYSCAN
-	memset(&data->children, 0, sizeof(data->children));
+	(void) memset(&data->children, 0, sizeof(data->children));
 	k_mutex_init(&data->lock);
 	k_sem_init(&data->irq_sem, 0, 1);
 
diff -u -p a/drivers/hwinfo/hwinfo_sam.c b/drivers/hwinfo/hwinfo_sam.c
--- a/drivers/hwinfo/hwinfo_sam.c
+++ b/drivers/hwinfo/hwinfo_sam.c
@@ -18,7 +18,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = sizeof(sam_uid);
 	}
 
-	memcpy(buffer, sam_uid, length);
+	(void) memcpy(buffer, sam_uid, length);
 
 	return length;
 }
diff -u -p a/drivers/hwinfo/hwinfo_sam0.c b/drivers/hwinfo/hwinfo_sam0.c
--- a/drivers/hwinfo/hwinfo_sam0.c
+++ b/drivers/hwinfo/hwinfo_sam0.c
@@ -32,7 +32,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = sizeof(dev_id.id);
 	}
 
-	memcpy(buffer, dev_id.id, length);
+	(void) memcpy(buffer, dev_id.id, length);
 
 	return length;
 }
diff -u -p a/drivers/entropy/fake_entropy_native_posix.c b/drivers/entropy/fake_entropy_native_posix.c
--- a/drivers/entropy/fake_entropy_native_posix.c
+++ b/drivers/entropy/fake_entropy_native_posix.c
@@ -40,7 +40,7 @@ static int entropy_native_posix_get_entr
 
 		size_t to_copy = MIN(length, sizeof(long int));
 
-		memcpy(buffer, &value, to_copy);
+		(void) memcpy(buffer, &value, to_copy);
 		buffer += to_copy;
 		length -= to_copy;
 	}
diff -u -p a/drivers/entropy/entropy_gecko_trng.c b/drivers/entropy/entropy_gecko_trng.c
--- a/drivers/entropy/entropy_gecko_trng.c
+++ b/drivers/entropy/entropy_gecko_trng.c
@@ -26,7 +26,7 @@ static void entropy_gecko_trng_read(uint
 		 * and FIFO data is available.
 		 */
 		tmp = TRNG0->FIFO;
-		memcpy(data, (const uint8_t *) &tmp, len);
+		(void) memcpy(data, (const uint8_t *) &tmp, len);
 	}
 }
 
diff -u -p a/drivers/usb/device/usb_dc_mcux_ehci.c b/drivers/usb/device/usb_dc_mcux_ehci.c
--- a/drivers/usb/device/usb_dc_mcux_ehci.c
+++ b/drivers/usb/device/usb_dc_mcux_ehci.c
@@ -216,7 +216,7 @@ int usb_dc_ep_configure(const struct usb
 		return -ENOMEM;
 	}
 
-	memset(block->data, 0, cfg->ep_mps);
+	(void) memset(block->data, 0, cfg->ep_mps);
 	dev_data.eps[ep_abs_idx].ep_mps = cfg->ep_mps;
 	status = dev_data.interface->deviceControl(dev_data.controllerHandle,
 			kUSB_DeviceControlEndpointInit, &ep_init);
@@ -774,8 +774,9 @@ void USB_DeviceNotificationTrigger(void 
 			return;
 		}
 
-		memcpy(&dev_data.eps[ep_abs_idx].transfer_message, cb_msg,
-		       sizeof(usb_device_callback_message_struct_t));
+		(void) memcpy(&dev_data.eps[ep_abs_idx].transfer_message,
+				cb_msg,
+				sizeof(usb_device_callback_message_struct_t));
 		handle_transfer_msg(&dev_data.eps[ep_abs_idx].transfer_message);
 	}
 }
diff -u -p a/drivers/usb/device/usb_dc_native_posix_adapt.c b/drivers/usb/device/usb_dc_native_posix_adapt.c
--- a/drivers/usb/device/usb_dc_native_posix_adapt.c
+++ b/drivers/usb/device/usb_dc_native_posix_adapt.c
@@ -122,9 +122,9 @@ static void fill_device(struct devlist_d
 	struct usb_cfg_descriptor *cfg =
 		(void *)(desc + sizeof(struct usb_device_descriptor));
 
-	memset(dev->path, 0, 256);
+	(void) memset(dev->path, 0, 256);
 	strcpy(dev->path, "/sys/devices/pci0000:00/0000:00:01.2/usb1/1-1");
-	memset(dev->busid, 0, 32);
+	(void) memset(dev->busid, 0, 32);
 	strcpy(dev->busid, "1-1");
 
 	dev->busnum = htonl(1);
@@ -305,7 +305,7 @@ void usbip_start(void)
 		LOG_WRN("setsockopt() failed: %s", strerror(errno));
 	}
 
-	memset(&srv, 0, sizeof(srv));
+	(void) memset(&srv, 0, sizeof(srv));
 	srv.sin_family = AF_INET;
 	srv.sin_addr.s_addr = htonl(INADDR_ANY);
 	srv.sin_port = htons(USBIP_PORT);
diff -u -p a/drivers/ec_host_cmd_periph/ec_host_cmd_simulator.c b/drivers/ec_host_cmd_periph/ec_host_cmd_simulator.c
--- a/drivers/ec_host_cmd_periph/ec_host_cmd_simulator.c
+++ b/drivers/ec_host_cmd_periph/ec_host_cmd_simulator.c
@@ -62,7 +62,7 @@ int ec_host_cmd_periph_sim_data_received
 		return -EBUSY;
 	}
 
-	memcpy(rx_buffer, buffer, len);
+	(void) memcpy(rx_buffer, buffer, len);
 	rx_buffer_len = len;
 
 	k_sem_give(&handler_owns);
diff -u -p a/drivers/flash/nrf_qspi_nor.c b/drivers/flash/nrf_qspi_nor.c
--- a/drivers/flash/nrf_qspi_nor.c
+++ b/drivers/flash/nrf_qspi_nor.c
@@ -565,7 +565,7 @@ static inline nrfx_err_t read_non_aligne
 		if (res != NRFX_SUCCESS) {
 			return res;
 		}
-		memcpy(dptr, buf + WORD_SIZE - flash_prefix, flash_prefix);
+		(void) memcpy(dptr, buf + WORD_SIZE - flash_prefix, flash_prefix);
 	}
 
 	/* read suffix */
@@ -576,7 +576,7 @@ static inline nrfx_err_t read_non_aligne
 		if (res != NRFX_SUCCESS) {
 			return res;
 		}
-		memcpy(dptr + flash_prefix + flash_middle, buf, flash_suffix);
+		(void) memcpy(dptr + flash_prefix + flash_middle, buf, flash_suffix);
 	}
 
 	return res;
@@ -630,7 +630,7 @@ static inline nrfx_err_t write_sub_word(
 	qspi_wait_for_completion(dev, res);
 
 	if (res == NRFX_SUCCESS) {
-		memcpy(buf, sptr, slen);
+		(void) memcpy(buf, sptr, slen);
 		res = nrfx_qspi_write(buf, sizeof(buf), addr);
 		qspi_wait_for_completion(dev, res);
 	}
@@ -659,7 +659,7 @@ static inline nrfx_err_t write_from_nvmc
 	while ((slen > 0) && (res == NRFX_SUCCESS)) {
 		size_t len = MIN(slen, sizeof(buf));
 
-		memcpy(buf, sp, len);
+		(void) memcpy(buf, sp, len);
 		res = nrfx_qspi_write(buf, sizeof(buf),
 				      addr);
 		qspi_wait_for_completion(dev, res);
diff -u -p a/drivers/flash/soc_flash_mcux.c b/drivers/flash/soc_flash_mcux.c
--- a/drivers/flash/soc_flash_mcux.c
+++ b/drivers/flash/soc_flash_mcux.c
@@ -189,11 +189,11 @@ static int flash_mcux_read(const struct 
 #endif
 
 	if (!rc) {
-		memcpy(data, (void *) addr, len);
+		(void) memcpy(data, (void *) addr, len);
 #ifdef CONFIG_CHECK_BEFORE_READING
 	} else if (rc == -ENODATA) {
 		/* Erased area, return dummy data as an erased page. */
-		memset(data, 0xFF, len);
+		(void) memset(data, 0xFF, len);
 		rc = 0;
 #endif
 	}
diff -u -p a/drivers/spi/spi_nrfx_spim.c b/drivers/spi/spi_nrfx_spim.c
--- a/drivers/spi/spi_nrfx_spim.c
+++ b/drivers/spi/spi_nrfx_spim.c
@@ -172,7 +172,7 @@ static void transfer_next_chunk(const st
 				chunk_len = sizeof(dev_data->buffer);
 			}
 
-			memcpy(dev_data->buffer, tx_buf, chunk_len);
+			(void) memcpy(dev_data->buffer, tx_buf, chunk_len);
 			tx_buf = dev_data->buffer;
 		}
 #endif
diff -u -p a/drivers/sensor/dht/dht.c b/drivers/sensor/dht/dht.c
--- a/drivers/sensor/dht/dht.c
+++ b/drivers/sensor/dht/dht.c
@@ -154,7 +154,7 @@ static int dht_sample_fetch(const struct
 		LOG_DBG("Invalid checksum in fetched sample");
 		ret = -EIO;
 	} else {
-		memcpy(drv_data->sample, buf, 4);
+		(void) memcpy(drv_data->sample, buf, 4);
 	}
 
 cleanup:
diff -u -p a/drivers/bluetooth/hci/rpmsg.c b/drivers/bluetooth/hci/rpmsg.c
--- a/drivers/bluetooth/hci/rpmsg.c
+++ b/drivers/bluetooth/hci/rpmsg.c
@@ -61,7 +61,7 @@ static struct net_buf *bt_rpmsg_evt_recv
 
 	discardable = is_hci_event_discardable(data);
 
-	memcpy((void *)&hdr, data, sizeof(hdr));
+	(void) memcpy((void *)&hdr, data, sizeof(hdr));
 	data += sizeof(hdr);
 	remaining -= sizeof(hdr);
 
@@ -99,7 +99,7 @@ static struct net_buf *bt_rpmsg_acl_recv
 
 	buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_NO_WAIT);
 	if (buf) {
-		memcpy((void *)&hdr, data, sizeof(hdr));
+		(void) memcpy((void *)&hdr, data, sizeof(hdr));
 		data += sizeof(hdr);
 		remaining -= sizeof(hdr);
 
diff -u -p a/drivers/neural_net/intel_gna.c b/drivers/neural_net/intel_gna.c
--- a/drivers/neural_net/intel_gna.c
+++ b/drivers/neural_net/intel_gna.c
@@ -84,7 +84,7 @@ static void intel_gna_interrupt_handler(
 		SOC_DCACHE_INVALIDATE(pending_req.model->output,
 				pending_req.output_len);
 		/* copy output from the model buffer to applciation buffer */
-		memcpy(pending_req.output, pending_req.model->output,
+		(void) memcpy(pending_req.output, pending_req.model->output,
 				pending_req.output_len);
 		pending_resp.response.output = pending_req.output;
 		pending_resp.response.output_len = pending_req.output_len;
@@ -463,7 +463,7 @@ static int intel_gna_infer(const struct 
 	}
 
 	/* copy input */
-	memcpy(handle->input, req->input, input_size);
+	(void) memcpy(handle->input, req->input, input_size);
 	SOC_DCACHE_FLUSH(handle->input, input_size);
 
 	/* assign layer descriptor base address to configuration descriptor */
diff -u -p a/drivers/ipm/ipm_imx.c b/drivers/ipm/ipm_imx.c
--- a/drivers/ipm/ipm_imx.c
+++ b/drivers/ipm/ipm_imx.c
@@ -104,7 +104,7 @@ static int imx_mu_ipm_send(const struct 
 	}
 
 	/* Actual message is passing using 32 bits registers */
-	memcpy(data32, data, size);
+	(void) memcpy(data32, data, size);
 
 	for (i = 0; i < IMX_IPM_DATA_REGS; i++) {
 		status = MU_TrySendMsg(base, id * IMX_IPM_DATA_REGS + i,
diff -u -p a/drivers/dma/dma_pl330.c b/drivers/dma/dma_pl330.c
--- a/drivers/dma/dma_pl330.c
+++ b/drivers/dma/dma_pl330.c
@@ -128,7 +128,7 @@ static void dma_pl330_config_channel(str
 {
 	struct dma_pl330_ch_internal *ch_handle = &ch_cfg->internal;
 
-	memset(ch_handle, 0, sizeof(*ch_handle));
+	(void) memset(ch_handle, 0, sizeof(*ch_handle));
 	ch_handle->src_addr = src;
 	ch_handle->dst_addr = dst;
 	ch_handle->trans_size = size;
diff -u -p a/drivers/display/display_sdl.c b/drivers/display/display_sdl.c
--- a/drivers/display/display_sdl.c
+++ b/drivers/display/display_sdl.c
@@ -32,7 +32,7 @@ static int sdl_display_init(const struct
 	    (struct sdl_display_data *)dev->data;
 	LOG_DBG("Initializing display driver");
 
-	memset(disp_data, 0, sizeof(struct sdl_display_data));
+	(void) memset(disp_data, 0, sizeof(struct sdl_display_data));
 
 	disp_data->current_pixel_format =
 #if defined(CONFIG_SDL_DISPLAY_DEFAULT_PIXEL_FORMAT_RGB_888)
@@ -90,7 +90,7 @@ static void sdl_display_write_argb8888(v
 	__ASSERT((desc->pitch * 4U * desc->height) <= desc->buf_size,
 			"Input buffer to small");
 
-	memcpy(disp_buf, buf, desc->pitch * 4U * desc->height);
+	(void) memcpy(disp_buf, buf, desc->pitch * 4U * desc->height);
 }
 
 static void sdl_display_write_rgb888(uint8_t *disp_buf,
@@ -350,7 +350,7 @@ static void sdl_display_get_capabilities
 	struct sdl_display_data *disp_data =
 	    (struct sdl_display_data *)dev->data;
 
-	memset(capabilities, 0, sizeof(struct display_capabilities));
+	(void) memset(capabilities, 0, sizeof(struct display_capabilities));
 	capabilities->x_resolution = CONFIG_SDL_DISPLAY_X_RES;
 	capabilities->y_resolution = CONFIG_SDL_DISPLAY_Y_RES;
 	capabilities->supported_pixel_formats = PIXEL_FORMAT_ARGB_8888 |
diff -u -p a/drivers/i2s/i2s_ll_stm32.c b/drivers/i2s/i2s_ll_stm32.c
--- a/drivers/i2s/i2s_ll_stm32.c
+++ b/drivers/i2s/i2s_ll_stm32.c
@@ -210,12 +210,12 @@ static int i2s_stm32_configure(const str
 
 	if (i2s_cfg->frame_clk_freq == 0U) {
 		stream->queue_drop(stream);
-		memset(&stream->cfg, 0, sizeof(struct i2s_config));
+		(void) memset(&stream->cfg, 0, sizeof(struct i2s_config));
 		stream->state = I2S_STATE_NOT_READY;
 		return 0;
 	}
 
-	memcpy(&stream->cfg, i2s_cfg, sizeof(struct i2s_config));
+	(void) memcpy(&stream->cfg, i2s_cfg, sizeof(struct i2s_config));
 
 	/* set I2S bitclock */
 	bit_clk_freq = i2s_cfg->frame_clk_freq *
@@ -461,7 +461,7 @@ static int start_dma(const struct device
 	struct dma_block_config blk_cfg;
 	int ret;
 
-	memset(&blk_cfg, 0, sizeof(blk_cfg));
+	(void) memset(&blk_cfg, 0, sizeof(blk_cfg));
 	blk_cfg.block_size = blk_size;
 	blk_cfg.source_address = (uint32_t)src;
 	blk_cfg.dest_address = (uint32_t)dst;
diff -u -p a/drivers/i2s/i2s_litex.c b/drivers/i2s/i2s_litex.c
--- a/drivers/i2s/i2s_litex.c
+++ b/drivers/i2s/i2s_litex.c
@@ -431,7 +431,7 @@ static int i2s_litex_configure(const str
 
 #endif
 
-	memcpy(&stream->cfg, i2s_cfg, sizeof(struct i2s_config));
+	(void) memcpy(&stream->cfg, i2s_cfg, sizeof(struct i2s_config));
 	stream->state = I2S_STATE_READY;
 	return 0;
 }
diff -u -p a/drivers/eeprom/eeprom_at2x.c b/drivers/eeprom/eeprom_at2x.c
--- a/drivers/eeprom/eeprom_at2x.c
+++ b/drivers/eeprom/eeprom_at2x.c
@@ -255,7 +255,7 @@ static int eeprom_at24_write(const struc
 		block[i++] = offset >> 8;
 	}
 	block[i++] = offset;
-	memcpy(&block[i], buf, count);
+	(void) memcpy(&block[i], buf, count);
 
 	/*
 	 * A write cycle may already be in progress so writes must be
diff -u -p a/drivers/console/gsm_mux.c b/drivers/console/gsm_mux.c
--- a/drivers/console/gsm_mux.c
+++ b/drivers/console/gsm_mux.c
@@ -213,7 +213,7 @@ static void hexdump_packet(const char *h
 		return;
 	}
 
-	memset(out, 0, sizeof(out));
+	(void) memset(out, 0, sizeof(out));
 
 	ret = snprintk(out, sizeof(out), "%s: DLCI %d %s ",
 		       header, address, cmd_rsp ? "cmd" : "resp");
@@ -1461,7 +1461,7 @@ struct gsm_mux *gsm_mux_create(const str
 
 		mux = &muxes[i];
 
-		memset(mux, 0, sizeof(*mux));
+		(void) memset(mux, 0, sizeof(*mux));
 
 		mux->in_use = true;
 		mux->uart = uart;
diff -u -p a/subsys/jwt/jwt.c b/subsys/jwt/jwt.c
--- a/subsys/jwt/jwt.c
+++ b/subsys/jwt/jwt.c
@@ -104,7 +104,7 @@ static void base64_flush(struct jwt_buil
 	}
 
 	st->pending = 0;
-	memset(st->wip, 0, 3);
+	(void) memset(st->wip, 0, 3);
 }
 
 static void base64_addbyte(struct jwt_builder *st, uint8_t byte)
@@ -253,7 +253,7 @@ static int setup_prng(void)
 	for (int i = 0; i < sizeof(entropy); i += sizeof(uint32_t)) {
 		uint32_t rv = sys_rand32_get();
 
-		memcpy(entropy + i, &rv, sizeof(uint32_t));
+		(void) memcpy(entropy + i, &rv, sizeof(uint32_t));
 	}
 
 	int res = tc_ctr_prng_init(&prng_state,
diff -u -p a/subsys/settings/src/settings_line.c b/subsys/settings/src/settings_line.c
--- a/subsys/settings/src/settings_line.c
+++ b/subsys/settings/src/settings_line.c
@@ -53,7 +53,7 @@ int settings_line_write(const char *name
 
 #ifdef CONFIG_SETTINGS_ENCODE_LEN
 	len_field = settings_line_len_calc(name, val_len);
-	memcpy(w_buf, &len_field, sizeof(len_field));
+	(void) memcpy(w_buf, &len_field, sizeof(len_field));
 	w_size = 0;
 
 
@@ -64,7 +64,7 @@ int settings_line_write(const char *name
 			w_size = rem;
 		}
 
-		memcpy(w_buf + sizeof(len_field), name, w_size);
+		(void) memcpy(w_buf + sizeof(len_field), name, w_size);
 		name += w_size;
 		rem -= w_size;
 	}
@@ -88,7 +88,7 @@ int settings_line_write(const char *name
 	w_size = rem;
 
 	if (rem) {
-		memcpy(w_buf, name, rem);
+		(void) memcpy(w_buf, name, rem);
 	}
 
 	w_buf[rem] = '=';
@@ -102,7 +102,7 @@ int settings_line_write(const char *name
 #ifdef CONFIG_SETTINGS_USE_BASE64
 			if (enc_len) {
 				add = MIN(enc_len, sizeof(w_buf) - w_size);
-				memcpy(&w_buf[w_size], p_enc, add);
+				(void) memcpy(&w_buf[w_size], p_enc, add);
 				enc_len -= add;
 				w_size += add;
 				p_enc += add;
@@ -120,7 +120,7 @@ int settings_line_write(const char *name
 					p_enc = enc_buf;
 #else
 					add = MIN(rem, sizeof(w_buf) - w_size);
-					memcpy(&w_buf[w_size], value, add);
+					(void) memcpy(&w_buf[w_size], value, add);
 					value += add;
 					rem -= add;
 					w_size += add;
@@ -129,8 +129,9 @@ int settings_line_write(const char *name
 					add = (w_size) % wbs;
 					if (add) {
 						add = wbs - add;
-						memset(&w_buf[w_size], '\0',
-						       add);
+						(void) memset(&w_buf[w_size],
+								'\0',
+								add);
 						w_size += add;
 					}
 					done = true;
@@ -258,7 +259,7 @@ static int settings_line_raw_read_until(
 			}
 		}
 
-		memcpy(out, &temp_buf[off], len);
+		(void) memcpy(out, &temp_buf[off], len);
 
 		rem_size -= len;
 
@@ -341,7 +342,7 @@ int settings_line_val_read(off_t val_off
 
 		clen = MIN(olen + off_begin - off, rem_size);
 
-		memcpy(out, &dec_buf[off - off_begin], clen);
+		(void) memcpy(out, &dec_buf[off - off_begin], clen);
 		rem_size -= clen;
 
 		if (exp_size > read_size || olen < read_size/4*3) {
diff -u -p a/subsys/mgmt/mcumgr/serial_util.c b/subsys/mgmt/mcumgr/serial_util.c
--- a/subsys/mgmt/mcumgr/serial_util.c
+++ b/subsys/mgmt/mcumgr/serial_util.c
@@ -36,7 +36,7 @@ static int mcumgr_serial_parse_op(const 
 		return -EINVAL;
 	}
 
-	memcpy(&op, buf, sizeof(op));
+	(void) memcpy(&op, buf, sizeof(op));
 	op = sys_be16_to_cpu(op);
 
 	if (op != MCUMGR_SERIAL_HDR_PKT && op != MCUMGR_SERIAL_HDR_FRAG) {
@@ -219,7 +219,7 @@ int mcumgr_serial_tx_frame(const uint8_t
 	/* Only the first fragment contains the packet length. */
 	if (first) {
 		u16 = sys_cpu_to_be16(len);
-		memcpy(raw, &u16, sizeof(u16));
+		(void) memcpy(raw, &u16, sizeof(u16));
 		raw[2] = data[0];
 
 		rc = mcumgr_serial_tx_small(raw, 3, cb, arg);
@@ -284,7 +284,7 @@ int mcumgr_serial_tx_frame(const uint8_t
 		}
 
 		/* Otherwise, just encode payload data. */
-		memcpy(raw, data + src_off, 3);
+		(void) memcpy(raw, data + src_off, 3);
 		rc = mcumgr_serial_tx_small(raw, 3, cb, arg);
 		if (rc != 0) {
 			return rc;
diff -u -p a/subsys/mgmt/updatehub/updatehub.c b/subsys/mgmt/updatehub/updatehub.c
--- a/subsys/mgmt/updatehub/updatehub.c
+++ b/subsys/mgmt/updatehub/updatehub.c
@@ -87,7 +87,7 @@ static int bin2hex_str(uint8_t *bin, siz
 		return -2;
 	}
 
-	memset(str, 0, str_buf_len);
+	(void) memset(str, 0, str_buf_len);
 	/* str_buf_len - 1 ensure space for \0 */
 	bin2hex(bin, bin_len, str, str_buf_len - 1);
 
@@ -155,7 +155,7 @@ static void cleanup_connection(void)
 	}
 
 	for (i = 0; i < ctx.nfds; i++) {
-		memset(&ctx.fds[i], 0, sizeof(ctx.fds[i]));
+		(void) memset(&ctx.fds[i], 0, sizeof(ctx.fds[i]));
 	}
 
 	ctx.nfds = 0;
@@ -169,7 +169,7 @@ static bool start_coap_client(void)
 	int resolve_attempts = 10;
 	int ret = -1;
 
-	memset(&hints, 0, sizeof(hints));
+	(void) memset(&hints, 0, sizeof(hints));
 
 	if (IS_ENABLED(CONFIG_NET_IPV6)) {
 		hints.ai_family = AF_INET6;
@@ -626,7 +626,7 @@ static int report(enum updatehub_state s
 		goto error;
 	}
 
-	memset(&report, 0, sizeof(report));
+	(void) memset(&report, 0, sizeof(report));
 	report.product_uid = CONFIG_UPDATEHUB_PRODUCT_UID;
 	report.device_identity.id = device_id;
 	report.version = firmware_version;
@@ -658,7 +658,7 @@ static int report(enum updatehub_state s
 		report.error_message = "";
 	}
 
-	memset(&ctx.payload, 0, MAX_PAYLOAD_SIZE);
+	(void) memset(&ctx.payload, 0, MAX_PAYLOAD_SIZE);
 	ret = json_obj_encode_buf(send_report_descr,
 				  ARRAY_SIZE(send_report_descr),
 				  &report, ctx.payload,
@@ -725,9 +725,9 @@ static void probe_cb(char *metadata, siz
 		return;
 	}
 
-	memset(metadata, 0, metadata_size);
-	memcpy(metadata, reply.data + reply.offset,
-	       reply.max_len - reply.offset);
+	(void) memset(metadata, 0, metadata_size);
+	(void) memcpy(metadata, reply.data + reply.offset,
+			reply.max_len - reply.offset);
 
 	/* ensures payload have a valid string with size lower
 	 * than metadata_size
@@ -780,13 +780,13 @@ enum updatehub_response updatehub_probe(
 		goto error;
 	}
 
-	memset(&request, 0, sizeof(request));
+	(void) memset(&request, 0, sizeof(request));
 	request.product_uid = CONFIG_UPDATEHUB_PRODUCT_UID;
 	request.device_identity.id = device_id;
 	request.version = firmware_version;
 	request.hardware = CONFIG_BOARD;
 
-	memset(&ctx.payload, 0, MAX_PAYLOAD_SIZE);
+	(void) memset(&ctx.payload, 0, MAX_PAYLOAD_SIZE);
 	if (json_obj_encode_buf(send_probe_descr,
 				ARRAY_SIZE(send_probe_descr),
 				&request, ctx.payload,
@@ -814,7 +814,7 @@ enum updatehub_response updatehub_probe(
 		goto cleanup;
 	}
 
-	memset(&update_info, 0, sizeof(update_info));
+	(void) memset(&update_info, 0, sizeof(update_info));
 	if (metadata_hash_get(metadata) < 0) {
 		LOG_ERR("Could not get metadata hash");
 		ctx.code_status = UPDATEHUB_METADATA_ERROR;
@@ -824,7 +824,7 @@ enum updatehub_response updatehub_probe(
 	LOG_DBG("metadata size: %d", strlen(metadata));
 	LOG_HEXDUMP_DBG(metadata, MAX_DOWNLOAD_DATA, "metadata");
 
-	memcpy(metadata_copy, metadata, strlen(metadata));
+	(void) memcpy(metadata_copy, metadata, strlen(metadata));
 	if (json_obj_parse(metadata, strlen(metadata),
 			   recv_probe_sh_array_descr,
 			   ARRAY_SIZE(recv_probe_sh_array_descr),
@@ -854,9 +854,9 @@ enum updatehub_response updatehub_probe(
 			goto cleanup;
 		}
 
-		memcpy(update_info.sha256sum_image,
-		       metadata_any_boards.objects[1].objects.sha256sum,
-		       SHA256_HEX_DIGEST_SIZE);
+		(void) memcpy(update_info.sha256sum_image,
+				metadata_any_boards.objects[1].objects.sha256sum,
+				SHA256_HEX_DIGEST_SIZE);
 		update_info.image_size = metadata_any_boards.objects[1].objects.size;
 		LOG_DBG("metadata_any: %s", update_info.sha256sum_image);
 	} else {
@@ -882,9 +882,9 @@ enum updatehub_response updatehub_probe(
 			goto cleanup;
 		}
 
-		memcpy(update_info.sha256sum_image,
-		       metadata_some_boards.objects[1].objects.sha256sum,
-		       SHA256_HEX_DIGEST_SIZE);
+		(void) memcpy(update_info.sha256sum_image,
+				metadata_some_boards.objects[1].objects.sha256sum,
+				SHA256_HEX_DIGEST_SIZE);
 		update_info.image_size =
 			metadata_some_boards.objects[1].objects.size;
 		LOG_DBG("metadata_some: %s", update_info.sha256sum_image);
diff -u -p a/subsys/mgmt/osdp/src/osdp_pd.c b/subsys/mgmt/osdp/src/osdp_pd.c
--- a/subsys/mgmt/osdp/src/osdp_pd.c
+++ b/subsys/mgmt/osdp/src/osdp_pd.c
@@ -613,7 +613,7 @@ static void osdp_pd_set_attributes(struc
 		cap++;
 	}
 	if (id != NULL) {
-		memcpy(&pd->id, id, sizeof(struct osdp_pd_id));
+		(void) memcpy(&pd->id, id, sizeof(struct osdp_pd_id));
 	}
 }
 
@@ -638,7 +638,7 @@ int osdp_pd_get_cmd(struct osdp_cmd *cmd
 	if (osdp_cmd_dequeue(pd, &c)) {
 		return -1;
 	}
-	memcpy(cmd, c, sizeof(struct osdp_cmd));
+	(void) memcpy(cmd, c, sizeof(struct osdp_cmd));
 	osdp_cmd_free(pd, c);
 	return 0;
 }
diff -u -p a/subsys/net/l2/ieee802154/ieee802154_mgmt.c b/subsys/net/l2/ieee802154/ieee802154_mgmt.c
--- a/subsys/net/l2/ieee802154/ieee802154_mgmt.c
+++ b/subsys/net/l2/ieee802154/ieee802154_mgmt.c
@@ -287,8 +287,8 @@ static int ieee802154_associate(uint32_t
 		if (ctx->coord_addr_len == IEEE802154_SHORT_ADDR_LENGTH) {
 			ctx->coord.short_addr = req->short_addr;
 		} else {
-			memcpy(ctx->coord.ext_addr,
-			       req->addr, IEEE802154_EXT_ADDR_LENGTH);
+			(void) memcpy(ctx->coord.ext_addr,
+					req->addr, IEEE802154_EXT_ADDR_LENGTH);
 		}
 	} else {
 		ret = -EACCES;
@@ -414,7 +414,7 @@ static int ieee802154_set_parameters(uin
 		}
 
 		if (memcmp(ctx->ext_addr, data, IEEE802154_EXT_ADDR_LENGTH)) {
-			memcpy(ctx->ext_addr, data, IEEE802154_EXT_ADDR_LENGTH);
+			(void) memcpy(ctx->ext_addr, data, IEEE802154_EXT_ADDR_LENGTH);
 			ieee802154_filter_ieee_addr(iface, ctx->ext_addr);
 		}
 	} else if (mgmt_request == NET_REQUEST_IEEE802154_SET_SHORT_ADDR) {
@@ -472,7 +472,7 @@ static int ieee802154_get_parameters(uin
 			return -EINVAL;
 		}
 
-		memcpy(data, ctx->ext_addr, IEEE802154_EXT_ADDR_LENGTH);
+		(void) memcpy(data, ctx->ext_addr, IEEE802154_EXT_ADDR_LENGTH);
 	} else if (mgmt_request == NET_REQUEST_IEEE802154_GET_SHORT_ADDR) {
 		*value = ctx->short_addr;
 	} else if (mgmt_request == NET_REQUEST_IEEE802154_GET_TX_POWER) {
@@ -546,7 +546,7 @@ static int ieee802154_get_security_setti
 
 	params = (struct ieee802154_security_params *)data;
 
-	memcpy(params->key, ctx->sec_ctx.key, ctx->sec_ctx.key_len);
+	(void) memcpy(params->key, ctx->sec_ctx.key, ctx->sec_ctx.key_len);
 	params->key_len = ctx->sec_ctx.key_len;
 	params->key_mode = ctx->sec_ctx.key_mode;
 	params->level = ctx->sec_ctx.level;
diff -u -p a/subsys/net/l2/openthread/openthread_utils.c b/subsys/net/l2/openthread/openthread_utils.c
--- a/subsys/net/l2/openthread/openthread_utils.c
+++ b/subsys/net/l2/openthread/openthread_utils.c
@@ -174,9 +174,9 @@ void add_ipv6_addr_to_ot(struct openthre
 	/* save the last added IP address for this interface */
 	for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
 		if (ipv6->unicast[i].is_used) {
-			memcpy(&addr.mAddress,
-			       &ipv6->unicast[i].address.in6_addr,
-			       sizeof(addr.mAddress));
+			(void) memcpy(&addr.mAddress,
+					&ipv6->unicast[i].address.in6_addr,
+					sizeof(addr.mAddress));
 			break;
 		}
 	}
@@ -227,9 +227,9 @@ void add_ipv6_maddr_to_ot(struct openthr
 	/* save the last added IP address for this interface */
 	for (i = NET_IF_MAX_IPV6_MADDR - 1; i >= 0; i--) {
 		if (ipv6->mcast[i].is_used) {
-			memcpy(&addr,
-			       &ipv6->mcast[i].address.in6_addr,
-			       sizeof(addr));
+			(void) memcpy(&addr,
+					&ipv6->mcast[i].address.in6_addr,
+					sizeof(addr));
 			break;
 		}
 	}
diff -u -p a/subsys/net/l2/ppp/ipv6cp.c b/subsys/net/l2/ppp/ipv6cp.c
--- a/subsys/net/l2/ppp/ipv6cp.c
+++ b/subsys/net/l2/ppp/ipv6cp.c
@@ -35,12 +35,12 @@ static int ipv6cp_add_iid(struct ppp_con
 
 	linkaddr = net_if_get_link_addr(ctx->iface);
 	if (linkaddr->len == 8) {
-		memcpy(iid, linkaddr->addr, iid_len);
+		(void) memcpy(iid, linkaddr->addr, iid_len);
 	} else {
-		memcpy(iid, linkaddr->addr, 3);
+		(void) memcpy(iid, linkaddr->addr, 3);
 		iid[3] = 0xff;
 		iid[4] = 0xfe;
-		memcpy(iid + 5, linkaddr->addr + 3, 3);
+		(void) memcpy(iid + 5, linkaddr->addr + 3, 3);
 	}
 
 	net_pkt_write_u8(pkt, INTERFACE_IDENTIFIER_OPTION_LEN);
@@ -146,8 +146,8 @@ static int ipv6cp_config_info_req(struct
 		return -EINVAL;
 	}
 
-	memcpy(ctx->ipv6cp.peer_options.iid, data.iface_id,
-	       sizeof(data.iface_id));
+	(void) memcpy(ctx->ipv6cp.peer_options.iid, data.iface_id,
+			sizeof(data.iface_id));
 
 	return PPP_CONFIGURE_ACK;
 }
@@ -211,7 +211,7 @@ static void setup_iid_address(uint8_t *i
 	addr->s6_addr[1] = 0x80;
 	UNALIGNED_PUT(0, &addr->s6_addr16[1]);
 	UNALIGNED_PUT(0, &addr->s6_addr32[1]);
-	memcpy(&addr->s6_addr[8], iid, PPP_INTERFACE_IDENTIFIER_LEN);
+	(void) memcpy(&addr->s6_addr[8], iid, PPP_INTERFACE_IDENTIFIER_LEN);
 
 	/* TODO: should we toggle local/global bit */
 	/* addr->s6_addr[8] ^= 0x02; */
@@ -373,7 +373,7 @@ static void ipv6cp_init(struct ppp_conte
 	NET_DBG("proto %s (0x%04x) fsm %p", ppp_proto2str(PPP_IPV6CP),
 		PPP_IPV6CP, &ctx->ipv6cp.fsm);
 
-	memset(&ctx->ipv6cp.fsm, 0, sizeof(ctx->ipv6cp.fsm));
+	(void) memset(&ctx->ipv6cp.fsm, 0, sizeof(ctx->ipv6cp.fsm));
 
 	ppp_fsm_init(&ctx->ipv6cp.fsm, PPP_IPV6CP);
 
diff -u -p a/subsys/net/l2/ethernet/arp.c b/subsys/net/l2/ethernet/arp.c
--- a/subsys/net/l2/ethernet/arp.c
+++ b/subsys/net/l2/ethernet/arp.c
@@ -295,8 +295,8 @@ static inline struct net_pkt *arp_prepar
 
 	net_ipaddr_copy(&hdr->dst_ipaddr, next_addr);
 
-	memcpy(hdr->src_hwaddr.addr, net_pkt_lladdr_src(pkt)->addr,
-	       sizeof(struct net_eth_addr));
+	(void) memcpy(hdr->src_hwaddr.addr, net_pkt_lladdr_src(pkt)->addr,
+			sizeof(struct net_eth_addr));
 
 	if (!entry || net_pkt_ipv4_auto(pkt)) {
 		my_addr = current_ip;
@@ -412,7 +412,7 @@ static void arp_gratuitous(struct net_if
 					   (const uint8_t *)hwaddr,
 					   sizeof(struct net_eth_addr))));
 
-		memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
+		(void) memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
 	}
 }
 
@@ -439,8 +439,8 @@ static void arp_update(struct net_if *if
 
 			entry = arp_entry_find(&arp_table, iface, src, &prev);
 			if (entry) {
-				memcpy(&entry->eth, hwaddr,
-				       sizeof(struct net_eth_addr));
+				(void) memcpy(&entry->eth, hwaddr,
+						sizeof(struct net_eth_addr));
 			} else {
 				/* Add new entry as it was not found and force
 				 * was set.
@@ -455,7 +455,7 @@ static void arp_update(struct net_if *if
 					entry->req_start = k_uptime_get_32();
 					entry->iface = iface;
 					net_ipaddr_copy(&entry->ip, src);
-					memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
+					(void) memcpy(&entry->eth, hwaddr, sizeof(entry->eth));
 					sys_slist_prepend(&arp_table, &entry->node);
 				}
 			}
@@ -476,7 +476,7 @@ static void arp_update(struct net_if *if
 	pkt = entry->pending;
 	entry->pending = NULL;
 
-	memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
+	(void) memcpy(&entry->eth, hwaddr, sizeof(struct net_eth_addr));
 
 	/* Inserting entry into the table */
 	sys_slist_prepend(&arp_table, &entry->node);
@@ -511,10 +511,11 @@ static inline struct net_pkt *arp_prepar
 	hdr->protolen = sizeof(struct in_addr);
 	hdr->opcode = htons(NET_ARP_REPLY);
 
-	memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
-	       sizeof(struct net_eth_addr));
-	memcpy(&hdr->src_hwaddr.addr, net_if_get_link_addr(iface)->addr,
-	       sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->dst_hwaddr.addr, &dst_addr->addr,
+			sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->src_hwaddr.addr,
+			net_if_get_link_addr(iface)->addr,
+			sizeof(struct net_eth_addr));
 
 	net_ipaddr_copy(&hdr->dst_ipaddr, &query->src_ipaddr);
 	net_ipaddr_copy(&hdr->src_ipaddr, &query->dst_ipaddr);
diff -u -p a/subsys/net/l2/ethernet/gptp/gptp.c b/subsys/net/l2/ethernet/gptp/gptp.c
--- a/subsys/net/l2/ethernet/gptp/gptp.c
+++ b/subsys/net/l2/ethernet/gptp/gptp.c
@@ -400,9 +400,9 @@ static void gptp_init_clock_ds(void)
 	/* Initialize parent data set. */
 
 	/* parent clock id is initialized to default_ds clock id. */
-	memcpy(parent_ds->port_id.clk_id, default_ds->clk_id,
-	       GPTP_CLOCK_ID_LEN);
-	memcpy(parent_ds->gm_id, default_ds->clk_id, GPTP_CLOCK_ID_LEN);
+	(void) memcpy(parent_ds->port_id.clk_id, default_ds->clk_id,
+			GPTP_CLOCK_ID_LEN);
+	(void) memcpy(parent_ds->gm_id, default_ds->clk_id, GPTP_CLOCK_ID_LEN);
 	parent_ds->port_id.port_number = 0U;
 
 	/* TODO: Check correct value for below field. */
@@ -451,7 +451,7 @@ static void gptp_init_port_ds(int port)
 	port_ds = GPTP_PORT_DS(port);
 
 	/* Initialize port data set. */
-	memcpy(port_ds->port_id.clk_id, default_ds->clk_id, GPTP_CLOCK_ID_LEN);
+	(void) memcpy(port_ds->port_id.clk_id, default_ds->clk_id, GPTP_CLOCK_ID_LEN);
 	port_ds->port_id.port_number = port;
 
 	port_ds->ptt_port_enabled = true;
diff -u -p a/subsys/net/l2/ethernet/gptp/gptp_mi.c b/subsys/net/l2/ethernet/gptp/gptp_mi.c
--- a/subsys/net/l2/ethernet/gptp/gptp_mi.c
+++ b/subsys/net/l2/ethernet/gptp/gptp_mi.c
@@ -393,7 +393,7 @@ static void gptp_mi_pss_rcv_compute(int 
 
 	pss->local_port_number = port;
 
-	memcpy(&pss->sync_info, sync_rcv, sizeof(struct gptp_md_sync_info));
+	(void) memcpy(&pss->sync_info, sync_rcv, sizeof(struct gptp_md_sync_info));
 
 	pss->sync_receipt_timeout_time = gptp_get_current_time_nanosecond(port);
 	pss->sync_receipt_timeout_time +=
@@ -472,10 +472,12 @@ static void gptp_mi_pss_store_last_pss(i
 
 	state->last_rcvd_port_num = pss_ptr->local_port_number;
 
-	memcpy(&state->last_precise_orig_ts, &sync_info->precise_orig_ts,
-	       sizeof(struct net_ptp_time));
-	memcpy(&state->last_gm_phase_change, &sync_info->last_gm_phase_change,
-	       sizeof(struct gptp_scaled_ns));
+	(void) memcpy(&state->last_precise_orig_ts,
+			&sync_info->precise_orig_ts,
+			sizeof(struct net_ptp_time));
+	(void) memcpy(&state->last_gm_phase_change,
+			&sync_info->last_gm_phase_change,
+			sizeof(struct gptp_scaled_ns));
 
 	state->last_follow_up_correction_field =
 		sync_info->follow_up_correction_field;
@@ -497,8 +499,8 @@ static void gptp_mi_pss_send_md_sync_sen
 	pss_ptr = state->pss_sync_ptr;
 	sync_send = &GPTP_PORT_STATE(port)->sync_send;
 
-	memcpy(&state->sync_send, &pss_ptr->sync_info,
-	       sizeof(struct gptp_md_sync_info));
+	(void) memcpy(&state->sync_send, &pss_ptr->sync_info,
+			sizeof(struct gptp_md_sync_info));
 
 	sync_send->sync_send_ptr = &state->sync_send;
 	sync_send->rcvd_md_sync = true;
@@ -621,8 +623,8 @@ static void gptp_mi_site_ss_prepare_pss_
 
 	state = &GPTP_STATE()->site_ss;
 
-	memcpy(&state->pss_send, state->pss_rcv_ptr,
-	       sizeof(struct gptp_mi_port_sync_sync));
+	(void) memcpy(&state->pss_send, state->pss_rcv_ptr,
+			sizeof(struct gptp_mi_port_sync_sync));
 }
 
 static void gptp_mi_site_ss_send_to_pss(void)
@@ -893,14 +895,14 @@ static void gptp_mi_clk_master_sync_offs
 
 		if (global_ds->selected_role[0] == GPTP_PORT_PASSIVE) {
 			/* TODO Calculate real values for proper BC support */
-			memset(&global_ds->clk_src_phase_offset, 0x0,
-			       sizeof(struct gptp_scaled_ns));
+			(void) memset(&global_ds->clk_src_phase_offset, 0x0,
+					sizeof(struct gptp_scaled_ns));
 			global_ds->clk_src_freq_offset = 0;
 		} else if (global_ds->clk_src_time_base_indicator_prev
 			   != global_ds->clk_src_time_base_indicator) {
-			memcpy(&global_ds->clk_src_phase_offset,
-			       &global_ds->last_gm_phase_change,
-			       sizeof(struct gptp_scaled_ns));
+			(void) memcpy(&global_ds->clk_src_phase_offset,
+					&global_ds->last_gm_phase_change,
+					sizeof(struct gptp_scaled_ns));
 
 			global_ds->clk_src_freq_offset =
 				global_ds->last_gm_freq_change;
@@ -962,9 +964,9 @@ static void gptp_mi_set_ps_sync_cmss(voi
 	sync_info->follow_up_correction_field = 0;
 	sync_info->rate_ratio = 0;
 
-	memcpy(&sync_info->src_port_id.clk_id,
-	       GPTP_DEFAULT_DS()->clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(&sync_info->src_port_id.clk_id,
+			GPTP_DEFAULT_DS()->clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	sync_info->src_port_id.port_number = 0U;
 	sync_info->log_msg_interval = CONFIG_NET_GPTP_INIT_LOG_SYNC_ITV;
@@ -975,9 +977,9 @@ static void gptp_mi_set_ps_sync_cmss(voi
 	sync_info->gm_time_base_indicator =
 		global_ds->clk_src_time_base_indicator;
 
-	memcpy(&sync_info->last_gm_phase_change,
-	       &global_ds->clk_src_phase_offset,
-	       sizeof(struct gptp_scaled_ns));
+	(void) memcpy(&sync_info->last_gm_phase_change,
+			&global_ds->clk_src_phase_offset,
+			sizeof(struct gptp_scaled_ns));
 
 	sync_info->last_gm_freq_change = global_ds->clk_src_freq_offset;
 }
@@ -1049,19 +1051,19 @@ static void gptp_compute_gm_rate_ratio(v
 	global_ds = GPTP_GLOBAL_DS();
 
 	/* Get current local and source time */
-	memcpy(&src_time_n, &state->rcvd_clk_src_req.src_time,
-	       sizeof(struct net_ptp_extended_time));
+	(void) memcpy(&src_time_n, &state->rcvd_clk_src_req.src_time,
+			sizeof(struct net_ptp_extended_time));
 
-	memcpy(&local_time_n, &global_ds->local_time,
-	       sizeof(struct gptp_uscaled_ns));
+	(void) memcpy(&local_time_n, &global_ds->local_time,
+			sizeof(struct gptp_uscaled_ns));
 
 	if ((src_time_0.second == 0U && src_time_0.fract_nsecond == 0U)
 	    || (local_time_0.high == 0U && local_time_0.low == 0U)) {
-		memcpy(&src_time_0, &src_time_n,
-		       sizeof(struct net_ptp_extended_time));
+		(void) memcpy(&src_time_0, &src_time_n,
+				sizeof(struct net_ptp_extended_time));
 
-		memcpy(&local_time_0, &local_time_n,
-		       sizeof(struct gptp_uscaled_ns));
+		(void) memcpy(&local_time_0, &local_time_n,
+				sizeof(struct gptp_uscaled_ns));
 
 		global_ds->gm_rate_ratio = 1.0;
 
@@ -1075,12 +1077,12 @@ static void gptp_compute_gm_rate_ratio(v
 	    || (src_time_n.second == src_time_0.second
 		&& src_time_n.fract_nsecond < src_time_0.fract_nsecond)) {
 		/* Change result sign and swap src_time_n and src_time_0 */
-		memcpy(&src_time_t, &src_time_n,
-		       sizeof(struct net_ptp_extended_time));
-		memcpy(&src_time_n, &src_time_0,
-		       sizeof(struct net_ptp_extended_time));
-		memcpy(&src_time_0, &src_time_t,
-		       sizeof(struct net_ptp_extended_time));
+		(void) memcpy(&src_time_t, &src_time_n,
+				sizeof(struct net_ptp_extended_time));
+		(void) memcpy(&src_time_n, &src_time_0,
+				sizeof(struct net_ptp_extended_time));
+		(void) memcpy(&src_time_0, &src_time_t,
+				sizeof(struct net_ptp_extended_time));
 
 		new_gm_rate *= -1;
 	}
@@ -1089,12 +1091,12 @@ static void gptp_compute_gm_rate_ratio(v
 	    || (local_time_n.high == local_time_0.high
 		&& local_time_n.low < local_time_0.low)) {
 		/* Change result sign and swap local_time_n and local_time_0 */
-		memcpy(&local_time_t, &local_time_n,
-		       sizeof(struct gptp_uscaled_ns));
-		memcpy(&local_time_n, &local_time_0,
-		       sizeof(struct gptp_uscaled_ns));
-		memcpy(&local_time_0, &local_time_t,
-		       sizeof(struct gptp_uscaled_ns));
+		(void) memcpy(&local_time_t, &local_time_n,
+				sizeof(struct gptp_uscaled_ns));
+		(void) memcpy(&local_time_n, &local_time_0,
+				sizeof(struct gptp_uscaled_ns));
+		(void) memcpy(&local_time_0, &local_time_t,
+				sizeof(struct gptp_uscaled_ns));
 
 		new_gm_rate *= -1;
 	}
@@ -1143,8 +1145,8 @@ static void gptp_mi_clk_master_sync_rcv_
 
 	invoke_args.src_time.fract_nsecond = cur * GPTP_POW2_16;
 
-	memset(&invoke_args.last_gm_phase_change, 0x0,
-	       sizeof(struct gptp_scaled_ns));
+	(void) memset(&invoke_args.last_gm_phase_change, 0x0,
+			sizeof(struct gptp_scaled_ns));
 	invoke_args.last_gm_freq_change = 0;
 
 	gptp_clk_src_time_invoke(&invoke_args);
@@ -1179,9 +1181,9 @@ static void gptp_mi_clk_master_sync_rcv_
 			global_ds->clk_src_time_base_indicator =
 				s->rcvd_clk_src_req.time_base_indicator;
 
-			memcpy(&global_ds->clk_src_last_gm_phase_change,
-			       &s->rcvd_clk_src_req.last_gm_phase_change,
-			       sizeof(struct gptp_scaled_ns));
+			(void) memcpy(&global_ds->clk_src_last_gm_phase_change,
+					&s->rcvd_clk_src_req.last_gm_phase_change,
+					sizeof(struct gptp_scaled_ns));
 
 			global_ds->clk_src_last_gm_freq_change =
 				s->rcvd_clk_src_req.last_gm_freq_change;
@@ -1213,12 +1215,13 @@ static void copy_path_trace(struct gptp_
 
 	sys_path_trace->len = htons(len + GPTP_CLOCK_ID_LEN);
 
-	memcpy(sys_path_trace->path_sequence, announce->tlv.path_sequence,
-	       len);
+	(void) memcpy(sys_path_trace->path_sequence,
+			announce->tlv.path_sequence,
+			len);
 
 	/* Append local clockIdentity. */
-	memcpy((uint8_t *)sys_path_trace->path_sequence + len,
-	       GPTP_DEFAULT_DS()->clk_id, GPTP_CLOCK_ID_LEN);
+	(void) memcpy((uint8_t *)sys_path_trace->path_sequence + len,
+			GPTP_DEFAULT_DS()->clk_id, GPTP_CLOCK_ID_LEN);
 }
 
 static bool gptp_mi_qualify_announce(int port, struct net_pkt *announce_msg)
@@ -1407,11 +1410,11 @@ static void copy_priority_vector(struct 
 	hdr = GPTP_HDR(pkt);
 	announce = GPTP_ANNOUNCE(pkt);
 
-	memcpy(&vector->root_system_id, &announce->root_system_id,
-	       sizeof(struct gptp_root_system_identity) + sizeof(uint16_t));
+	(void) memcpy(&vector->root_system_id, &announce->root_system_id,
+			sizeof(struct gptp_root_system_identity) + sizeof(uint16_t));
 
-	memcpy(&vector->src_port_id, &hdr->port_id,
-	       sizeof(struct gptp_port_identity));
+	(void) memcpy(&vector->src_port_id, &hdr->port_id,
+			sizeof(struct gptp_port_identity));
 
 	vector->port_number = htons(port);
 }
@@ -1469,9 +1472,9 @@ static void gptp_mi_port_announce_inform
 
 	case GPTP_PA_INFO_UPDATE:
 		if (IS_SELECTED(global_ds, port) && bmca_data->updt_info) {
-			memcpy(&bmca_data->port_priority,
-			       &bmca_data->master_priority,
-			       sizeof(struct gptp_priority_vector));
+			(void) memcpy(&bmca_data->port_priority,
+					&bmca_data->master_priority,
+					sizeof(struct gptp_priority_vector));
 
 			bmca_data->port_steps_removed =
 				global_ds->master_steps_removed;
@@ -1592,8 +1595,9 @@ static void gptp_updt_role_disabled_tree
 
 	/* Set pathTrace array to contain the single element thisClock. */
 	global_ds->path_trace.len = htons(GPTP_CLOCK_ID_LEN);
-	memcpy(global_ds->path_trace.path_sequence, GPTP_DEFAULT_DS()->clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(global_ds->path_trace.path_sequence,
+			GPTP_DEFAULT_DS()->clk_id,
+			GPTP_CLOCK_ID_LEN);
 }
 
 static void gptp_clear_reselect_tree(void)
@@ -1628,10 +1632,11 @@ static int compute_best_vector(void)
 	gm_prio->root_system_id.clk_quality.offset_scaled_log_var =
 		htons(default_ds->clk_quality.offset_scaled_log_var);
 
-	memcpy(gm_prio->src_port_id.clk_id, default_ds->clk_id,
-	       GPTP_CLOCK_ID_LEN);
-	memcpy(gm_prio->root_system_id.grand_master_id, default_ds->clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(gm_prio->src_port_id.clk_id, default_ds->clk_id,
+			GPTP_CLOCK_ID_LEN);
+	(void) memcpy(gm_prio->root_system_id.grand_master_id,
+			default_ds->clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	best_vector = gm_prio;
 
@@ -1703,9 +1708,9 @@ static int compute_best_vector(void)
 	if (best_port != 0) {
 		if (&global_ds->gm_priority.root_system_id !=
 		    &best_vector->root_system_id) {
-			memcpy(&global_ds->gm_priority.root_system_id,
-			       &best_vector->root_system_id,
-			       sizeof(struct gptp_root_system_identity));
+			(void) memcpy(&global_ds->gm_priority.root_system_id,
+					&best_vector->root_system_id,
+					sizeof(struct gptp_root_system_identity));
 		}
 
 		global_ds->gm_priority.steps_removed =
@@ -1713,9 +1718,9 @@ static int compute_best_vector(void)
 
 		if (&global_ds->gm_priority.src_port_id !=
 		    &best_vector->src_port_id) {
-			memcpy(&global_ds->gm_priority.src_port_id,
-			       &best_vector->src_port_id,
-			       sizeof(struct gptp_port_identity));
+			(void) memcpy(&global_ds->gm_priority.src_port_id,
+					&best_vector->src_port_id,
+					sizeof(struct gptp_port_identity));
 		}
 
 		global_ds->gm_priority.port_number = best_vector->port_number;
@@ -1734,18 +1739,18 @@ static void update_bmca(int port,
 
 	/* Update masterPriorityVector for the port. */
 	if (best_port == 0) {
-		memcpy(&bmca_data->master_priority, gm_prio,
-		       sizeof(struct gptp_priority_vector));
+		(void) memcpy(&bmca_data->master_priority, gm_prio,
+				sizeof(struct gptp_priority_vector));
 
 		bmca_data->master_priority.port_number = htons(port);
 		bmca_data->master_priority.src_port_id.port_number =
 			htons(port);
 	} else {
-		memcpy(&bmca_data->master_priority.root_system_id,
-		       &gm_prio->root_system_id,
-		       sizeof(struct gptp_root_system_identity));
-		memcpy(bmca_data->master_priority.src_port_id.clk_id,
-		       default_ds->clk_id, GPTP_CLOCK_ID_LEN);
+		(void) memcpy(&bmca_data->master_priority.root_system_id,
+				&gm_prio->root_system_id,
+				sizeof(struct gptp_root_system_identity));
+		(void) memcpy(bmca_data->master_priority.src_port_id.clk_id,
+				default_ds->clk_id, GPTP_CLOCK_ID_LEN);
 		bmca_data->master_priority.port_number = htons(port);
 		bmca_data->master_priority.src_port_id.port_number =
 			htons(port);
@@ -1825,7 +1830,7 @@ static void gptp_updt_roles_tree(void)
 	last_gm_prio = &global_ds->last_gm_priority;
 
 	/* Save gmPriority. */
-	memcpy(last_gm_prio, gm_prio, sizeof(struct gptp_priority_vector));
+	(void) memcpy(last_gm_prio, gm_prio, sizeof(struct gptp_priority_vector));
 
 	best_port = compute_best_vector();
 
@@ -1880,8 +1885,8 @@ static void gptp_updt_roles_tree(void)
 	if (memcmp(default_ds->clk_id, gm_prio->root_system_id.grand_master_id,
 		   GPTP_CLOCK_ID_LEN) == 0) {
 		global_ds->path_trace.len = htons(GPTP_CLOCK_ID_LEN);
-		memcpy(global_ds->path_trace.path_sequence,
-		       default_ds->clk_id, GPTP_CLOCK_ID_LEN);
+		(void) memcpy(global_ds->path_trace.path_sequence,
+				default_ds->clk_id, GPTP_CLOCK_ID_LEN);
 	}
 }
 
diff -u -p a/subsys/net/lib/sockets/sockets.c b/subsys/net/lib/sockets/sockets.c
--- a/subsys/net/lib/sockets/sockets.c
+++ b/subsys/net/lib/sockets/sockets.c
@@ -510,7 +510,7 @@ int zsock_accept_ctx(struct net_context 
 	if (addr != NULL && addrlen != NULL) {
 		int len = MIN(*addrlen, sizeof(ctx->remote));
 
-		memcpy(addr, &ctx->remote, len);
+		(void) memcpy(addr, &ctx->remote, len);
 		/* addrlen is a value-result argument, set to actual
 		 * size of source address
 		 */
@@ -1655,22 +1655,24 @@ int zsock_getsockname_ctx(struct net_con
 
 		addr4.sin_family = AF_INET;
 		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
-		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
-		       sizeof(struct in_addr));
+		(void) memcpy(&addr4.sin_addr,
+				net_sin_ptr(&ctx->local)->sin_addr,
+				sizeof(struct in_addr));
 		newlen = sizeof(struct sockaddr_in);
 
-		memcpy(addr, &addr4, MIN(*addrlen, newlen));
+		(void) memcpy(addr, &addr4, MIN(*addrlen, newlen));
 	} else if (IS_ENABLED(CONFIG_NET_IPV6) &&
 		   ctx->local.family == AF_INET6) {
 		struct sockaddr_in6 addr6 = { 0 };
 
 		addr6.sin6_family = AF_INET6;
 		addr6.sin6_port = net_sin6_ptr(&ctx->local)->sin6_port;
-		memcpy(&addr6.sin6_addr, net_sin6_ptr(&ctx->local)->sin6_addr,
-		       sizeof(struct in6_addr));
+		(void) memcpy(&addr6.sin6_addr,
+				net_sin6_ptr(&ctx->local)->sin6_addr,
+				sizeof(struct in6_addr));
 		newlen = sizeof(struct sockaddr_in6);
 
-		memcpy(addr, &addr6, MIN(*addrlen, newlen));
+		(void) memcpy(addr, &addr6, MIN(*addrlen, newlen));
 	} else {
 		SET_ERRNO(-EINVAL);
 	}
diff -u -p a/subsys/net/lib/sockets/socketpair.c b/subsys/net/lib/sockets/socketpair.c
--- a/subsys/net/lib/sockets/socketpair.c
+++ b/subsys/net/lib/sockets/socketpair.c
@@ -192,7 +192,7 @@ static void spair_delete(struct spair *s
 	__ASSERT(res == 0, "k_poll_signal_raise() failed: %d", res);
 
 	/* ensure no private information is released to the memory pool */
-	memset(spair, 0, sizeof(*spair));
+	(void) memset(spair, 0, sizeof(*spair));
 #ifdef CONFIG_USERSPACE
 	k_object_free(spair);
 #else
@@ -233,7 +233,7 @@ static struct spair *spair_new(void)
 		errno = ENOMEM;
 		goto out;
 	}
-	memset(spair, 0, sizeof(*spair));
+	(void) memset(spair, 0, sizeof(*spair));
 
 	/* initialize any non-zero default values */
 	spair->remote = -1;
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_engine.c b/subsys/net/lib/lwm2m/lwm2m_engine.c
--- a/subsys/net/lib/lwm2m/lwm2m_engine.c
+++ b/subsys/net/lib/lwm2m/lwm2m_engine.c
@@ -273,7 +273,7 @@ init_block_ctx(const uint8_t *token, uin
 	}
 
 	(*ctx)->tkl = tkl;
-	memcpy((*ctx)->token, token, tkl);
+	(void) memcpy((*ctx)->token, token, tkl);
 	coap_block_transfer_init(&(*ctx)->ctx, lwm2m_default_block_size(), 0);
 	(*ctx)->timestamp = timestamp;
 	(*ctx)->remaining_len = 0;
@@ -435,7 +435,7 @@ static int engine_add_observer(struct lw
 		if (obs->ctx == msg->ctx &&
 		    memcmp(&obs->path, &msg->path, sizeof(msg->path)) == 0) {
 			/* quietly update the token information */
-			memcpy(obs->token, token, tkl);
+			(void) memcpy(obs->token, token, tkl);
 			obs->tkl = tkl;
 
 			LOG_DBG("OBSERVER DUPLICATE %u/%u/%u(%u) [%s]",
@@ -526,8 +526,8 @@ static int engine_add_observer(struct lw
 
 	/* copy the values and add it to the list */
 	observe_node_data[i].ctx = msg->ctx;
-	memcpy(&observe_node_data[i].path, &msg->path, sizeof(msg->path));
-	memcpy(observe_node_data[i].token, token, tkl);
+	(void) memcpy(&observe_node_data[i].path, &msg->path, sizeof(msg->path));
+	(void) memcpy(observe_node_data[i].token, token, tkl);
 	observe_node_data[i].tkl = tkl;
 	observe_node_data[i].last_timestamp = k_uptime_get();
 	observe_node_data[i].event_timestamp =
@@ -1063,7 +1063,7 @@ uint16_t lwm2m_get_rd_data(uint8_t *clie
 	int len;
 
 	/* Add resource-type/content-type to the registration message */
-	memcpy(client_data, REG_PREFACE, sizeof(REG_PREFACE) - 1);
+	(void) memcpy(client_data, REG_PREFACE, sizeof(REG_PREFACE) - 1);
 	pos += sizeof(REG_PREFACE) - 1;
 
 	SYS_SLIST_FOR_EACH_CONTAINER(&engine_obj_list, obj, node) {
@@ -1081,7 +1081,7 @@ uint16_t lwm2m_get_rd_data(uint8_t *clie
 				break;
 			}
 
-			memcpy(&client_data[pos], temp, len);
+			(void) memcpy(&client_data[pos], temp, len);
 			pos += len;
 			continue;
 		}
@@ -1103,7 +1103,7 @@ uint16_t lwm2m_get_rd_data(uint8_t *clie
 					break;
 				}
 
-				memcpy(&client_data[pos], temp, len);
+				(void) memcpy(&client_data[pos], temp, len);
 				pos += len;
 			}
 		}
@@ -1455,11 +1455,11 @@ static int lwm2m_engine_set(char *pathst
 	switch (obj_field->data_type) {
 
 	case LWM2M_RES_TYPE_OPAQUE:
-		memcpy((uint8_t *)data_ptr, value, len);
+		(void) memcpy((uint8_t *)data_ptr, value, len);
 		break;
 
 	case LWM2M_RES_TYPE_STRING:
-		memcpy((uint8_t *)data_ptr, value, len);
+		(void) memcpy((uint8_t *)data_ptr, value, len);
 		((uint8_t *)data_ptr)[len] = '\0';
 		break;
 
@@ -1704,7 +1704,7 @@ static int lwm2m_engine_get(char *pathst
 				return -ENOMEM;
 			}
 
-			memcpy(buf, data_ptr, data_len);
+			(void) memcpy(buf, data_ptr, data_len);
 			break;
 
 		case LWM2M_RES_TYPE_STRING:
@@ -2600,7 +2600,7 @@ static int lwm2m_write_attr_handler(stru
 		}
 
 		vlen = options[i].len - plen - 1;
-		memcpy(opt_buf, options[i].value + plen + 1, vlen);
+		(void) memcpy(opt_buf, options[i].value + plen + 1, vlen);
 		opt_buf[vlen] = '\0';
 
 		/* convert value to integer or float */
@@ -2633,7 +2633,7 @@ static int lwm2m_write_attr_handler(stru
 		if (type <= LWM2M_ATTR_PMAX) {
 			*(int32_t *)nattr_ptrs[type] = val.val1;
 		} else {
-			memcpy(nattr_ptrs[type], &val, sizeof(float32_value_t));
+			(void) memcpy(nattr_ptrs[type], &val, sizeof(float32_value_t));
 		}
 
 		nattrs.flags |= BIT(type);
@@ -2700,8 +2700,8 @@ static int lwm2m_write_attr_handler(stru
 				continue;
 			}
 
-			memcpy(&attr->float_val, nattr_ptrs[type],
-			       sizeof(float32_value_t));
+			(void) memcpy(&attr->float_val, nattr_ptrs[type],
+					sizeof(float32_value_t));
 		}
 
 		LOG_DBG("Update %s to %d.%06d",
@@ -2734,8 +2734,8 @@ static int lwm2m_write_attr_handler(stru
 			attr->int_val = *(int32_t *)nattr_ptrs[type];
 			update_observe_node = true;
 		} else {
-			memcpy(&attr->float_val, nattr_ptrs[type],
-			       sizeof(float32_value_t));
+			(void) memcpy(&attr->float_val, nattr_ptrs[type],
+					sizeof(float32_value_t));
 		}
 
 		nattrs.flags &= ~BIT(type);
@@ -2929,7 +2929,7 @@ int lwm2m_perform_read_op(struct lwm2m_m
 	}
 
 	/* store original path values so we can change them during processing */
-	memcpy(&temp_path, &msg->path, sizeof(temp_path));
+	(void) memcpy(&temp_path, &msg->path, sizeof(temp_path));
 	engine_put_begin(&msg->out, &msg->path);
 
 	while (obj_inst) {
@@ -3015,7 +3015,7 @@ move_forward:
 	engine_put_end(&msg->out, &msg->path);
 
 	/* restore original path values */
-	memcpy(&msg->path, &temp_path, sizeof(temp_path));
+	(void) memcpy(&msg->path, &temp_path, sizeof(temp_path));
 
 	/* did not read anything even if we should have - on single item */
 	if (ret == 0 && num_read == 0U && msg->path.level == 3U) {
@@ -3948,7 +3948,7 @@ static int generate_notify_message(struc
 	}
 
 	/* copy path */
-	memcpy(&msg->path, &obs->path, sizeof(struct lwm2m_obj_path));
+	(void) memcpy(&msg->path, &obs->path, sizeof(struct lwm2m_obj_path));
 	msg->operation = LWM2M_OP_READ;
 
 	LOG_DBG("[%s] NOTIFY MSG START: %u/%u/%u(%u) token:'%s' [%s] %lld",
@@ -4465,7 +4465,7 @@ int lwm2m_parse_peerinfo(char *url, stru
 			goto cleanup;
 		}
 
-		memcpy(addr, res->ai_addr, sizeof(*addr));
+		(void) memcpy(addr, res->ai_addr, sizeof(*addr));
 		addr->sa_family = res->ai_family;
 		freeaddrinfo(res);
 #else
diff -u -p a/subsys/net/lib/socks/socks.c b/subsys/net/lib/socks/socks.c
--- a/subsys/net/lib/socks/socks.c
+++ b/subsys/net/lib/socks/socks.c
@@ -27,13 +27,13 @@ static void socks5_method_rsp_cb(struct 
 			(struct socks5_method_response *)user_data;
 
 	if (!pkt || status) {
-		memset(method_rsp, 0, sizeof(struct socks5_method_response));
+		(void) memset(method_rsp, 0, sizeof(struct socks5_method_response));
 		goto end;
 	}
 
 	if (net_pkt_read(pkt, (uint8_t *)method_rsp,
 			 sizeof(struct socks5_method_response))) {
-		memset(method_rsp, 0, sizeof(struct socks5_method_response));
+		(void) memset(method_rsp, 0, sizeof(struct socks5_method_response));
 	}
 
 end:
@@ -52,16 +52,16 @@ static void socks5_cmd_rsp_cb(struct net
 	int size;
 
 	if (!pkt || status) {
-		memset(cmd_rsp, 0,
-		       sizeof(struct socks5_command_request_common));
+		(void) memset(cmd_rsp, 0,
+				sizeof(struct socks5_command_request_common));
 		goto end;
 	}
 
 	size = sizeof(struct socks5_command_request_common);
 
 	if (net_pkt_read(pkt, (uint8_t *)cmd_rsp, size)) {
-		memset(cmd_rsp, 0,
-		       sizeof(struct socks5_command_request_common));
+		(void) memset(cmd_rsp, 0,
+				sizeof(struct socks5_command_request_common));
 	}
 
 end:
@@ -128,9 +128,9 @@ static int socks5_tcp_connect(struct net
 
 		cmd_req.r.atyp = SOCKS5_ATYP_IPV4;
 
-		memcpy(&cmd_req.ipv4_addr.addr,
-		       (uint8_t *)&d4->sin_addr,
-		       sizeof(cmd_req.ipv4_addr.addr));
+		(void) memcpy(&cmd_req.ipv4_addr.addr,
+				(uint8_t *)&d4->sin_addr,
+				sizeof(cmd_req.ipv4_addr.addr));
 
 		cmd_req.ipv4_addr.port = d4->sin_port;
 
@@ -142,9 +142,9 @@ static int socks5_tcp_connect(struct net
 
 		cmd_req.r.atyp = SOCKS5_ATYP_IPV6;
 
-		memcpy(&cmd_req.ipv6_addr.addr,
-		       (uint8_t *)&d6->sin6_addr,
-		       sizeof(cmd_req.ipv6_addr.addr));
+		(void) memcpy(&cmd_req.ipv6_addr.addr,
+				(uint8_t *)&d6->sin6_addr,
+				sizeof(cmd_req.ipv6_addr.addr));
 
 		cmd_req.ipv6_addr.port = d6->sin6_port;
 
diff -u -p a/subsys/net/lib/dns/resolve.c b/subsys/net/lib/dns/resolve.c
--- a/subsys/net/lib/dns/resolve.c
+++ b/subsys/net/lib/dns/resolve.c
@@ -239,8 +239,9 @@ int dns_resolve_init(struct dns_resolve_
 
 	if (servers_sa) {
 		for (i = 0; idx < SERVER_COUNT && servers_sa[i]; i++) {
-			memcpy(&ctx->servers[idx].dns_server, servers_sa[i],
-			       sizeof(ctx->servers[idx].dns_server));
+			(void) memcpy(&ctx->servers[idx].dns_server,
+					servers_sa[i],
+					sizeof(ctx->servers[idx].dns_server));
 			dns_postprocess_server(ctx, idx);
 			idx++;
 		}
@@ -526,7 +527,7 @@ int dns_validate_msg(struct dns_resolve_
 			}
 
 			src = dns_msg->msg + dns_msg->response_position;
-			memcpy(addr, src, address_size);
+			(void) memcpy(addr, src, address_size);
 
 		query_known:
 			ctx->queries[*query_idx].cb(DNS_EAI_INPROGRESS, &info,
@@ -974,8 +975,8 @@ int dns_resolve_name(struct dns_resolve_
 				goto quit;
 			}
 
-			memcpy(net_sin(&info.ai_addr), net_sin(&addr),
-			       sizeof(struct sockaddr_in));
+			(void) memcpy(net_sin(&info.ai_addr), net_sin(&addr),
+					sizeof(struct sockaddr_in));
 			info.ai_family = AF_INET;
 			info.ai_addr.sa_family = AF_INET;
 			info.ai_addrlen = sizeof(struct sockaddr_in);
@@ -992,8 +993,9 @@ int dns_resolve_name(struct dns_resolve_
 			}
 
 #if defined(CONFIG_NET_IPV6)
-			memcpy(net_sin6(&info.ai_addr), net_sin6(&addr),
-			       sizeof(struct sockaddr_in6));
+			(void) memcpy(net_sin6(&info.ai_addr),
+					net_sin6(&addr),
+					sizeof(struct sockaddr_in6));
 			info.ai_family = AF_INET6;
 			info.ai_addr.sa_family = AF_INET6;
 			info.ai_addrlen = sizeof(struct sockaddr_in6);
diff -u -p a/subsys/net/lib/sntp/sntp.c b/subsys/net/lib/sntp/sntp.c
--- a/subsys/net/lib/sntp/sntp.c
+++ b/subsys/net/lib/sntp/sntp.c
@@ -148,7 +148,7 @@ int sntp_init(struct sntp_ctx *ctx, stru
 		return -EFAULT;
 	}
 
-	memset(ctx, 0, sizeof(struct sntp_ctx));
+	(void) memset(ctx, 0, sizeof(struct sntp_ctx));
 
 	ctx->sock.fd = socket(addr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
 	if (ctx->sock.fd < 0) {
diff -u -p a/subsys/net/ip/net_context.c b/subsys/net/ip/net_context.c
--- a/subsys/net/ip/net_context.c
+++ b/subsys/net/ip/net_context.c
@@ -239,7 +239,7 @@ int net_context_get(sa_family_t family,
 			continue;
 		}
 
-		memset(&contexts[i], 0, sizeof(contexts[i]));
+		(void) memset(&contexts[i], 0, sizeof(contexts[i]));
 	/* FIXME - Figure out a way to get the correct network interface
 	 * as it is not known at this point yet.
 	 */
@@ -413,8 +413,9 @@ static int bind_default(struct net_conte
 		}
 
 		addr6.sin6_family = AF_INET6;
-		memcpy(&addr6.sin6_addr, net_ipv6_unspecified_address(),
-		       sizeof(addr6.sin6_addr));
+		(void) memcpy(&addr6.sin6_addr,
+				net_ipv6_unspecified_address(),
+				sizeof(addr6.sin6_addr));
 		addr6.sin6_port =
 			find_available_port(context,
 					    (struct sockaddr *)&addr6);
@@ -937,8 +938,8 @@ int net_context_connect(struct net_conte
 			goto unlock;
 		}
 
-		memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
-		       sizeof(struct in6_addr));
+		(void) memcpy(&addr6->sin6_addr, &net_sin6(addr)->sin6_addr,
+				sizeof(struct in6_addr));
 
 		addr6->sin6_port = net_sin6(addr)->sin6_port;
 		addr6->sin6_family = AF_INET6;
@@ -987,8 +988,8 @@ int net_context_connect(struct net_conte
 
 		addr4 = (struct sockaddr_in *)&context->remote;
 
-		memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
-		       sizeof(struct in_addr));
+		(void) memcpy(&addr4->sin_addr, &net_sin(addr)->sin_addr,
+				sizeof(struct in_addr));
 
 		addr4->sin_port = net_sin(addr)->sin_port;
 		addr4->sin_family = AF_INET;
@@ -1151,7 +1152,7 @@ static int get_context_proxy(struct net_
 
 	*len = MIN(context->options.proxy.addrlen, *len);
 
-	memcpy(addr, &context->options.proxy.addr, *len);
+	(void) memcpy(addr, &context->options.proxy.addr, *len);
 
 	return 0;
 #else
@@ -1168,7 +1169,7 @@ int net_context_get_timestamp(struct net
 
 	get_context_timepstamp(context, &is_timestamped, NULL);
 	if (is_timestamped) {
-		memcpy(timestamp, net_pkt_timestamp(pkt), sizeof(*timestamp));
+		(void) memcpy(timestamp, net_pkt_timestamp(pkt), sizeof(*timestamp));
 		return 0;
 	}
 
@@ -1471,8 +1472,8 @@ static int context_sendto(struct net_con
 			 * point to remote addr.
 			 */
 			if ((void *)&context->remote != (void *)ll_addr) {
-				memcpy((struct sockaddr_ll *)&context->remote,
-				       ll_addr, sizeof(struct sockaddr_ll));
+				(void) memcpy((struct sockaddr_ll *)&context->remote,
+						ll_addr, sizeof(struct sockaddr_ll));
 			}
 		}
 
@@ -1960,9 +1961,9 @@ int net_context_recv(struct net_context 
 			addr.sll_halen =
 				net_sll_ptr(&context->local)->sll_halen;
 
-			memcpy(addr.sll_addr,
-			       net_sll_ptr(&context->local)->sll_addr,
-			       MIN(addr.sll_halen, sizeof(addr.sll_addr)));
+			(void) memcpy(addr.sll_addr,
+					net_sll_ptr(&context->local)->sll_addr,
+					MIN(addr.sll_halen, sizeof(addr.sll_addr)));
 
 			ret = recv_raw(context, cb, timeout,
 				       (struct sockaddr *)&addr, user_data);
@@ -2102,7 +2103,7 @@ static int set_context_proxy(struct net_
 	}
 
 	context->options.proxy.addrlen = len;
-	memcpy(&context->options.proxy.addr, addr, len);
+	(void) memcpy(&context->options.proxy.addr, addr, len);
 
 	return 0;
 #else
diff -u -p a/subsys/net/ip/utils.c b/subsys/net/ip/utils.c
--- a/subsys/net/ip/utils.c
+++ b/subsys/net/ip/utils.c
@@ -466,7 +466,7 @@ int z_vrfy_net_addr_pton(sa_family_t fam
 		return -EINVAL;
 	}
 
-	memset(str, 0, sizeof(str));
+	(void) memset(str, 0, sizeof(str));
 
 	nlen = z_user_string_nlen((const char *)src, sizeof(str), &err);
 	if (err) {
@@ -663,10 +663,10 @@ static bool parse_ipv6(const char *str, 
 		}
 
 		end = MIN(len, ptr - (str + 1));
-		memcpy(ipaddr, str + 1, end);
+		(void) memcpy(ipaddr, str + 1, end);
 	} else {
 		end = len;
-		memcpy(ipaddr, str, end);
+		(void) memcpy(ipaddr, str, end);
 	}
 
 	ipaddr[end] = '\0';
@@ -700,7 +700,7 @@ static bool parse_ipv6(const char *str, 
 		}
 
 		/* Re-use the ipaddr buf for port conversion */
-		memcpy(ipaddr, ptr, len);
+		(void) memcpy(ipaddr, ptr, len);
 		ipaddr[len] = '\0';
 
 		ret = convert_port(ipaddr, &port);
@@ -761,7 +761,7 @@ static bool parse_ipv4(const char *str, 
 		end = len;
 	}
 
-	memcpy(ipaddr, str, end);
+	(void) memcpy(ipaddr, str, end);
 	ipaddr[end] = '\0';
 
 	addr4 = &net_sin(addr)->sin_addr;
@@ -777,7 +777,7 @@ static bool parse_ipv4(const char *str, 
 		return true;
 	}
 
-	memcpy(ipaddr, ptr + 1, str_len - end);
+	(void) memcpy(ipaddr, ptr + 1, str_len - end);
 	ipaddr[str_len - end] = '\0';
 
 	ret = convert_port(ipaddr, &port);
diff -u -p a/subsys/net/ip/6lo.c b/subsys/net/ip/6lo.c
--- a/subsys/net/ip/6lo.c
+++ b/subsys/net/ip/6lo.c
@@ -1401,8 +1401,8 @@ static bool uncompress_IPHC_header(struc
 
 		if ((iphc & NET_6LO_IPHC_SAM_MASK) == NET_6LO_IPHC_SAM_00) {
 			NET_DBG("SAM_00 unspecified address");
-			memset(&ipv6->src.s6_addr[0], 0,
-				sizeof(ipv6->src.s6_addr));
+			(void) memset(&ipv6->src.s6_addr[0], 0,
+					sizeof(ipv6->src.s6_addr));
 		} else if (IS_ENABLED(CONFIG_NET_6LO_CONTEXT)) {
 #if defined(CONFIG_NET_6LO_CONTEXT)
 			if (!src) {
diff -u -p a/subsys/net/ip/net_pkt.c b/subsys/net/ip/net_pkt.c
--- a/subsys/net/ip/net_pkt.c
+++ b/subsys/net/ip/net_pkt.c
@@ -773,7 +773,7 @@ bool net_pkt_compact(struct net_pkt *pkt
 				copy_len = net_buf_tailroom(frag);
 			}
 
-			memcpy(net_buf_tail(frag), frag->frags->data, copy_len);
+			(void) memcpy(net_buf_tail(frag), frag->frags->data, copy_len);
 			net_buf_add(frag, copy_len);
 
 			memmove(frag->frags->data,
@@ -1193,7 +1193,7 @@ static struct net_pkt *pkt_alloc(struct 
 		return NULL;
 	}
 
-	memset(pkt, 0, sizeof(struct net_pkt));
+	(void) memset(pkt, 0, sizeof(struct net_pkt));
 
 	pkt->atomic_ref = ATOMIC_INIT(1);
 	pkt->slab = slab;
@@ -1579,11 +1579,11 @@ static int net_pkt_cursor_operate(struct
 		}
 
 		if (copy) {
-			memcpy(write ? c_op->pos : data,
-			       write ? data : c_op->pos,
-			       len);
+			(void) memcpy(write ? c_op->pos : data,
+					write ? data : c_op->pos,
+					len);
 		} else if (data) {
-			memset(c_op->pos, *(int *)data, len);
+			(void) memset(c_op->pos, *(int *)data, len);
 		}
 
 		if (write && !net_pkt_is_being_overwritten(pkt)) {
@@ -1708,7 +1708,7 @@ int net_pkt_copy(struct net_pkt *pkt_dst
 			break;
 		}
 
-		memcpy(c_dst->pos, c_src->pos, len);
+		(void) memcpy(c_dst->pos, c_src->pos, len);
 
 		if (!net_pkt_is_being_overwritten(pkt_dst)) {
 			net_buf_add(c_dst->buf, len);
@@ -1783,10 +1783,10 @@ struct net_pkt *net_pkt_clone(struct net
 		 * a buffer that we copied because those pointers point
 		 * to start of the fragment which we do not have right now.
 		 */
-		memcpy(&clone_pkt->lladdr_src, &pkt->lladdr_src,
-		       sizeof(clone_pkt->lladdr_src));
-		memcpy(&clone_pkt->lladdr_dst, &pkt->lladdr_dst,
-		       sizeof(clone_pkt->lladdr_dst));
+		(void) memcpy(&clone_pkt->lladdr_src, &pkt->lladdr_src,
+				sizeof(clone_pkt->lladdr_src));
+		(void) memcpy(&clone_pkt->lladdr_dst, &pkt->lladdr_dst,
+				sizeof(clone_pkt->lladdr_dst));
 	}
 
 	clone_pkt_attributes(pkt, clone_pkt);
@@ -1829,10 +1829,10 @@ struct net_pkt *net_pkt_shallow_clone(st
 		 * a buffer that we copied because those pointers point
 		 * to start of the fragment which we do not have right now.
 		 */
-		memcpy(&clone_pkt->lladdr_src, &pkt->lladdr_src,
-		       sizeof(clone_pkt->lladdr_src));
-		memcpy(&clone_pkt->lladdr_dst, &pkt->lladdr_dst,
-		       sizeof(clone_pkt->lladdr_dst));
+		(void) memcpy(&clone_pkt->lladdr_src, &pkt->lladdr_src,
+				sizeof(clone_pkt->lladdr_src));
+		(void) memcpy(&clone_pkt->lladdr_dst, &pkt->lladdr_dst,
+				sizeof(clone_pkt->lladdr_dst));
 	}
 
 	clone_pkt_attributes(pkt, clone_pkt);
diff -u -p a/subsys/shell/shell_cmds.c b/subsys/shell/shell_cmds.c
--- a/subsys/shell/shell_cmds.c
+++ b/subsys/shell/shell_cmds.c
@@ -70,7 +70,7 @@ static int cursor_position_get(const str
 	*x = 0U;
 	*y = 0U;
 
-	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
+	(void) memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
 
 	/* escape code asking terminal about its size */
 	static char const cmd_get_terminal_size[] = "\033[6n";
diff -u -p a/subsys/shell/shell_wildcard.c b/subsys/shell/shell_wildcard.c
--- a/subsys/shell/shell_wildcard.c
+++ b/subsys/shell/shell_wildcard.c
@@ -33,7 +33,7 @@ static enum shell_wildcard_status comman
 
 	/* make place for new command: + 1 for space + 1 for EOS */
 	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
-	memcpy(completion_addr, cmd, cmd_len);
+	(void) memcpy(completion_addr, cmd, cmd_len);
 	/* adding space to not brake next command in the buffer */
 	completion_addr[cmd_len] = ' ';
 
@@ -142,8 +142,8 @@ void shell_wildcard_prepare(const struct
 	 *    including expanded commands, are passed as arguments.
 	 */
 
-	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
-	memcpy(shell->ctx->temp_buff,
+	(void) memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
+	(void) memcpy(shell->ctx->temp_buff,
 			shell->ctx->cmd_buff,
 			shell->ctx->cmd_buff_len);
 
@@ -186,8 +186,8 @@ enum shell_wildcard_status shell_wildcar
 
 void shell_wildcard_finalize(const struct shell *shell)
 {
-	memcpy(shell->ctx->cmd_buff,
-	       shell->ctx->temp_buff,
-	       shell->ctx->cmd_tmp_buff_len);
+	(void) memcpy(shell->ctx->cmd_buff,
+			shell->ctx->temp_buff,
+			shell->ctx->cmd_tmp_buff_len);
 	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
 }
diff -u -p a/subsys/usb/usb_descriptor.c b/subsys/usb/usb_descriptor.c
--- a/subsys/usb/usb_descriptor.c
+++ b/subsys/usb/usb_descriptor.c
@@ -307,8 +307,8 @@ __weak uint8_t *usb_update_sn_string_des
 	static uint8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
 	const char hex[] = "0123456789ABCDEF";
 
-	memset(hwid, 0, sizeof(hwid));
-	memset(sn, 0, sizeof(sn));
+	(void) memset(hwid, 0, sizeof(hwid));
+	(void) memset(sn, 0, sizeof(sn));
 
 	if (hwinfo_get_device_id(hwid, sizeof(hwid)) > 0) {
 		LOG_HEXDUMP_DBG(hwid, sizeof(hwid), "Serial Number");
@@ -343,7 +343,7 @@ static void usb_fix_ascii_sn_string_desc
 		return;
 	}
 
-	memcpy(sn->bString, runtime_sn, runtime_sn_len);
+	(void) memcpy(sn->bString, runtime_sn, runtime_sn_len);
 }
 
 /*
diff -u -p a/subsys/usb/class/audio/audio.c b/subsys/usb/class/audio/audio.c
--- a/subsys/usb/class/audio/audio.c
+++ b/subsys/usb/class/audio/audio.c
@@ -527,7 +527,7 @@ static int handle_fu_mute_req(struct usb
 	case USB_AUDIO_SET_CUR:
 		evt->val = control_val;
 		evt->val_len = *len;
-		memcpy(control_val, *data, *len);
+		(void) memcpy(control_val, *data, *len);
 		return 0;
 	case USB_AUDIO_GET_CUR:
 		*data = control_val;
diff -u -p a/subsys/canbus/canopen/canopen_program.c b/subsys/canbus/canopen/canopen_program.c
--- a/subsys/canbus/canopen/canopen_program.c
+++ b/subsys/canbus/canopen/canopen_program.c
@@ -247,7 +247,7 @@ static CO_SDO_abortCode_t canopen_odf_1f
 
 	/* Preserve old value */
 	cmd = odf_arg->data[0];
-	memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint8_t));
+	(void) memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint8_t));
 
 	LOG_DBG("program status = %d, cmd = %d", canopen_program_get_status(),
 		cmd);
@@ -294,7 +294,7 @@ static CO_SDO_abortCode_t canopen_odf_1f
 
 	if (!odf_arg->reading) {
 		/* Preserve old value */
-		memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
+		(void) memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
 		return CO_SDO_AB_READONLY;
 	}
 
@@ -363,7 +363,7 @@ static CO_SDO_abortCode_t canopen_odf_1f
 
 	if (!odf_arg->reading) {
 		/* Preserve old value */
-		memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
+		(void) memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
 		return CO_SDO_AB_READONLY;
 	}
 
diff -u -p a/subsys/bluetooth/mesh/proxy.c b/subsys/bluetooth/mesh/proxy.c
--- a/subsys/bluetooth/mesh/proxy.c
+++ b/subsys/bluetooth/mesh/proxy.c
@@ -1081,7 +1081,7 @@ static int node_id_adv(struct bt_mesh_su
 	}
 
 	(void)memset(tmp, 0, 6);
-	memcpy(tmp + 6, proxy_svc_data + 11, 8);
+	(void) memcpy(tmp + 6, proxy_svc_data + 11, 8);
 	sys_put_be16(bt_mesh_primary_addr(), tmp + 14);
 
 	err = bt_encrypt_be(sub->keys[sub->kr_flag].identity, tmp, tmp);
@@ -1089,7 +1089,7 @@ static int node_id_adv(struct bt_mesh_su
 		return err;
 	}
 
-	memcpy(proxy_svc_data + 3, tmp + 8, 8);
+	(void) memcpy(proxy_svc_data + 3, tmp + 8, 8);
 
 	err = bt_le_adv_start(&fast_adv_param, node_id_ad,
 			      ARRAY_SIZE(node_id_ad), NULL, 0);
@@ -1114,7 +1114,7 @@ static int net_id_adv(struct bt_mesh_sub
 	BT_DBG("Advertising with NetId %s",
 	       bt_hex(sub->keys[sub->kr_flag].net_id, 8));
 
-	memcpy(proxy_svc_data + 3, sub->keys[sub->kr_flag].net_id, 8);
+	(void) memcpy(proxy_svc_data + 3, sub->keys[sub->kr_flag].net_id, 8);
 
 	err = bt_le_adv_start(&slow_adv_param, net_id_ad,
 			      ARRAY_SIZE(net_id_ad), NULL, 0);
@@ -1238,7 +1238,7 @@ static size_t gatt_prov_adv_create(struc
 	size_t prov_sd_len = 0;
 	size_t sd_space = 31;
 
-	memcpy(prov_svc_data + 2, prov->uuid, 16);
+	(void) memcpy(prov_svc_data + 2, prov->uuid, 16);
 	sys_put_be16(prov->oob_info, prov_svc_data + 18);
 
 	if (prov->uri) {
diff -u -p a/subsys/bluetooth/mesh/pb_adv.c b/subsys/bluetooth/mesh/pb_adv.c
--- a/subsys/bluetooth/mesh/pb_adv.c
+++ b/subsys/bluetooth/mesh/pb_adv.c
@@ -364,7 +364,7 @@ static void gen_prov_cont(struct prov_rx
 		return;
 	}
 
-	memcpy(XACT_SEG_DATA(seg), buf->data, buf->len);
+	(void) memcpy(XACT_SEG_DATA(seg), buf->data, buf->len);
 	XACT_SEG_RECV(seg);
 
 	if (seg == link.rx.last_seg && !(link.rx.seg & BIT(0))) {
@@ -472,7 +472,7 @@ static void gen_prov_start(struct prov_r
 	}
 
 	link.rx.seg = seg & ((1 << (START_LAST_SEG(rx->gpc) + 1)) - 1);
-	memcpy(link.rx.buf->data, buf->data, buf->len);
+	(void) memcpy(link.rx.buf->data, buf->data, buf->len);
 	XACT_SEG_RECV(0);
 
 	if (!link.rx.seg) {
diff -u -p a/subsys/bluetooth/mesh/beacon.c b/subsys/bluetooth/mesh/beacon.c
--- a/subsys/bluetooth/mesh/beacon.c
+++ b/subsys/bluetooth/mesh/beacon.c
@@ -61,7 +61,7 @@ static struct bt_mesh_subnet *cache_chec
 
 static void cache_add(uint8_t data[21], struct bt_mesh_subnet *sub)
 {
-	memcpy(sub->beacon_cache, data, 21);
+	(void) memcpy(sub->beacon_cache, data, 21);
 }
 
 static void beacon_complete(int err, void *user_data)
diff -u -p a/subsys/bluetooth/mesh/crypto.c b/subsys/bluetooth/mesh/crypto.c
--- a/subsys/bluetooth/mesh/crypto.c
+++ b/subsys/bluetooth/mesh/crypto.c
@@ -118,7 +118,7 @@ int bt_mesh_k2(const uint8_t n[16], cons
 		return err;
 	}
 
-	memcpy(enc_key, out, 16);
+	(void) memcpy(enc_key, out, 16);
 
 	pad = 0x03;
 
@@ -127,7 +127,7 @@ int bt_mesh_k2(const uint8_t n[16], cons
 		return err;
 	}
 
-	memcpy(priv_key, out, 16);
+	(void) memcpy(priv_key, out, 16);
 
 	BT_DBG("NID 0x%02x enc_key %s", net_id[0], bt_hex(enc_key, 16));
 	BT_DBG("priv_key %s", bt_hex(priv_key, 16));
@@ -157,7 +157,7 @@ int bt_mesh_k3(const uint8_t n[16], uint
 		return err;
 	}
 
-	memcpy(out, tmp + 8, 8);
+	(void) memcpy(out, tmp + 8, 8);
 
 	return 0;
 }
@@ -265,7 +265,7 @@ int bt_mesh_net_obfuscate(uint8_t *pdu, 
 	BT_DBG("IVIndex %u, PrivacyKey %s", iv_index, bt_hex(privacy_key, 16));
 
 	sys_put_be32(iv_index, &priv_rand[5]);
-	memcpy(&priv_rand[9], &pdu[7], 7);
+	(void) memcpy(&priv_rand[9], &pdu[7], 7);
 
 	BT_DBG("PrivacyRandom %s", bt_hex(priv_rand, 16));
 
@@ -540,14 +540,14 @@ int bt_mesh_beacon_auth(const uint8_t be
 	BT_DBG("IV Index 0x%08x", iv_index);
 
 	msg[0] = flags;
-	memcpy(&msg[1], net_id, 8);
+	(void) memcpy(&msg[1], net_id, 8);
 	sys_put_be32(iv_index, &msg[9]);
 
 	BT_DBG("BeaconMsg %s", bt_hex(msg, sizeof(msg)));
 
 	err = bt_mesh_aes_cmac_one(beacon_key, msg, sizeof(msg), tmp);
 	if (!err) {
-		memcpy(auth, tmp, 8);
+		(void) memcpy(auth, tmp, 8);
 	}
 
 	return err;
diff -u -p a/subsys/bluetooth/host/l2cap.c b/subsys/bluetooth/host/l2cap.c
--- a/subsys/bluetooth/host/l2cap.c
+++ b/subsys/bluetooth/host/l2cap.c
@@ -1157,7 +1157,7 @@ response:
 	if (result == BT_L2CAP_LE_ERR_UNACCEPT_PARAMS ||
 	    result == BT_L2CAP_LE_ERR_PSM_NOT_SUPP ||
 	    result == BT_L2CAP_LE_ERR_AUTHENTICATION) {
-		memset(dcid, 0, sizeof(scid) * i);
+		(void) memset(dcid, 0, sizeof(scid) * i);
 	} else if (ch) {
 		rsp->mps = sys_cpu_to_le16(ch->rx.mps);
 		rsp->mtu = sys_cpu_to_le16(ch->rx.mtu);
@@ -2051,7 +2051,7 @@ int bt_l2cap_chan_recv_complete(struct b
 	BT_DBG("chan %p buf %p", chan, buf);
 
 	/* Restore credits used by packet */
-	memcpy(&credits, net_buf_user_data(buf), sizeof(credits));
+	(void) memcpy(&credits, net_buf_user_data(buf), sizeof(credits));
 
 	l2cap_chan_send_credits(ch, buf, credits);
 
@@ -2105,7 +2105,7 @@ static void l2cap_chan_le_recv_seg(struc
 
 	len = net_buf_frags_len(chan->_sdu);
 	if (len) {
-		memcpy(&seg, net_buf_user_data(chan->_sdu), sizeof(seg));
+		(void) memcpy(&seg, net_buf_user_data(chan->_sdu), sizeof(seg));
 	}
 
 	if (len + buf->len > chan->_sdu_len) {
@@ -2116,7 +2116,7 @@ static void l2cap_chan_le_recv_seg(struc
 
 	seg++;
 	/* Store received segments in user_data */
-	memcpy(net_buf_user_data(chan->_sdu), &seg, sizeof(seg));
+	(void) memcpy(net_buf_user_data(chan->_sdu), &seg, sizeof(seg));
 
 	BT_DBG("chan %p seg %d len %zu", chan, seg, net_buf_frags_len(buf));
 
diff -u -p a/subsys/bluetooth/host/gatt.c b/subsys/bluetooth/host/gatt.c
--- a/subsys/bluetooth/host/gatt.c
+++ b/subsys/bluetooth/host/gatt.c
@@ -105,7 +105,7 @@ static ssize_t write_name(struct bt_conn
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 	}
 
-	memcpy(value, buf, len);
+	(void) memcpy(value, buf, len);
 
 	bt_set_name(value);
 
@@ -254,7 +254,7 @@ static void sc_store(struct gatt_sc_cfg 
 
 static void clear_sc_cfg(struct gatt_sc_cfg *cfg)
 {
-	memset(cfg, 0, sizeof(*cfg));
+	(void) memset(cfg, 0, sizeof(*cfg));
 }
 
 static int bt_gatt_clear_sc(uint8_t id, const bt_addr_le_t *addr)
@@ -320,7 +320,7 @@ static void sc_reset(struct gatt_sc_cfg 
 {
 	BT_DBG("peer %s", bt_addr_le_str(&cfg->peer));
 
-	memset(&cfg->data, 0, sizeof(cfg->data));
+	(void) memset(&cfg->data, 0, sizeof(cfg->data));
 
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 		sc_store(cfg);
@@ -444,7 +444,7 @@ static struct gatt_cf_cfg cf_cfg[CF_CFG_
 static void clear_cf_cfg(struct gatt_cf_cfg *cfg)
 {
 	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
-	memset(cfg->data, 0, sizeof(cfg->data));
+	(void) memset(cfg->data, 0, sizeof(cfg->data));
 	atomic_set(cfg->flags, 0);
 }
 
@@ -476,7 +476,7 @@ static ssize_t cf_read(struct bt_conn *c
 
 	cfg = find_cf_cfg(conn);
 	if (cfg) {
-		memcpy(data, cfg->data, sizeof(data));
+		(void) memcpy(data, cfg->data, sizeof(data));
 	}
 
 	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
@@ -1231,7 +1231,7 @@ ssize_t bt_gatt_attr_read(struct bt_conn
 	BT_DBG("handle 0x%04x offset %u length %u", attr->handle, offset,
 	       len);
 
-	memcpy(buf, (uint8_t *)value + offset, len);
+	(void) memcpy(buf, (uint8_t *)value + offset, len);
 
 	return len;
 }
@@ -1386,7 +1386,7 @@ ssize_t bt_gatt_attr_read_chrc(struct bt
 		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
 		value_len += 2U;
 	} else {
-		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
+		(void) memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
 		value_len += 16U;
 	}
 
@@ -1805,7 +1805,7 @@ static int gatt_notify_mult(struct bt_co
 	nfy->len = sys_cpu_to_le16(params->len);
 
 	net_buf_add(*buf, params->len);
-	memcpy(nfy->value, params->data, params->len);
+	(void) memcpy(nfy->value, params->data, params->len);
 
 	k_work_submit(&nfy_mult_work);
 
@@ -1854,7 +1854,7 @@ static int gatt_notify(struct bt_conn *c
 	nfy->handle = sys_cpu_to_le16(handle);
 
 	net_buf_add(buf, params->len);
-	memcpy(nfy->value, params->data, params->len);
+	(void) memcpy(nfy->value, params->data, params->len);
 
 	return bt_att_send(conn, buf, params->func, params->user_data);
 }
@@ -1934,7 +1934,7 @@ static int gatt_indicate(struct bt_conn 
 	ind->handle = sys_cpu_to_le16(handle);
 
 	net_buf_add(buf, params->len);
-	memcpy(ind->value, params->data, params->len);
+	(void) memcpy(ind->value, params->data, params->len);
 
 	if (!params->func) {
 		return gatt_send(conn, buf, NULL, NULL, NULL);
@@ -2867,7 +2867,7 @@ static void read_included_uuid_cb(struct
 	value.end_handle = params->_included.end_handle;
 	value.uuid = &u.uuid;
 	u.uuid.type = BT_UUID_TYPE_128;
-	memcpy(u.u128.val, pdu, length);
+	(void) memcpy(u.u128.val, pdu, length);
 
 	BT_DBG("handle 0x%04x uuid %s start_handle 0x%04x "
 	       "end_handle 0x%04x\n", params->_included.attr_handle,
@@ -3053,7 +3053,7 @@ static uint16_t parse_characteristic(str
 			u.u16.val = sys_le16_to_cpu(chrc->uuid16);
 			break;
 		case BT_UUID_TYPE_128:
-			memcpy(u.u128.val, chrc->uuid, sizeof(chrc->uuid));
+			(void) memcpy(u.u128.val, chrc->uuid, sizeof(chrc->uuid));
 			break;
 		}
 
@@ -3184,11 +3184,11 @@ static uint16_t parse_service(struct bt_
 
 		switch (u.uuid.type) {
 		case BT_UUID_TYPE_16:
-			memcpy(&u.u16.val, data->value, sizeof(u.u16.val));
+			(void) memcpy(&u.u16.val, data->value, sizeof(u.u16.val));
 			u.u16.val = sys_le16_to_cpu(u.u16.val);
 			break;
 		case BT_UUID_TYPE_128:
-			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
+			(void) memcpy(u.u128.val, data->value, sizeof(u.u128.val));
 			break;
 		}
 
@@ -3339,7 +3339,7 @@ static void gatt_find_info_rsp(struct bt
 			u.u16.val = sys_le16_to_cpu(info.i16->uuid);
 			break;
 		case BT_UUID_TYPE_128:
-			memcpy(u.u128.val, info.i128->uuid, 16);
+			(void) memcpy(u.u128.val, info.i128->uuid, 16);
 			break;
 		}
 
@@ -3999,13 +3999,13 @@ static uint8_t gatt_ccc_discover_cb(stru
 	struct bt_gatt_subscribe_params *sub_params = params->sub_params;
 
 	if (!attr) {
-		memset(params, 0, sizeof(*params));
+		(void) memset(params, 0, sizeof(*params));
 		sub_params->notify(conn, sub_params, NULL, 0);
 		return BT_GATT_ITER_STOP;
 	}
 
 	if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
-		memset(params, 0, sizeof(*params));
+		(void) memset(params, 0, sizeof(*params));
 		sub_params->ccc_handle = attr->handle;
 
 		if (bt_gatt_subscribe(conn, sub_params)) {
@@ -4027,8 +4027,8 @@ static int gatt_ccc_discover(struct bt_c
 	int err;
 	static struct bt_uuid_16 ccc_uuid = BT_UUID_INIT_16(0);
 
-	memcpy(&ccc_uuid, BT_UUID_GATT_CCC, sizeof(ccc_uuid));
-	memset(params->disc_params, 0, sizeof(*params->disc_params));
+	(void) memcpy(&ccc_uuid, BT_UUID_GATT_CCC, sizeof(ccc_uuid));
+	(void) memset(params->disc_params, 0, sizeof(*params->disc_params));
 
 	params->disc_params->sub_params = params;
 	params->disc_params->uuid = &ccc_uuid.uuid;
@@ -4739,7 +4739,7 @@ static int sc_set(const char *name, size
 		BT_DBG("Restored SC for %s", bt_addr_le_str(&addr));
 	} else if (cfg) {
 		/* Clear configuration */
-		memset(cfg, 0, sizeof(*cfg));
+		(void) memset(cfg, 0, sizeof(*cfg));
 
 		BT_DBG("Removed SC for %s", bt_addr_le_str(&addr));
 	}
@@ -4898,7 +4898,7 @@ static uint8_t remove_peer_from_attr(con
 	/* Check if there is a cfg for the peer */
 	cfg = ccc_find_cfg(ccc, addr_with_id->addr, addr_with_id->id);
 	if (cfg) {
-		memset(cfg, 0, sizeof(*cfg));
+		(void) memset(cfg, 0, sizeof(*cfg));
 	}
 
 	return BT_GATT_ITER_CONTINUE;
diff -u -p a/subsys/bluetooth/host/keys_br.c b/subsys/bluetooth/host/keys_br.c
--- a/subsys/bluetooth/host/keys_br.c
+++ b/subsys/bluetooth/host/keys_br.c
@@ -193,7 +193,7 @@ static int link_key_set(const char *name
 		return 0;
 	}
 
-	memcpy(link_key->storage_start, val, len);
+	(void) memcpy(link_key->storage_start, val, len);
 	BT_DBG("Successfully restored link key for %s",
 	       bt_addr_le_str(&le_addr));
 #if IS_ENABLED(CONFIG_BT_KEYS_OVERWRITE_OLDEST)
diff -u -p a/subsys/bluetooth/shell/bt.c b/subsys/bluetooth/shell/bt.c
--- a/subsys/bluetooth/shell/bt.c
+++ b/subsys/bluetooth/shell/bt.c
@@ -79,7 +79,7 @@ static bool data_cb(struct bt_data *data
 	switch (data->type) {
 	case BT_DATA_NAME_SHORTENED:
 	case BT_DATA_NAME_COMPLETE:
-		memcpy(name, data->data, MIN(data->data_len, NAME_LEN - 1));
+		(void) memcpy(name, data->data, MIN(data->data_len, NAME_LEN - 1));
 		return false;
 	default:
 		return true;
@@ -905,7 +905,7 @@ static int cmd_directed_adv(const struct
 static bool adv_param_parse(size_t argc, char *argv[],
 			   struct bt_le_adv_param *param)
 {
-	memset(param, 0, sizeof(struct bt_le_adv_param));
+	(void) memset(param, 0, sizeof(struct bt_le_adv_param));
 
 	if (!strcmp(argv[1], "conn-scan")) {
 		param->options |= BT_LE_ADV_OPT_CONNECTABLE;
@@ -1990,7 +1990,7 @@ static int cmd_oob_remote(const struct s
 
 static int cmd_oob_clear(const struct shell *shell, size_t argc, char *argv[])
 {
-	memset(&oob_remote, 0, sizeof(oob_remote));
+	(void) memset(&oob_remote, 0, sizeof(oob_remote));
 	bt_set_oob_data_flag(false);
 
 	return 0;
diff -u -p a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c
--- a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c
+++ b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_conn.c
@@ -303,8 +303,8 @@ lll_conn_isr_rx_exit:
 
 			pkt_decrypt_data = (uint8_t *)radio_pkt_decrypt_get() +
 					   offsetof(struct pdu_data, lldata);
-			memcpy((void *)pdu_data_rx->lldata,
-			       (void *)pkt_decrypt_data, pdu_data_rx->len);
+			(void) memcpy((void *)pdu_data_rx->lldata,
+					(void *)pkt_decrypt_data, pdu_data_rx->len);
 		}
 #endif
 
@@ -618,8 +618,8 @@ static int isr_rx_pdu(struct lll_conn *l
 		uint8_t *pkt_decrypt;
 
 		pkt_decrypt = radio_pkt_decrypt_get();
-		memcpy((void *)pdu_data_rx, (void *)pkt_decrypt,
-		       offsetof(struct pdu_data, lldata));
+		(void) memcpy((void *)pdu_data_rx, (void *)pkt_decrypt,
+				offsetof(struct pdu_data, lldata));
 	}
 #endif
 
@@ -722,11 +722,11 @@ static int isr_rx_pdu(struct lll_conn *l
 
 					if (ctrl_pdu_len_check(
 						scratch_pkt->len)) {
-						memcpy(pdu_data_rx,
-						       scratch_pkt,
-						       scratch_pkt->len +
-						       offsetof(struct pdu_data,
-							llctrl));
+						(void) memcpy(pdu_data_rx,
+								scratch_pkt,
+								scratch_pkt->len +
+								offsetof(struct pdu_data,
+									 llctrl));
 						mic_failure = false;
 						lll->ccm_rx.counter--;
 					}
diff -u -p a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c
--- a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c
+++ b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c
@@ -148,7 +148,7 @@ int lll_adv_scan_req_report(struct lll_a
 	 */
 	pdu_adv = (void *)node_rx->pdu;
 	pdu_len = offsetof(struct pdu_adv, payload) + pdu_adv_rx->len;
-	memcpy(pdu_adv, pdu_adv_rx, pdu_len);
+	(void) memcpy(pdu_adv, pdu_adv_rx, pdu_len);
 
 	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? (radio_rssi_get() & 0x7f) :
 						  0x7f;
@@ -654,8 +654,8 @@ static struct pdu_adv *chan_prepare(stru
 			/* Copy the address from the adv packet we will send
 			 * into the scan response.
 			 */
-			memcpy(&scan_pdu->scan_rsp.addr[0],
-			       &pdu->adv_ind.addr[0], BDADDR_SIZE);
+			(void) memcpy(&scan_pdu->scan_rsp.addr[0],
+					&pdu->adv_ind.addr[0], BDADDR_SIZE);
 		}
 #else
 		ARG_UNUSED(scan_pdu);
@@ -788,8 +788,8 @@ static inline int isr_rx_pdu(struct lll_
 		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 		rx->hdr.handle = 0xffff;
 
-		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
-					 sizeof(struct pdu_adv_connect_ind)));
+		(void) memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
+						sizeof(struct pdu_adv_connect_ind)));
 
 		ftr = &(rx->hdr.rx_ftr);
 		ftr->param = lll;
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_slave.c b/subsys/bluetooth/controller/ll_sw/ull_slave.c
--- a/subsys/bluetooth/controller/ll_sw/ull_slave.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_slave.c
@@ -456,8 +456,8 @@ uint8_t ll_start_enc_req_send(uint16_t h
 			return BT_HCI_ERR_CMD_DISALLOWED;
 		}
 
-		memcpy(&conn->llcp_enc.ltk[0], ltk,
-		       sizeof(conn->llcp_enc.ltk));
+		(void) memcpy(&conn->llcp_enc.ltk[0], ltk,
+				sizeof(conn->llcp_enc.ltk));
 
 		conn->llcp.encryption.error_code = 0U;
 		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
diff -u -p a/subsys/bluetooth/controller/ll_sw/ll_addr.c b/subsys/bluetooth/controller/ll_sw/ll_addr.c
--- a/subsys/bluetooth/controller/ll_sw/ll_addr.c
+++ b/subsys/bluetooth/controller/ll_sw/ll_addr.c
@@ -40,14 +40,14 @@ uint8_t *ll_addr_get(uint8_t addr_type, 
 
 	if (addr_type) {
 		if (bdaddr) {
-			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
+			(void) memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
 		}
 
 		return rnd_addr;
 	}
 
 	if (bdaddr) {
-		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
+		(void) memcpy(bdaddr, pub_addr, BDADDR_SIZE);
 	}
 
 	return pub_addr;
@@ -71,9 +71,9 @@ uint8_t ll_addr_set(uint8_t addr_type, u
 	}
 
 	if (addr_type) {
-		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
+		(void) memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 	} else {
-		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
+		(void) memcpy(pub_addr, bdaddr, BDADDR_SIZE);
 	}
 
 	return 0;
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_conn.c b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_conn.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_conn.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_conn.c
@@ -757,11 +757,11 @@ static int isr_rx_pdu(struct lll_conn *l
 
 					if (ctrl_pdu_len_check(
 						scratch_pkt->len)) {
-						memcpy(pdu_data_rx,
-						       scratch_pkt,
-						       scratch_pkt->len +
-						       offsetof(struct pdu_data,
-							llctrl));
+						(void) memcpy(pdu_data_rx,
+								scratch_pkt,
+								scratch_pkt->len +
+								offsetof(struct pdu_data,
+									 llctrl));
 						mic_failure = false;
 						lll->ccm_rx.counter--;
 					}
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c
@@ -598,8 +598,8 @@ static void chan_prepare(struct lll_adv 
 		/* Copy the address from the adv packet we will send into the
 		 * scan response.
 		 */
-		memcpy(&scan_pdu->scan_rsp.addr[0],
-		       &pdu->adv_ind.addr[0], BDADDR_SIZE);
+		(void) memcpy(&scan_pdu->scan_rsp.addr[0],
+				&pdu->adv_ind.addr[0], BDADDR_SIZE);
 	}
 #else
 	ARG_UNUSED(scan_pdu);
@@ -734,8 +734,8 @@ static inline int isr_rx_pdu(struct lll_
 		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 		rx->hdr.handle = 0xffff;
 
-		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
-					 sizeof(struct pdu_adv_connect_ind)));
+		(void) memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
+						sizeof(struct pdu_adv_connect_ind)));
 
 		ftr = &(rx->hdr.rx_ftr);
 		ftr->param = lll;
@@ -809,7 +809,7 @@ static inline int isr_rx_sr_report(struc
 	 */
 	pdu_adv = (void *)node_rx->pdu;
 	pdu_len = offsetof(struct pdu_adv, payload) + pdu_adv_rx->len;
-	memcpy(pdu_adv, pdu_adv_rx, pdu_len);
+	(void) memcpy(pdu_adv, pdu_adv_rx, pdu_len);
 
 	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ? (radio_rssi_get() & 0x7f) :
 						  0x7f;
diff -u -p a/subsys/bluetooth/controller/hci/hci.c b/subsys/bluetooth/controller/hci/hci.c
--- a/subsys/bluetooth/controller/hci/hci.c
+++ b/subsys/bluetooth/controller/hci/hci.c
@@ -878,7 +878,7 @@ static void le_encrypt(struct net_buf *b
 	rp = hci_cmd_complete(evt, sizeof(*rp));
 
 	rp->status = 0x00;
-	memcpy(rp->enc_data, enc_data, 16);
+	(void) memcpy(rp->enc_data, enc_data, 16);
 }
 
 static void le_rand(struct net_buf *buf, struct net_buf **evt)
@@ -2542,7 +2542,7 @@ static void vs_read_build_info(struct ne
 
 	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
 	rp->status = 0x00;
-	memcpy(rp->info, build_info, sizeof(build_info));
+	(void) memcpy(rp->info, build_info, sizeof(build_info));
 }
 
 void __weak hci_vendor_read_key_hierarchy_roots(uint8_t ir[16], uint8_t er[16])
@@ -2676,7 +2676,7 @@ static void mesh_set_scan_filter(struct 
 			goto exit;
 		}
 		f->lengths[i] = cmd->patterns[i].pattern_len;
-		memcpy(f->patterns[i], cmd->patterns[i].pattern, f->lengths[i]);
+		(void) memcpy(f->patterns[i], cmd->patterns[i].pattern, f->lengths[i]);
 	}
 
 	f->count = cmd->num_patterns;
@@ -2965,7 +2965,7 @@ int hci_acl_handle(struct net_buf *buf, 
 	}
 
 	pdu_data->len = len;
-	memcpy(&pdu_data->lldata[0], buf->data, len);
+	(void) memcpy(&pdu_data->lldata[0], buf->data, len);
 
 	if (ll_tx_mem_enqueue(handle, node_tx)) {
 		BT_ERR("Invalid Tx Enqueue");
@@ -3001,8 +3001,8 @@ static inline bool dup_found(struct pdu_
 		}
 
 		/* insert into the duplicate filter */
-		memcpy(&dup_filter[dup_curr].addr.a.val[0],
-		       &adv->adv_ind.addr[0], sizeof(bt_addr_t));
+		(void) memcpy(&dup_filter[dup_curr].addr.a.val[0],
+				&adv->adv_ind.addr[0], sizeof(bt_addr_t));
 		dup_filter[dup_curr].addr.type = adv->tx_addr;
 		dup_filter[dup_curr].mask = BIT(adv->type);
 
@@ -3063,13 +3063,14 @@ static inline void le_dir_adv_report(str
 	if (1) {
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 		dir_info->addr.type = adv->tx_addr;
-		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
-		       sizeof(bt_addr_t));
+		(void) memcpy(&dir_info->addr.a.val[0],
+				&adv->direct_ind.adv_addr[0],
+				sizeof(bt_addr_t));
 	}
 
 	dir_info->dir_addr.type = adv->rx_addr;
-	memcpy(&dir_info->dir_addr.a.val[0],
-	       &adv->direct_ind.tgt_addr[0], sizeof(bt_addr_t));
+	(void) memcpy(&dir_info->dir_addr.a.val[0],
+			&adv->direct_ind.tgt_addr[0], sizeof(bt_addr_t));
 
 	dir_info->rssi = rssi;
 }
@@ -3122,13 +3123,13 @@ static inline void le_mesh_scan_report(s
 	mep->num_reports = 1U;
 	sr = (void *)(((uint8_t *)mep) + sizeof(*mep));
 	sr->addr.type = adv->tx_addr;
-	memcpy(&sr->addr.a.val[0], &adv->adv_ind.addr[0], sizeof(bt_addr_t));
+	(void) memcpy(&sr->addr.a.val[0], &adv->adv_ind.addr[0], sizeof(bt_addr_t));
 	sr->chan = chan;
 	sr->rssi = rssi;
 	sys_put_le32(instant, (uint8_t *)&sr->instant);
 
 	sr->data_len = data_len;
-	memcpy(&sr->data[0], &adv->adv_ind.data[0], data_len);
+	(void) memcpy(&sr->data[0], &adv->adv_ind.data[0], data_len);
 }
 #endif /* CONFIG_BT_HCI_MESH_EXT */
 
@@ -3224,12 +3225,12 @@ static void le_advertising_report(struct
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 
 		adv_info->addr.type = adv->tx_addr;
-		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
-		       sizeof(bt_addr_t));
+		(void) memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
+				sizeof(bt_addr_t));
 	}
 
 	adv_info->length = data_len;
-	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
+	(void) memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
 	/* RSSI */
 	prssi = &adv_info->data[0] + data_len;
 	*prssi = rssi;
@@ -3333,8 +3334,8 @@ static void le_ext_adv_legacy_report(str
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 	{
 		adv_info->addr.type = adv->tx_addr;
-		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
-		       sizeof(bt_addr_t));
+		(void) memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
+				sizeof(bt_addr_t));
 	}
 
 	adv_info->prim_phy = BT_HCI_LE_EXT_SCAN_PHY_1M;
@@ -3347,16 +3348,16 @@ static void le_ext_adv_legacy_report(str
 	adv_info->direct_addr.type = adv->rx_addr;
 #if defined(CONFIG_BT_CTLR_EXT_SCAN_FP)
 	if (direct) {
-		memcpy(&adv_info->direct_addr.a.val[0],
-		       &adv->direct_ind.tgt_addr[0], sizeof(bt_addr_t));
+		(void) memcpy(&adv_info->direct_addr.a.val[0],
+				&adv->direct_ind.tgt_addr[0], sizeof(bt_addr_t));
 	} else
 #endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */
 	{
-		memset(&adv_info->direct_addr.a.val[0], 0, sizeof(bt_addr_t));
+		(void) memset(&adv_info->direct_addr.a.val[0], 0, sizeof(bt_addr_t));
 	}
 
 	adv_info->length = data_len;
-	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
+	(void) memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
 }
 
 static void le_ext_adv_report(struct pdu_data *pdu_data,
@@ -3440,7 +3441,7 @@ static void le_ext_adv_report(struct pdu
 			adv_addr_curr = ptr;
 
 			addr.type = adv->tx_addr;
-			memcpy(&addr.a.val[0], ptr, sizeof(bt_addr_t));
+			(void) memcpy(&addr.a.val[0], ptr, sizeof(bt_addr_t));
 			ptr += BDADDR_SIZE;
 
 			BT_DBG("    AdvA: %s", bt_addr_le_str(&addr));
@@ -3453,7 +3454,7 @@ static void le_ext_adv_report(struct pdu
 			direct_addr_curr = ptr;
 
 			addr.type = adv->rx_addr;
-			memcpy(&addr.a.val[0], ptr, sizeof(bt_addr_t));
+			(void) memcpy(&addr.a.val[0], ptr, sizeof(bt_addr_t));
 			ptr += BDADDR_SIZE;
 
 			BT_DBG("    TgtA: %s", bt_addr_le_str(&addr));
@@ -3648,10 +3649,10 @@ no_ext_hdr:
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 	} else if (adv_addr) {
 		adv_info->addr.type = adv_addr_type;
-		memcpy(&adv_info->addr.a.val[0], adv_addr, sizeof(bt_addr_t));
+		(void) memcpy(&adv_info->addr.a.val[0], adv_addr, sizeof(bt_addr_t));
 	} else {
 		adv_info->addr.type = 0U;
-		memset(&adv_info->addr.a.val[0], 0, sizeof(bt_addr_t));
+		(void) memset(&adv_info->addr.a.val[0], 0, sizeof(bt_addr_t));
 	}
 
 	adv_info->prim_phy = find_lsb_set(phy);
@@ -3663,15 +3664,15 @@ no_ext_hdr:
 
 	if (evt_type & BT_HCI_LE_ADV_EVT_TYPE_DIRECT) {
 		adv_info->direct_addr.type = direct_addr_type;
-		memcpy(&adv_info->direct_addr.a.val[0], direct_addr,
-		       sizeof(bt_addr_t));
+		(void) memcpy(&adv_info->direct_addr.a.val[0], direct_addr,
+				sizeof(bt_addr_t));
 	} else {
 		adv_info->direct_addr.type = 0U;
-		memset(&adv_info->direct_addr.a.val[0], 0, sizeof(bt_addr_t));
+		(void) memset(&adv_info->direct_addr.a.val[0], 0, sizeof(bt_addr_t));
 	}
 
 	adv_info->length = data_len;
-	memcpy(&adv_info->data[0], data, data_len);
+	(void) memcpy(&adv_info->data[0], data, data_len);
 
 le_ext_adv_report_invalid:
 	/* Free the node_rx list */
@@ -3765,8 +3766,8 @@ static void le_scan_req_received(struct 
 
 		handle = node_rx->hdr.handle & 0xff;
 		addr.type = adv->tx_addr;
-		memcpy(&addr.a.val[0], &adv->scan_req.scan_addr[0],
-		       sizeof(bt_addr_t));
+		(void) memcpy(&addr.a.val[0], &adv->scan_req.scan_addr[0],
+				sizeof(bt_addr_t));
 
 		/* The Link Layer currently returns RSSI as an absolute value */
 		rssi = -(node_rx->hdr.rx_ftr.rssi);
@@ -3780,8 +3781,8 @@ static void le_scan_req_received(struct 
 	sep = meta_evt(buf, BT_HCI_EVT_LE_SCAN_REQ_RECEIVED, sizeof(*sep));
 	sep->handle = node_rx->hdr.handle & 0xff;
 	sep->addr.type = adv->tx_addr;
-	memcpy(&sep->addr.a.val[0], &adv->scan_req.scan_addr[0],
-	       sizeof(bt_addr_t));
+	(void) memcpy(&sep->addr.a.val[0], &adv->scan_req.scan_addr[0],
+			sizeof(bt_addr_t));
 
 #if defined(CONFIG_BT_CTLR_PRIVACY)
 	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
@@ -3796,8 +3797,8 @@ static void le_scan_req_received(struct 
 	if (1) {
 #endif
 		sep->addr.type = adv->tx_addr;
-		memcpy(&sep->addr.a.val[0], &adv->adv_ind.addr[0],
-		       sizeof(bt_addr_t));
+		(void) memcpy(&sep->addr.a.val[0], &adv->adv_ind.addr[0],
+				sizeof(bt_addr_t));
 	}
 }
 #endif /* CONFIG_BT_CTLR_SCAN_REQ_NOTIFY */
@@ -3851,17 +3852,19 @@ static void le_conn_complete(struct pdu_
 		leecc->role = node_rx->role;
 
 		leecc->peer_addr.type = node_rx->peer_addr_type;
-		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
-		       BDADDR_SIZE);
+		(void) memcpy(&leecc->peer_addr.a.val[0],
+				&node_rx->peer_addr[0],
+				BDADDR_SIZE);
 
 #if defined(CONFIG_BT_CTLR_PRIVACY)
-		memcpy(&leecc->local_rpa.val[0], &node_rx->local_rpa[0],
-		       BDADDR_SIZE);
-		memcpy(&leecc->peer_rpa.val[0], &node_rx->peer_rpa[0],
-		       BDADDR_SIZE);
+		(void) memcpy(&leecc->local_rpa.val[0],
+				&node_rx->local_rpa[0],
+				BDADDR_SIZE);
+		(void) memcpy(&leecc->peer_rpa.val[0], &node_rx->peer_rpa[0],
+				BDADDR_SIZE);
 #else /* !CONFIG_BT_CTLR_PRIVACY */
-		memset(&leecc->local_rpa.val[0], 0, BDADDR_SIZE);
-		memset(&leecc->peer_rpa.val[0], 0, BDADDR_SIZE);
+		(void) memset(&leecc->local_rpa.val[0], 0, BDADDR_SIZE);
+		(void) memset(&leecc->peer_rpa.val[0], 0, BDADDR_SIZE);
 #endif /* !CONFIG_BT_CTLR_PRIVACY */
 
 		leecc->interval = sys_cpu_to_le16(node_rx->interval);
@@ -3884,7 +3887,7 @@ static void le_conn_complete(struct pdu_
 	lecc->handle = sys_cpu_to_le16(handle);
 	lecc->role = node_rx->role;
 	lecc->peer_addr.type = node_rx->peer_addr_type & 0x1;
-	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
+	(void) memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 	lecc->interval = sys_cpu_to_le16(node_rx->interval);
 	lecc->latency = sys_cpu_to_le16(node_rx->latency);
 	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
@@ -4194,8 +4197,8 @@ static void le_ltk_request(struct pdu_da
 	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
 
 	sep->handle = sys_cpu_to_le16(handle);
-	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(uint64_t));
-	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(uint16_t));
+	(void) memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(uint64_t));
+	(void) memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(uint16_t));
 }
 
 static void encrypt_change(uint8_t err, uint16_t handle,
@@ -4231,9 +4234,9 @@ static void le_remote_feat_complete(uint
 	sep->status = status;
 	sep->handle = sys_cpu_to_le16(handle);
 	if (!status) {
-		memcpy(&sep->features[0],
-		       &pdu_data->llctrl.feature_rsp.features[0],
-		       sizeof(sep->features));
+		(void) memcpy(&sep->features[0],
+				&pdu_data->llctrl.feature_rsp.features[0],
+				sizeof(sep->features));
 	} else {
 		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 	}
@@ -4404,7 +4407,7 @@ void hci_acl_encode(struct node_rx_pdu *
 		acl->handle = sys_cpu_to_le16(handle_flags);
 		acl->len = sys_cpu_to_le16(pdu_data->len);
 		data = (void *)net_buf_add(buf, pdu_data->len);
-		memcpy(data, pdu_data->lldata, pdu_data->len);
+		(void) memcpy(data, pdu_data->lldata, pdu_data->len);
 #if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
 		if (hci_hbuf_total > 0) {
 			LL_ASSERT((hci_hbuf_sent - hci_hbuf_acked) <
diff -u -p a/subsys/disk/disk_access_ram.c b/subsys/disk/disk_access_ram.c
--- a/subsys/disk/disk_access_ram.c
+++ b/subsys/disk/disk_access_ram.c
@@ -48,7 +48,7 @@ static int disk_ram_access_init(struct d
 static int disk_ram_access_read(struct disk_info *disk, uint8_t *buff,
 				uint32_t sector, uint32_t count)
 {
-	memcpy(buff, lba_to_address(sector), count * RAMDISK_SECTOR_SIZE);
+	(void) memcpy(buff, lba_to_address(sector), count * RAMDISK_SECTOR_SIZE);
 
 	return 0;
 }
@@ -56,7 +56,7 @@ static int disk_ram_access_read(struct d
 static int disk_ram_access_write(struct disk_info *disk, const uint8_t *buff,
 				 uint32_t sector, uint32_t count)
 {
-	memcpy(lba_to_address(sector), buff, count * RAMDISK_SECTOR_SIZE);
+	(void) memcpy(lba_to_address(sector), buff, count * RAMDISK_SECTOR_SIZE);
 
 	return 0;
 }
diff -u -p a/subsys/fs/nvs/nvs.c b/subsys/fs/nvs/nvs.c
--- a/subsys/fs/nvs/nvs.c
+++ b/subsys/fs/nvs/nvs.c
@@ -66,7 +66,7 @@ static int nvs_flash_al_wrt(struct nvs_f
 		data8 += blen;
 	}
 	if (len) {
-		memcpy(buf, data8, len);
+		(void) memcpy(buf, data8, len);
 		(void)memset(buf + len, fs->flash_parameters->erase_value,
 			fs->flash_parameters->write_block_size - len);
 
diff -u -p a/tests/crypto/tinycrypt/src/ecc_dsa.c b/tests/crypto/tinycrypt/src/ecc_dsa.c
--- a/tests/crypto/tinycrypt/src/ecc_dsa.c
+++ b/tests/crypto/tinycrypt/src/ecc_dsa.c
@@ -620,7 +620,7 @@ int default_CSPRNG(uint8_t *dest, unsign
 		uint32_t len = size >= sizeof(uint32_t) ? sizeof(uint32_t) : size;
 		uint32_t rv = sys_rand32_get();
 
-		memcpy(dest, &rv, len);
+		(void) memcpy(dest, &rv, len);
 		dest += len;
 		size -= len;
 	}
diff -u -p a/tests/net/ieee802154/l2/src/ieee802154_fake_driver.c b/tests/net/ieee802154/l2/src/ieee802154_fake_driver.c
--- a/tests/net/ieee802154/l2/src/ieee802154_fake_driver.c
+++ b/tests/net/ieee802154/l2/src/ieee802154_fake_driver.c
@@ -53,7 +53,7 @@ static inline void insert_frag(struct ne
 		return;
 	}
 
-	memcpy(new_frag->data, frag->data, frag->len);
+	(void) memcpy(new_frag->data, frag->data, frag->len);
 	net_buf_add(new_frag, frag->len);
 
 	net_pkt_frag_add(current_pkt, new_frag);
diff -u -p a/tests/net/mgmt/src/mgmt.c b/tests/net/mgmt/src/mgmt.c
--- a/tests/net/mgmt/src/mgmt.c
+++ b/tests/net/mgmt/src/mgmt.c
@@ -241,7 +241,7 @@ static void initialize_event_tests(void)
 	k_sem_init(&thrower_lock, 0, UINT_MAX);
 
 	info_length_in_test = TEST_MGMT_EVENT_INFO_SIZE;
-	memcpy(info_data, info_string, strlen(info_string) + 1);
+	(void) memcpy(info_data, info_string, strlen(info_string) + 1);
 
 	net_mgmt_init_event_callback(&rx_cb, receiver_cb, TEST_MGMT_EVENT);
 
@@ -256,7 +256,7 @@ static int test_core_event(uint32_t even
 	TC_PRINT("- Triggering core event: 0x%08X\n", event);
 
 	info_length_in_test = sizeof(struct in6_addr);
-	memcpy(info_data, &addr6, sizeof(addr6));
+	(void) memcpy(info_data, &addr6, sizeof(addr6));
 
 	net_mgmt_init_event_callback(&rx_cb, receiver_cb, event);
 
diff -u -p a/tests/net/ptp/clock/src/main.c b/tests/net/ptp/clock/src/main.c
--- a/tests/net/ptp/clock/src/main.c
+++ b/tests/net/ptp/clock/src/main.c
@@ -191,7 +191,7 @@ static int my_ptp_clock_set(const struct
 		zassert_true(false, "Context pointers do not match\n");
 	}
 
-	memcpy(&eth_ctx->time, tm, sizeof(struct net_ptp_time));
+	(void) memcpy(&eth_ctx->time, tm, sizeof(struct net_ptp_time));
 
 	return 0;
 }
@@ -201,7 +201,7 @@ static int my_ptp_clock_get(const struct
 	struct ptp_context *ptp_ctx = dev->data;
 	struct eth_context *eth_ctx = ptp_ctx->eth_context;
 
-	memcpy(tm, &eth_ctx->time, sizeof(struct net_ptp_time));
+	(void) memcpy(tm, &eth_ctx->time, sizeof(struct net_ptp_time));
 
 	return 0;
 }
diff -u -p a/tests/net/6lo/src/main.c b/tests/net/6lo/src/main.c
--- a/tests/net/6lo/src/main.c
+++ b/tests/net/6lo/src/main.c
@@ -480,14 +480,14 @@ static struct net_pkt *create_pkt(struct
 	}
 
 	if (data->nh_udp) {
-		memcpy(frag->data, (uint8_t *) data, NET_IPV6UDPH_LEN);
+		(void) memcpy(frag->data, (uint8_t *) data, NET_IPV6UDPH_LEN);
 		net_buf_add(frag, NET_IPV6UDPH_LEN);
 	} else if (data->nh_icmp) {
-		memcpy(frag->data, (uint8_t *) data, NET_IPV6ICMPH_LEN);
+		(void) memcpy(frag->data, (uint8_t *) data, NET_IPV6ICMPH_LEN);
 		net_buf_add(frag, NET_IPV6ICMPH_LEN);
 
 	} else {
-		memcpy(frag->data, (uint8_t *) data, NET_IPV6H_LEN);
+		(void) memcpy(frag->data, (uint8_t *) data, NET_IPV6H_LEN);
 		net_buf_add(frag, NET_IPV6H_LEN);
 	}
 
@@ -522,7 +522,7 @@ static struct net_pkt *create_pkt(struct
 
 		bytes = net_buf_tailroom(frag);
 		copy = remaining > bytes ? bytes : remaining;
-		memcpy(net_buf_add(frag, copy), &user_data[pos], copy);
+		(void) memcpy(net_buf_add(frag, copy), &user_data[pos], copy);
 
 		pos += copy;
 		remaining -= copy;
diff -u -p a/tests/net/lib/dns_packet/src/main.c b/tests/net/lib/dns_packet/src/main.c
--- a/tests/net/lib/dns_packet/src/main.c
+++ b/tests/net/lib/dns_packet/src/main.c
@@ -471,14 +471,14 @@ void test_dns_response(void)
 	struct dns_response_test test1, test2;
 	int rc;
 
-	memcpy(&test1, &test, sizeof(test1));
+	(void) memcpy(&test1, &test, sizeof(test1));
 	rc = eval_response1(&test1, false);
 	zassert_equal(rc, 0,
 		      "Response test failed for domain: " DNAME1
 		      " at line %d", -rc);
 
 	/* Test also using dns_unpack_answer() API */
-	memcpy(&test2, &test, sizeof(test2));
+	(void) memcpy(&test2, &test, sizeof(test2));
 	rc = eval_response1(&test2, true);
 	zassert_equal(rc, 0,
 		      "Response test 2 failed for domain: " DNAME1
diff -u -p a/tests/net/arp/src/main.c b/tests/net/arp/src/main.c
--- a/tests/net/arp/src/main.c
+++ b/tests/net/arp/src/main.c
@@ -188,8 +188,8 @@ static inline struct net_pkt *prepare_ar
 	net_buf_pull(pkt->buffer, sizeof(struct net_eth_hdr));
 
 	(void)memset(&eth->dst.addr, 0xff, sizeof(struct net_eth_addr));
-	memcpy(&eth->src.addr, net_if_get_link_addr(iface)->addr,
-	       sizeof(struct net_eth_addr));
+	(void) memcpy(&eth->src.addr, net_if_get_link_addr(iface)->addr,
+			sizeof(struct net_eth_addr));
 	eth->type = htons(NET_ETH_PTYPE_ARP);
 
 	*eth_rep = eth;
@@ -205,10 +205,10 @@ static inline struct net_pkt *prepare_ar
 	hdr->protolen = sizeof(struct in_addr);
 	hdr->opcode = htons(NET_ARP_REPLY);
 
-	memcpy(&hdr->dst_hwaddr.addr, &eth->src.addr,
-	       sizeof(struct net_eth_addr));
-	memcpy(&hdr->src_hwaddr.addr, addr,
-	       sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->dst_hwaddr.addr, &eth->src.addr,
+			sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->src_hwaddr.addr, addr,
+			sizeof(struct net_eth_addr));
 
 	net_ipaddr_copy(&hdr->dst_ipaddr, &NET_ARP_HDR(req)->src_ipaddr);
 	net_ipaddr_copy(&hdr->src_ipaddr, &NET_ARP_HDR(req)->dst_ipaddr);
@@ -241,7 +241,7 @@ static inline struct net_pkt *prepare_ar
 	req_hdr = NET_ARP_HDR(req);
 
 	(void)memset(&eth->dst.addr, 0xff, sizeof(struct net_eth_addr));
-	memcpy(&eth->src.addr, addr, sizeof(struct net_eth_addr));
+	(void) memcpy(&eth->src.addr, addr, sizeof(struct net_eth_addr));
 
 	eth->type = htons(NET_ETH_PTYPE_ARP);
 	*eth_hdr = eth;
@@ -258,7 +258,7 @@ static inline struct net_pkt *prepare_ar
 	hdr->opcode = htons(NET_ARP_REQUEST);
 
 	(void)memset(&hdr->dst_hwaddr.addr, 0x00, sizeof(struct net_eth_addr));
-	memcpy(&hdr->src_hwaddr.addr, addr, sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->src_hwaddr.addr, addr, sizeof(struct net_eth_addr));
 
 	net_ipaddr_copy(&hdr->src_ipaddr, &req_hdr->src_ipaddr);
 	net_ipaddr_copy(&hdr->dst_ipaddr, &req_hdr->dst_ipaddr);
@@ -273,9 +273,9 @@ static void setup_eth_header(struct net_
 {
 	struct net_eth_hdr *hdr = (struct net_eth_hdr *)net_pkt_data(pkt);
 
-	memcpy(&hdr->dst.addr, hwaddr, sizeof(struct net_eth_addr));
-	memcpy(&hdr->src.addr, net_if_get_link_addr(iface)->addr,
-	       sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->dst.addr, hwaddr, sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr->src.addr, net_if_get_link_addr(iface)->addr,
+			sizeof(struct net_eth_addr));
 
 	hdr->type = htons(type);
 }
@@ -367,7 +367,7 @@ void test_arp(void)
 	net_ipaddr_copy(&ipv4->src, &src);
 	net_ipaddr_copy(&ipv4->dst, &dst);
 
-	memcpy(net_buf_add(pkt->buffer, len), app_data, len);
+	(void) memcpy(net_buf_add(pkt->buffer, len), app_data, len);
 
 	pkt2 = net_arp_prepare(pkt, &NET_IPV4_HDR(pkt)->dst, NULL);
 
@@ -620,8 +620,8 @@ void test_arp(void)
 		arp_hdr->hwlen = sizeof(struct net_eth_addr);
 		arp_hdr->protolen = sizeof(struct in_addr);
 		arp_hdr->opcode = htons(NET_ARP_REQUEST);
-		memcpy(&arp_hdr->src_hwaddr, &new_hwaddr, 6);
-		memcpy(&arp_hdr->dst_hwaddr, net_eth_broadcast_addr(), 6);
+		(void) memcpy(&arp_hdr->src_hwaddr, &new_hwaddr, 6);
+		(void) memcpy(&arp_hdr->dst_hwaddr, net_eth_broadcast_addr(), 6);
 		net_ipaddr_copy(&arp_hdr->dst_ipaddr, &dst);
 		net_ipaddr_copy(&arp_hdr->src_ipaddr, &dst);
 
diff -u -p a/tests/net/socket/net_mgmt/src/main.c b/tests/net/socket/net_mgmt/src/main.c
--- a/tests/net/socket/net_mgmt/src/main.c
+++ b/tests/net/socket/net_mgmt/src/main.c
@@ -243,7 +243,7 @@ static int eth_fake_init(const struct de
 	ctx->link_10bt = true;
 	ctx->link_100bt = false;
 
-	memcpy(ctx->mac_address, mac_addr_init, 6);
+	(void) memcpy(ctx->mac_address, mac_addr_init, 6);
 
 	/* Initialize priority queues */
 	for (i = 0; i < ARRAY_SIZE(ctx->priority_queues); ++i) {
@@ -360,7 +360,7 @@ static void test_net_mgmt_setup(void)
 	k_object_access_all_grant(ctx);
 #endif /* CONFIG_USERSPACE */
 
-	memset(&sockaddr, 0, sizeof(sockaddr));
+	(void) memset(&sockaddr, 0, sizeof(sockaddr));
 
 	sockaddr.nm_family = AF_NET_MGMT;
 	sockaddr.nm_ifindex = net_if_get_by_iface(net_if_get_default());
@@ -387,7 +387,7 @@ static void test_net_mgmt_catch_events(v
 	while (event_count > 0) {
 		struct net_mgmt_msghdr *hdr;
 
-		memset(buf, 0, sizeof(buf));
+		(void) memset(buf, 0, sizeof(buf));
 		event_addr_len = sizeof(event_addr);
 
 		ret = recvfrom(fd, buf, sizeof(buf), 0,
@@ -451,7 +451,7 @@ static void test_ethernet_set_qav(void)
 	struct ethernet_req_params params;
 	int ret;
 
-	memset(&params, 0, sizeof(params));
+	(void) memset(&params, 0, sizeof(params));
 
 	params.qav_param.queue_id = 1;
 	params.qav_param.type = ETHERNET_QAV_PARAM_TYPE_STATUS;
@@ -479,7 +479,7 @@ static void test_ethernet_get_qav(void)
 	socklen_t optlen = sizeof(params);
 	int ret;
 
-	memset(&params, 0, sizeof(params));
+	(void) memset(&params, 0, sizeof(params));
 
 	params.qav_param.queue_id = 1;
 	params.qav_param.type = ETHERNET_QAV_PARAM_TYPE_STATUS;
@@ -509,7 +509,7 @@ static void test_ethernet_get_unknown_op
 	socklen_t optlen = sizeof(params);
 	int ret;
 
-	memset(&params, 0, sizeof(params));
+	(void) memset(&params, 0, sizeof(params));
 
 	ret = getsockopt(fd, SOL_NET_MGMT_RAW,
 			 NET_REQUEST_ETHERNET_GET_PRIORITY_QUEUES_NUM,
@@ -534,7 +534,7 @@ static void test_ethernet_set_unknown_op
 	socklen_t optlen = sizeof(params);
 	int ret;
 
-	memset(&params, 0, sizeof(params));
+	(void) memset(&params, 0, sizeof(params));
 
 	ret = setsockopt(fd, SOL_NET_MGMT_RAW,
 			 NET_REQUEST_ETHERNET_SET_MAC_ADDRESS,
diff -u -p a/tests/net/socket/socketpair/src/test_socketpair_poll.c b/tests/net/socket/socketpair/src/test_socketpair_poll.c
--- a/tests/net/socket/socketpair/src/test_socketpair_poll.c
+++ b/tests/net/socket/socketpair/src/test_socketpair_poll.c
@@ -45,7 +45,7 @@ static void test_socketpair_poll_timeout
 
 	struct pollfd fds[1];
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLIN;
 	res = poll(fds, 1, 1);
@@ -56,7 +56,7 @@ static void test_socketpair_poll_timeout
 		zassert_equal(res, 1, "write failed: %d", res);
 	}
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLOUT;
 	res = poll(fds, 1, 1);
@@ -134,11 +134,11 @@ void test_socketpair_poll_close_remote_e
 	 * But rather than writing, close the other end of the channel
 	 */
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLIN;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 	ctx.fd = sv[1];
 	ctx.delay = K_MSEC(1000);
 
@@ -177,11 +177,11 @@ void test_socketpair_poll_close_remote_e
 		zassert_equal(res, 1, "write failed: %d", res);
 	}
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLOUT;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 	ctx.fd = sv[1];
 	ctx.delay = K_MSEC(1000);
 
@@ -218,7 +218,7 @@ void test_socketpair_poll_immediate_data
 	res = socketpair(AF_UNIX, SOCK_STREAM, 0, sv);
 	zassert_not_equal(res, -1, "socketpair(2) failed: %d", errno);
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLOUT;
 	res = poll(fds, 1, 0);
@@ -230,7 +230,7 @@ void test_socketpair_poll_immediate_data
 	zassert_not_equal(res, -1, "write(2) failed: %d", errno);
 	zassert_equal(res, 1, "write(2): expected: 1 actual: %d", res);
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[1];
 	fds[0].events |= POLLIN;
 	res = poll(fds, 1, 0);
@@ -238,7 +238,7 @@ void test_socketpair_poll_immediate_data
 	zassert_equal(res, 1, "poll(2): expected: 1 actual: %d", res);
 	zassert_not_equal(fds[0].revents & POLLIN, 0, "POLLIN not set");
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLOUT;
 	fds[1].fd = sv[1];
@@ -299,11 +299,11 @@ void test_socketpair_poll_delayed_data(v
 	res = socketpair(AF_UNIX, SOCK_STREAM, 0, sv);
 	zassert_not_equal(res, -1, "socketpair(2) failed: %d", errno);
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLIN;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 	ctx.fd = sv[1];
 	ctx.should_write = true;
 	ctx.delay = K_MSEC(100);
@@ -323,11 +323,11 @@ void test_socketpair_poll_delayed_data(v
 		zassert_equal(res, 1, "write failed: %d", res);
 	}
 
-	memset(fds, 0, sizeof(fds));
+	(void) memset(fds, 0, sizeof(fds));
 	fds[0].fd = sv[0];
 	fds[0].events |= POLLOUT;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 	ctx.fd = sv[1];
 	ctx.should_write = false;
 	ctx.delay = K_MSEC(100);
diff -u -p a/tests/net/socket/getnameinfo/src/main.c b/tests/net/socket/getnameinfo/src/main.c
--- a/tests/net/socket/getnameinfo/src/main.c
+++ b/tests/net/socket/getnameinfo/src/main.c
@@ -19,7 +19,7 @@ void test_getnameinfo_ipv4(void)
 	char serv[10];
 	int ret;
 
-	memset(&saddr, 0, sizeof(saddr));
+	(void) memset(&saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
 
 	ret = getnameinfo((struct sockaddr *)&saddr, sizeof(saddr),
@@ -49,7 +49,7 @@ void test_getnameinfo_ipv6(void)
 	char serv[10];
 	int ret;
 
-	memset(&saddr, 0, sizeof(saddr));
+	(void) memset(&saddr, 0, sizeof(saddr));
 	saddr.sin6_family = AF_INET6;
 
 	ret = getnameinfo((struct sockaddr *)&saddr, sizeof(saddr),
diff -u -p a/tests/drivers/hwinfo/api/src/main.c b/tests/drivers/hwinfo/api/src/main.c
--- a/tests/drivers/hwinfo/api/src/main.c
+++ b/tests/drivers/hwinfo/api/src/main.c
@@ -41,13 +41,13 @@ static void test_device_id_get(void)
 	zassert_not_equal(length_read_1, 0, "Zero bytes read");
 	zassert_equal(length_read_1, 1, "Length not adhered");
 
-	memset(buffer_1, BUFFER_CANARY, sizeof(buffer_1));
+	(void) memset(buffer_1, BUFFER_CANARY, sizeof(buffer_1));
 
 	length_read_1 = hwinfo_get_device_id(buffer_1, BUFFER_LENGTH - 1);
 	zassert_equal(buffer_1[length_read_1], BUFFER_CANARY,
 		      "Too many bytes are written");
 
-	memcpy(buffer_2, buffer_1, length_read_1);
+	(void) memcpy(buffer_2, buffer_1, length_read_1);
 
 	for (i = 0; i < BUFFER_LENGTH; i++) {
 		buffer_1[i] ^= 0xA5;
diff -u -p a/tests/drivers/dma/chan_blen_transfer/src/test_dma.c b/tests/drivers/dma/chan_blen_transfer/src/test_dma.c
--- a/tests/drivers/dma/chan_blen_transfer/src/test_dma.c
+++ b/tests/drivers/dma/chan_blen_transfer/src/test_dma.c
@@ -56,7 +56,7 @@ static int test_task(uint32_t chan_id, u
 	}
 
 #ifdef CONFIG_NOCACHE_MEMORY
-	memcpy(tx_data, TX_DATA, sizeof(TX_DATA));
+	(void) memcpy(tx_data, TX_DATA, sizeof(TX_DATA));
 #endif
 
 	dma_cfg.channel_direction = MEMORY_TO_MEMORY;
diff -u -p a/tests/subsys/settings/fcb/src/settings_test_compress_reset.c b/tests/subsys/settings/fcb/src/settings_test_compress_reset.c
--- a/tests/subsys/settings/fcb/src/settings_test_compress_reset.c
+++ b/tests/subsys/settings/fcb/src/settings_test_compress_reset.c
@@ -35,7 +35,7 @@ void test_config_compress_reset(void)
 
 	for (i = 0; ; i++) {
 		test_config_fill_area(test_ref_value, i);
-		memcpy(val_string, test_ref_value, sizeof(val_string));
+		(void) memcpy(val_string, test_ref_value, sizeof(val_string));
 
 		rc = settings_save();
 		zassert_true(rc == 0, "fcb write error");
diff -u -p a/tests/subsys/settings/src/settings_test_getset_int64.c b/tests/subsys/settings/src/settings_test_getset_int64.c
--- a/tests/subsys/settings/src/settings_test_getset_int64.c
+++ b/tests/subsys/settings/src/settings_test_getset_int64.c
@@ -27,7 +27,7 @@ void test_config_getset_int64(void)
 	rc = settings_runtime_get(name, tmp, sizeof(tmp));
 	zassert_equal(rc, sizeof(int64_t), "the key value should been available");
 	zassert_true(test_get_called == 1, "the GET handler wasn't called");
-	memcpy(&new_val64, tmp, sizeof(int64_t));
+	(void) memcpy(&new_val64, tmp, sizeof(int64_t));
 	zassert_equal(new_val64, 0x8012345678901234,
 		      "unexpected value fetched %d", tmp);
 	ctest_clear_call_state();
@@ -45,7 +45,7 @@ void test_config_getset_int64(void)
 	rc = settings_runtime_get(name, tmp, sizeof(tmp));
 	zassert_equal(rc, sizeof(int64_t), "the key value should been available");
 	zassert_true(test_get_called == 1, "the GET handler wasn't called");
-	memcpy(&new_val64, tmp, sizeof(int64_t));
+	(void) memcpy(&new_val64, tmp, sizeof(int64_t));
 	zassert_equal(new_val64, 1,
 		      "unexpected value fetched %d", tmp);
 	ctest_clear_call_state();
diff -u -p a/tests/subsys/usb/bos/src/test_bos.c b/tests/subsys/usb/bos/src/test_bos.c
--- a/tests/subsys/usb/bos/src/test_bos.c
+++ b/tests/subsys/usb/bos/src/test_bos.c
@@ -220,23 +220,23 @@ static void test_usb_bos(void)
 void test_main(void)
 {
 	/* Prepare webusb_bos_descriptor_2 */
-	memcpy(&webusb_bos_descriptor_2.bos,
-	       &webusb_bos_descriptor.bos,
-	       sizeof(struct usb_bos_descriptor));
+	(void) memcpy(&webusb_bos_descriptor_2.bos,
+			&webusb_bos_descriptor.bos,
+			sizeof(struct usb_bos_descriptor));
 
-	memcpy(&webusb_bos_descriptor_2.platform_msos,
-	       &webusb_bos_descriptor.platform_msos,
-	       sizeof(struct usb_bos_platform_descriptor));
-	memcpy(&webusb_bos_descriptor_2.capability_data_msos,
-	       &webusb_bos_descriptor.capability_data_msos,
-	       sizeof(struct usb_bos_capability_msos));
+	(void) memcpy(&webusb_bos_descriptor_2.platform_msos,
+			&webusb_bos_descriptor.platform_msos,
+			sizeof(struct usb_bos_platform_descriptor));
+	(void) memcpy(&webusb_bos_descriptor_2.capability_data_msos,
+			&webusb_bos_descriptor.capability_data_msos,
+			sizeof(struct usb_bos_capability_msos));
 
-	memcpy(&webusb_bos_descriptor_2.platform_webusb,
-	       &webusb_bos_descriptor.platform_webusb,
-	       sizeof(struct usb_bos_platform_descriptor));
-	memcpy(&webusb_bos_descriptor_2.capability_data_webusb,
-	       &webusb_bos_descriptor.capability_data_webusb,
-	       sizeof(struct usb_bos_capability_webusb));
+	(void) memcpy(&webusb_bos_descriptor_2.platform_webusb,
+			&webusb_bos_descriptor.platform_webusb,
+			sizeof(struct usb_bos_platform_descriptor));
+	(void) memcpy(&webusb_bos_descriptor_2.capability_data_webusb,
+			&webusb_bos_descriptor.capability_data_webusb,
+			sizeof(struct usb_bos_capability_webusb));
 
 	ztest_test_suite(test_osdesc,
 			 ztest_unit_test(test_usb_bos_macros),
diff -u -p a/tests/subsys/fs/littlefs/src/test_util.c b/tests/subsys/fs/littlefs/src/test_util.c
--- a/tests/subsys/fs/littlefs/src/test_util.c
+++ b/tests/subsys/fs/littlefs/src/test_util.c
@@ -60,7 +60,7 @@ void test_util_path_init_overrun(void)
 	zassert_true(path_max < overrun_max,
 		     "path length requirements unmet");
 
-	memset(overrun + 1, 'A', overrun_max - 1);
+	(void) memset(overrun + 1, 'A', overrun_max - 1);
 
 	zassert_equal(testfs_path_init(&path, &overrun_mnt, TESTFS_PATH_END),
 		      path.path,
@@ -147,7 +147,7 @@ void test_util_path_extend_overrun(void)
 {
 	char long_elt[TESTFS_PATH_MAX];
 
-	memset(long_elt, 'a', sizeof(long_elt) - 1);
+	(void) memset(long_elt, 'a', sizeof(long_elt) - 1);
 	long_elt[sizeof(long_elt) - 1] = '\0';
 
 	zassert_equal(strcmp(testfs_path_extend(reset_path(),
diff -u -p a/tests/subsys/fs/multi-fs/src/test_ram_backend.c b/tests/subsys/fs/multi-fs/src/test_ram_backend.c
--- a/tests/subsys/fs/multi-fs/src/test_ram_backend.c
+++ b/tests/subsys/fs/multi-fs/src/test_ram_backend.c
@@ -51,7 +51,7 @@ static int test_flash_ram_write(const st
 	zassert_true(offset + len <= FLASH_AREA_SIZE(storage),
 		     "flash address out of bounds");
 
-	memcpy(rambuf + offset, data, len);
+	(void) memcpy(rambuf + offset, data, len);
 
 	return 0;
 }
@@ -64,7 +64,7 @@ static int test_flash_ram_read(const str
 	zassert_true(offset + len <= FLASH_AREA_SIZE(storage),
 		     "flash address out of bounds");
 
-	memcpy(data, rambuf + offset, len);
+	(void) memcpy(data, rambuf + offset, len);
 
 	return 0;
 }
diff -u -p a/tests/subsys/logging/log_core/src/log_core_test.c b/tests/subsys/logging/log_core/src/log_core_test.c
--- a/tests/subsys/logging/log_core/src/log_core_test.c
+++ b/tests/subsys/logging/log_core/src/log_core_test.c
@@ -158,12 +158,12 @@ static void log_setup(bool backend2_enab
 	zassert_equal(0, log_set_timestamp_func(timestamp_get, 0),
 		      "Expects successful timestamp function setting.");
 
-	memset(&backend1_cb, 0, sizeof(backend1_cb));
+	(void) memset(&backend1_cb, 0, sizeof(backend1_cb));
 
 	log_backend_enable(&backend1, &backend1_cb, LOG_LEVEL_DBG);
 
 	if (backend2_enable) {
-		memset(&backend2_cb, 0, sizeof(backend2_cb));
+		(void) memset(&backend2_cb, 0, sizeof(backend2_cb));
 
 		log_backend_enable(&backend2, &backend2_cb, LOG_LEVEL_DBG);
 	} else {
diff -u -p a/tests/bluetooth/gatt/src/main.c b/tests/bluetooth/gatt/src/main.c
--- a/tests/bluetooth/gatt/src/main.c
+++ b/tests/bluetooth/gatt/src/main.c
@@ -58,7 +58,7 @@ static ssize_t write_test(struct bt_conn
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/tester/src/mesh.c b/tests/bluetooth/tester/src/mesh.c
--- a/tests/bluetooth/tester/src/mesh.c
+++ b/tests/bluetooth/tester/src/mesh.c
@@ -390,8 +390,8 @@ static void config_prov(uint8_t *data, u
 
 	LOG_DBG("");
 
-	memcpy(dev_uuid, cmd->uuid, sizeof(dev_uuid));
-	memcpy(static_auth, cmd->static_auth, sizeof(static_auth));
+	(void) memcpy(dev_uuid, cmd->uuid, sizeof(dev_uuid));
+	(void) memcpy(static_auth, cmd->static_auth, sizeof(static_auth));
 
 	prov.output_size = cmd->out_size;
 	prov.output_actions = sys_le16_to_cpu(cmd->out_actions);
@@ -408,8 +408,8 @@ static void provision_node(uint8_t *data
 
 	LOG_DBG("");
 
-	memcpy(dev_key, cmd->dev_key, sizeof(dev_key));
-	memcpy(net_key, cmd->net_key, sizeof(net_key));
+	(void) memcpy(dev_key, cmd->dev_key, sizeof(dev_key));
+	(void) memcpy(net_key, cmd->net_key, sizeof(net_key));
 
 	addr = sys_le16_to_cpu(cmd->addr);
 	flags = cmd->flags;
@@ -613,12 +613,12 @@ static void health_generate_faults(uint8
 	rp = net_buf_simple_add(&buf, sizeof(*rp));
 
 	cur_faults_count = MIN(sizeof(cur_faults), sizeof(some_faults));
-	memcpy(cur_faults, some_faults, cur_faults_count);
+	(void) memcpy(cur_faults, some_faults, cur_faults_count);
 	net_buf_simple_add_mem(&buf, cur_faults, cur_faults_count);
 	rp->cur_faults_count = cur_faults_count;
 
 	reg_faults_count = MIN(sizeof(reg_faults), sizeof(some_faults));
-	memcpy(reg_faults, some_faults, reg_faults_count);
+	(void) memcpy(reg_faults, some_faults, reg_faults_count);
 	net_buf_simple_add_mem(&buf, reg_faults, reg_faults_count);
 	rp->reg_faults_count = reg_faults_count;
 
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_2.c
@@ -77,7 +77,7 @@ static ssize_t write_value_v6(struct bt_
 	if (offset + len > sizeof(value_v6_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_1.c
@@ -100,7 +100,7 @@ static ssize_t write_value_v4(struct bt_
 	if (offset + len > sizeof(value_v4_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -152,7 +152,7 @@ static ssize_t write_value_v4_1(struct b
 	if (offset + len > sizeof(value_v4_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -209,7 +209,7 @@ static ssize_t write_server_cha_con(stru
 	if (offset + len > sizeof(server_cha_con_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy((uint8_t *)&server_cha_con_conv + offset, buf, len);
+	(void) memcpy((uint8_t *)&server_cha_con_conv + offset, buf, len);
 
 	*value = sys_le16_to_cpu(server_cha_con_conv);
 
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_1.c
@@ -75,7 +75,7 @@ static ssize_t write_value_v6(struct bt_
 	if (offset + len > sizeof(value_v6_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_3.c
@@ -133,7 +133,7 @@ static ssize_t write_value_v2(struct bt_
 	if (offset + len > sizeof(value_v2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -163,7 +163,7 @@ static ssize_t write_value_v2_1(struct b
 	if (offset + len > sizeof(value_v2_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -193,7 +193,7 @@ static ssize_t write_value_v2_2(struct b
 	if (offset + len > sizeof(value_v2_2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -223,7 +223,7 @@ static ssize_t write_value_v2_3(struct b
 	if (offset + len > sizeof(value_v2_3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -253,7 +253,7 @@ static ssize_t write_value_v2_4(struct b
 	if (offset + len > sizeof(value_v2_4_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -283,7 +283,7 @@ static ssize_t write_value_v2_5(struct b
 	if (offset + len > sizeof(value_v2_5_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_3.c
@@ -91,7 +91,7 @@ static ssize_t write_value_v5(struct bt_
 	if (offset + len > sizeof(value_v5_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/bsim_test_app/src/test_connect1.c b/tests/bluetooth/bsim_bt/bsim_test_app/src/test_connect1.c
--- a/tests/bluetooth/bsim_bt/bsim_test_app/src/test_connect1.c
+++ b/tests/bluetooth/bsim_bt/bsim_test_app/src/test_connect1.c
@@ -136,14 +136,14 @@ static uint8_t discover_func(struct bt_c
 
 	if (!attr) {
 		printk("Discover complete\n");
-		memset(params, 0, sizeof(*params));
+		(void) memset(params, 0, sizeof(*params));
 		return BT_GATT_ITER_STOP;
 	}
 
 	printk("[ATTRIBUTE] handle %u\n", attr->handle);
 
 	if (!bt_uuid_cmp(discover_params.uuid, BT_UUID_HRS)) {
-		memcpy(&uuid, BT_UUID_HRS_MEASUREMENT, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_HRS_MEASUREMENT, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.start_handle = attr->handle + 1;
 		discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
@@ -154,7 +154,7 @@ static uint8_t discover_func(struct bt_c
 		}
 	} else if (!bt_uuid_cmp(discover_params.uuid,
 			BT_UUID_HRS_MEASUREMENT)) {
-		memcpy(&uuid, BT_UUID_GATT_CCC, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_GATT_CCC, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.start_handle = attr->handle + 2;
 		discover_params.type = BT_GATT_DISCOVER_DESCRIPTOR;
@@ -260,7 +260,7 @@ static void params_updated(struct bt_con
 		return;
 	}
 
-	memcpy(&uuid, BT_UUID_HRS, sizeof(uuid));
+	(void) memcpy(&uuid, BT_UUID_HRS, sizeof(uuid));
 	discover_params.uuid = &uuid.uuid;
 	discover_params.func = discover_func;
 	discover_params.start_handle = 0x0001;
@@ -295,7 +295,7 @@ static bool eir_found(struct bt_data *da
 			uint16_t u16;
 			int err;
 
-			memcpy(&u16, &data->data[i], sizeof(u16));
+			(void) memcpy(&u16, &data->data[i], sizeof(u16));
 			uuid = BT_UUID_DECLARE_16(sys_le16_to_cpu(u16));
 			if (bt_uuid_cmp(uuid, BT_UUID_HRS)) {
 				continue;
diff -u -p a/tests/lib/ringbuffer/src/main.c b/tests/lib/ringbuffer/src/main.c
--- a/tests/lib/ringbuffer/src/main.c
+++ b/tests/lib/ringbuffer/src/main.c
@@ -271,7 +271,7 @@ void test_ringbuffer_raw(void)
 	}
 
 	for (i = 0; i < 10; i++) {
-		memset(outbuf, 0, sizeof(outbuf));
+		(void) memset(outbuf, 0, sizeof(outbuf));
 		in_size = ring_buf_put(&ringbuf_raw, inbuf,
 					       RINGBUFFER_SIZE - 2);
 		out_size = ring_buf_get(&ringbuf_raw, outbuf,
@@ -283,7 +283,7 @@ void test_ringbuffer_raw(void)
 			     NULL);
 	}
 
-	memset(outbuf, 0, sizeof(outbuf));
+	(void) memset(outbuf, 0, sizeof(outbuf));
 	in_size = ring_buf_put(&ringbuf_raw, inbuf,
 				       RINGBUFFER_SIZE);
 	zassert_equal(in_size, RINGBUFFER_SIZE - 1, NULL);
diff -u -p a/tests/lib/cmsis_dsp/support/src/f32.c b/tests/lib/cmsis_dsp/support/src/f32.c
--- a/tests/lib/cmsis_dsp/support/src/f32.c
+++ b/tests/lib/cmsis_dsp/support/src/f32.c
@@ -275,7 +275,7 @@ static void test_arm_sort_in(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Copy input to the output buffer */
-	memcpy(output, input1, length * sizeof(float32_t));
+	(void) memcpy(output, input1, length * sizeof(float32_t));
 
 	/* Initialise sorter */
 	arm_sort_init_f32(&inst, alg, dir);
diff -u -p a/tests/lib/cmsis_dsp/transform/src/cf64.c b/tests/lib/cmsis_dsp/transform/src/cf64.c
--- a/tests/lib/cmsis_dsp/transform/src/cf64.c
+++ b/tests/lib/cmsis_dsp/transform/src/cf64.c
@@ -27,7 +27,7 @@ static void test_arm_cfft_f64_cmplx_back
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(output, input, length * sizeof(float64_t));
+	(void) memcpy(output, input, length * sizeof(float64_t));
 
 	/* Run test function */
 	arm_cfft_f64(inst, output, inverse, true);
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/unary_q15.c b/tests/lib/cmsis_dsp/matrix/src/unary_q15.c
--- a/tests/lib/cmsis_dsp/matrix/src/unary_q15.c
+++ b/tests/lib/cmsis_dsp/matrix/src/unary_q15.c
@@ -61,8 +61,8 @@ static void test_op2(int op, const q15_t
 		mat_in1.numCols = mat_in2.numCols = mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q15_t));
-		memcpy(mat_in2.pData, in_com2, rows * columns * sizeof(q15_t));
+		(void) memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q15_t));
+		(void) memcpy(mat_in2.pData, in_com2, rows * columns * sizeof(q15_t));
 
 		/* Run test function */
 		switch (op) {
@@ -133,7 +133,7 @@ static void test_op1(int op, const q15_t
 		mat_out.numCols = transpose ? rows : columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q15_t));
+		(void) memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q15_t));
 
 		/* Run test function */
 		switch (op) {
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/unary_q31.c b/tests/lib/cmsis_dsp/matrix/src/unary_q31.c
--- a/tests/lib/cmsis_dsp/matrix/src/unary_q31.c
+++ b/tests/lib/cmsis_dsp/matrix/src/unary_q31.c
@@ -61,8 +61,8 @@ static void test_op2(int op, const q31_t
 		mat_in1.numCols = mat_in2.numCols = mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q31_t));
-		memcpy(mat_in2.pData, in_com2, rows * columns * sizeof(q31_t));
+		(void) memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q31_t));
+		(void) memcpy(mat_in2.pData, in_com2, rows * columns * sizeof(q31_t));
 
 		/* Run test function */
 		switch (op) {
@@ -133,7 +133,7 @@ static void test_op1(int op, const q31_t
 		mat_out.numCols = transpose ? rows : columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q31_t));
+		(void) memcpy(mat_in1.pData, in_com1, rows * columns * sizeof(q31_t));
 
 		/* Run test function */
 		switch (op) {
diff -u -p a/tests/lib/c_lib/src/main.c b/tests/lib/c_lib/src/main.c
--- a/tests/lib/c_lib/src/main.c
+++ b/tests/lib/c_lib/src/main.c
@@ -186,7 +186,7 @@ void test_strncmp(void)
 
 	/* Note we don't want to count the final \0 that sizeof will */
 	__ASSERT_NO_MSG(sizeof(pattern) - 1 > BUFSIZE);
-	memcpy(buffer, pattern, BUFSIZE);
+	(void) memcpy(buffer, pattern, BUFSIZE);
 
 	zassert_true((strncmp(buffer, "fffff", 0) == 0), "strncmp 0");
 	zassert_true((strncmp(buffer, "eeeff", 3) == 0), "strncmp 3");
diff -u -p a/tests/kernel/mem_protect/userspace/src/main.c b/tests/kernel/mem_protect/userspace/src/main.c
--- a/tests/kernel/mem_protect/userspace/src/main.c
+++ b/tests/kernel/mem_protect/userspace/src/main.c
@@ -266,7 +266,7 @@ static void test_write_kerntext(void)
 	expect_fault = true;
 	expected_reason = K_ERR_CPU_EXCEPTION;
 	BARRIER();
-	memset(&z_is_thread_essential, 0, 4);
+	(void) memset(&z_is_thread_essential, 0, 4);
 	zassert_unreachable("Write to kernel text did not fault");
 }
 
@@ -981,8 +981,8 @@ void test_tls_leakage(void)
 	 * supervisor mode to be leaked
 	 */
 
-	memset(_current->userspace_local_data, 0xff,
-	       sizeof(struct _thread_userspace_local_data));
+	(void) memset(_current->userspace_local_data, 0xff,
+			sizeof(struct _thread_userspace_local_data));
 
 	k_thread_user_mode_enter(tls_leakage_user_part,
 				 _current->userspace_local_data, NULL, NULL);
diff -u -p a/tests/kernel/mbox/mbox_api/src/test_mbox_api.c b/tests/kernel/mbox/mbox_api/src/test_mbox_api.c
--- a/tests/kernel/mbox/mbox_api/src/test_mbox_api.c
+++ b/tests/kernel/mbox/mbox_api/src/test_mbox_api.c
@@ -154,7 +154,7 @@ static void tmbox_put(struct k_mbox *pmb
 		mmsg.tx_data = NULL;
 		zassert_equal(k_mem_pool_alloc(&mpooltx, &mmsg.tx_block,
 					       MAIL_LEN, K_NO_WAIT), 0, NULL);
-		memcpy(mmsg.tx_block.data, data[info_type], MAIL_LEN);
+		(void) memcpy(mmsg.tx_block.data, data[info_type], MAIL_LEN);
 		if (info_type == TARGET_SOURCE_THREAD_BLOCK) {
 			mmsg.tx_target_thread = receiver_tid;
 		} else {
@@ -224,7 +224,7 @@ static void tmbox_put(struct k_mbox *pmb
 		mmsg.tx_data = NULL;
 		zassert_equal(k_mem_pool_alloc(&mpooltx, &mmsg.tx_block,
 					       MAIL_LEN, K_NO_WAIT), 0, NULL);
-		memcpy(mmsg.tx_block.data, data[0], MAIL_LEN);
+		(void) memcpy(mmsg.tx_block.data, data[0], MAIL_LEN);
 		mmsg.tx_target_thread = K_ANY;
 		zassert_true(k_mbox_put(pmbox, &mmsg, K_FOREVER) == 0, NULL);
 		break;
diff -u -p a/samples/net/sockets/socketpair/src/socketpair_example.c b/samples/net/sockets/socketpair/src/socketpair_example.c
--- a/samples/net/sockets/socketpair/src/socketpair_example.c
+++ b/samples/net/sockets/socketpair/src/socketpair_example.c
@@ -188,7 +188,7 @@ int main(int argc, char *argv[])
 
 			if ((fds[i].revents & POLLIN) != 0) {
 
-				memset(buf, '\0', sizeof(buf));
+				(void) memset(buf, '\0', sizeof(buf));
 
 				/* read(2) should be used after #25443 */
 				r = recv(fd, buf, sizeof(buf), 0);
diff -u -p a/samples/net/sockets/coap_client/src/coap-client.c b/samples/net/sockets/coap_client/src/coap-client.c
--- a/samples/net/sockets/coap_client/src/coap-client.c
+++ b/samples/net/sockets/coap_client/src/coap-client.c
@@ -378,7 +378,7 @@ static int get_large_coap_msgs(void)
 
 		/* Received last block */
 		if (r == 1) {
-			memset(&blk_ctx, 0, sizeof(blk_ctx));
+			(void) memset(&blk_ctx, 0, sizeof(blk_ctx));
 			return 0;
 		}
 	}
diff -u -p a/samples/net/zperf/src/zperf_udp_receiver.c b/samples/net/zperf/src/zperf_udp_receiver.c
--- a/samples/net/zperf/src/zperf_udp_receiver.c
+++ b/samples/net/zperf/src/zperf_udp_receiver.c
@@ -58,7 +58,7 @@ static inline void build_reply(struct zp
 	int pos = 0;
 	struct zperf_server_hdr *stat_hdr;
 
-	memcpy(&buf[pos], hdr, sizeof(struct zperf_udp_datagram));
+	(void) memcpy(&buf[pos], hdr, sizeof(struct zperf_udp_datagram));
 	pos += sizeof(struct zperf_udp_datagram);
 
 	stat_hdr = (struct zperf_server_hdr *)&buf[pos];
@@ -328,8 +328,8 @@ void zperf_udp_receiver_init(const struc
 					      "Unable to get IPv4 by default\n");
 				return;
 			}
-			memcpy(&in4_addr_my->sin_addr, in4_addr,
-				sizeof(struct in_addr));
+			(void) memcpy(&in4_addr_my->sin_addr, in4_addr,
+					sizeof(struct in_addr));
 		}
 
 		shell_fprintf(shell, SHELL_NORMAL, "Binding to %s\n",
@@ -378,8 +378,8 @@ void zperf_udp_receiver_init(const struc
 					      "Unable to get IPv4 by default\n");
 				return;
 			}
-			memcpy(&in6_addr_my->sin6_addr, in6_addr,
-				sizeof(struct in6_addr));
+			(void) memcpy(&in6_addr_my->sin6_addr, in6_addr,
+					sizeof(struct in6_addr));
 		}
 
 		shell_fprintf(shell, SHELL_NORMAL, "Binding to %s\n",
diff -u -p a/samples/drivers/flash_shell/src/main.c b/samples/drivers/flash_shell/src/main.c
--- a/samples/drivers/flash_shell/src/main.c
+++ b/samples/drivers/flash_shell/src/main.c
@@ -298,7 +298,7 @@ static int do_write_unaligned(const stru
 			flash_read(flash_device, start_page, before_data, size_before);
 		}
 		/* Fill the with new data. */
-		memcpy(before_data + size_before, buf, len);
+		(void) memcpy(before_data + size_before, buf, len);
 		/* Fill the last part of old data. */
 		if (size_after) {
 			flash_read(flash_device, offset + len,
@@ -311,15 +311,15 @@ static int do_write_unaligned(const stru
 			flash_read(flash_device, start_page, before_data,
 					size_before);
 			/* Fill the rest with new data. */
-			memcpy(before_data + size_before, buf,
-			       page_size - size_before);
+			(void) memcpy(before_data + size_before, buf,
+					page_size - size_before);
 		}
 		if (size_after) {
 			/* Copy ending part of new data. */
-			memcpy((void *)after_data,
-			       (void *)(buf + len -
-				   ((len + size_before) % page_size)),
-			       page_size - size_after);
+			(void) memcpy((void *)after_data,
+					(void *)(buf + len -
+						 ((len + size_before) % page_size)),
+					page_size - size_after);
 			/* Copy ending part of flash page. */
 			flash_read(flash_device, offset + len,
 					after_data + (page_size - size_after),
diff -u -p a/samples/drivers/i2s/litex/src/main.c b/samples/drivers/i2s/litex/src/main.c
--- a/samples/drivers/i2s/litex/src/main.c
+++ b/samples/drivers/i2s/litex/src/main.c
@@ -108,7 +108,7 @@ void main(void)
 	while (true) {
 		k_mem_slab_alloc(&i2s_tx_mem_slab, &tx_mem_block, K_NO_WAIT);
 		i2s_read(host_i2s_rx_dev, &rx_mem_block, &size);
-		memcpy(tx_mem_block, rx_mem_block, size);
+		(void) memcpy(tx_mem_block, rx_mem_block, size);
 		i2s_write(host_i2s_tx_dev, tx_mem_block, size);
 		k_mem_slab_free(&i2s_rx_mem_slab, &rx_mem_block);
 	}
diff -u -p a/samples/subsys/canbus/isotp/src/main.c b/samples/subsys/canbus/isotp/src/main.c
--- a/samples/subsys/canbus/isotp/src/main.c
+++ b/samples/subsys/canbus/isotp/src/main.c
@@ -89,7 +89,7 @@ void rx_8_0_thread(void *arg1, void *arg
 				printk("%s", buf->data);
 			} else if (buf->len == 6) {
 				/* First frame does not have tailroom.*/
-				memcpy(rx_buffer, buf->data, 6);
+				(void) memcpy(rx_buffer, buf->data, 6);
 				rx_buffer[6] = '\0';
 				printk("%s", rx_buffer);
 			} else {
diff -u -p a/samples/basic/threads/src/main.c b/samples/basic/threads/src/main.c
--- a/samples/basic/threads/src/main.c
+++ b/samples/basic/threads/src/main.c
@@ -64,7 +64,7 @@ void blink(const struct led *led, uint32
 		char *mem_ptr = k_malloc(size);
 		__ASSERT_NO_MSG(mem_ptr != 0);
 
-		memcpy(mem_ptr, &tx_data, size);
+		(void) memcpy(mem_ptr, &tx_data, size);
 
 		k_fifo_put(&printk_fifo, mem_ptr);
 
diff -u -p a/samples/bluetooth/eddystone/src/main.c b/samples/bluetooth/eddystone/src/main.c
--- a/samples/bluetooth/eddystone/src/main.c
+++ b/samples/bluetooth/eddystone/src/main.c
@@ -203,7 +203,7 @@ static ssize_t write_slot(struct bt_conn
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(&value, buf, len);
+	(void) memcpy(&value, buf, len);
 
 	if (value + 1 > NUMBER_OF_SLOTS) {
 		return BT_GATT_ERR(BT_ATT_ERR_WRITE_NOT_PERMITTED);
@@ -243,7 +243,7 @@ static ssize_t write_tx_power(struct bt_
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(&slot->tx_power, buf, len);
+	(void) memcpy(&slot->tx_power, buf, len);
 
 	return len;
 }
@@ -278,7 +278,7 @@ static ssize_t write_adv_tx_power(struct
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(&slot->adv_tx_power, buf, len);
+	(void) memcpy(&slot->adv_tx_power, buf, len);
 
 	return len;
 }
@@ -330,7 +330,7 @@ static ssize_t write_lock(struct bt_conn
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 	}
 
-	memcpy(&value, buf, sizeof(value));
+	(void) memcpy(&value, buf, sizeof(value));
 
 	if (value > EDS_UNLOCKED_NO_RELOCKING) {
 		return BT_GATT_ERR(BT_ATT_ERR_WRITE_NOT_PERMITTED);
@@ -478,7 +478,7 @@ static ssize_t write_adv_data(struct bt_
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 	}
 
-	memcpy(&type, buf, sizeof(type));
+	(void) memcpy(&type, buf, sizeof(type));
 
 	switch (type) {
 	case EDS_TYPE_URL:
@@ -489,8 +489,8 @@ static ssize_t write_adv_data(struct bt_
 		 */
 		slot->ad[2].data_len = MIN(slot->ad[2].data_len,
 					   len + EDS_URL_WRITE_OFFSET);
-		memcpy(&slot->ad[2].data + EDS_URL_WRITE_OFFSET, buf,
-		       slot->ad[2].data_len - EDS_URL_WRITE_OFFSET);
+		(void) memcpy(&slot->ad[2].data + EDS_URL_WRITE_OFFSET, buf,
+				slot->ad[2].data_len - EDS_URL_WRITE_OFFSET);
 
 		/* Restart slot */
 		if (eds_slot_restart(slot, type) < 0) {
@@ -551,7 +551,7 @@ static ssize_t write_connectable(struct 
 	/* If any non-zero value is written, the beacon shall remain in its
 	 * connectable state until any other value is written.
 	 */
-	memcpy(&slot->connectable, buf, len);
+	(void) memcpy(&slot->connectable, buf, len);
 
 	return len;
 }
diff -u -p a/samples/bluetooth/central_hr/src/main.c b/samples/bluetooth/central_hr/src/main.c
--- a/samples/bluetooth/central_hr/src/main.c
+++ b/samples/bluetooth/central_hr/src/main.c
@@ -57,7 +57,7 @@ static uint8_t discover_func(struct bt_c
 	printk("[ATTRIBUTE] handle %u\n", attr->handle);
 
 	if (!bt_uuid_cmp(discover_params.uuid, BT_UUID_HRS)) {
-		memcpy(&uuid, BT_UUID_HRS_MEASUREMENT, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_HRS_MEASUREMENT, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.start_handle = attr->handle + 1;
 		discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
@@ -68,7 +68,7 @@ static uint8_t discover_func(struct bt_c
 		}
 	} else if (!bt_uuid_cmp(discover_params.uuid,
 				BT_UUID_HRS_MEASUREMENT)) {
-		memcpy(&uuid, BT_UUID_GATT_CCC, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_GATT_CCC, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.start_handle = attr->handle + 2;
 		discover_params.type = BT_GATT_DISCOVER_DESCRIPTOR;
@@ -117,7 +117,7 @@ static bool eir_found(struct bt_data *da
 			uint16_t u16;
 			int err;
 
-			memcpy(&u16, &data->data[i], sizeof(u16));
+			(void) memcpy(&u16, &data->data[i], sizeof(u16));
 			uuid = BT_UUID_DECLARE_16(sys_le16_to_cpu(u16));
 			if (bt_uuid_cmp(uuid, BT_UUID_HRS)) {
 				continue;
@@ -202,7 +202,7 @@ static void connected(struct bt_conn *co
 	printk("Connected: %s\n", addr);
 
 	if (conn == default_conn) {
-		memcpy(&uuid, BT_UUID_HRS, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_HRS, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.func = discover_func;
 		discover_params.start_handle = 0x0001;
diff -u -p a/samples/boards/reel_board/mesh_badge/src/reel_board.c b/samples/boards/reel_board/mesh_badge/src/reel_board.c
--- a/samples/boards/reel_board/mesh_badge/src/reel_board.c
+++ b/samples/boards/reel_board/mesh_badge/src/reel_board.c
@@ -85,7 +85,7 @@ static size_t print_line(enum font_size 
 	cfb_framebuffer_set_font(epd_dev, font_size);
 
 	len = MIN(len, fonts[font_size].columns);
-	memcpy(line, text, len);
+	(void) memcpy(line, text, len);
 	line[len] = '\0';
 
 	if (center) {
diff -u -p a/samples/boards/nrf/mesh/onoff-app/src/main.c b/samples/boards/nrf/mesh/onoff-app/src/main.c
--- a/samples/boards/nrf/mesh/onoff-app/src/main.c
+++ b/samples/boards/nrf/mesh/onoff-app/src/main.c
@@ -578,7 +578,7 @@ static void bt_ready(int err)
 	if (bt_le_oob_get_local(BT_ID_DEFAULT, &oob)) {
 		printk("Identity Address unavailable\n");
 	} else {
-		memcpy(dev_uuid, oob.addr.a.val, 6);
+		(void) memcpy(dev_uuid, oob.addr.a.val, 6);
 	}
 
 	bt_mesh_prov_enable(BT_MESH_PROV_GATT | BT_MESH_PROV_ADV);
diff -u -p a/arch/x86/core/multiboot.c b/arch/x86/core/multiboot.c
--- a/arch/x86/core/multiboot.c
+++ b/arch/x86/core/multiboot.c
@@ -31,7 +31,7 @@ static inline void clear_memmap(int inde
 void z_multiboot_init(struct multiboot_info *info)
 {
 	if (info != NULL) {
-		memcpy(&multiboot_info, info, sizeof(*info));
+		(void) memcpy(&multiboot_info, info, sizeof(*info));
 	}
 
 #ifdef CONFIG_MULTIBOOT_MEMMAP
diff -u -p a/arch/arm/core/aarch32/cortex_m/fault.c b/arch/arm/core/aarch32/cortex_m/fault.c
--- a/arch/arm/core/aarch32/cortex_m/fault.c
+++ b/arch/arm/core/aarch32/cortex_m/fault.c
@@ -966,13 +966,13 @@ void z_arm_fault(uint32_t msp, uint32_t 
 
 	/* Copy ESF */
 #if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
-	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
+	(void) memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
 	ARG_UNUSED(callee_regs);
 #else
 	/* the extra exception info is not present in the original esf
 	 * so we only copy the fields before those.
 	 */
-	memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
+	(void) memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
 	esf_copy.extra_info = (struct __extra_esf_info) {
 		.callee = callee_regs,
 		.exc_return = exc_return,
diff -u -p a/lib/cmsis_rtos_v2/mutex.c b/lib/cmsis_rtos_v2/mutex.c
--- a/lib/cmsis_rtos_v2/mutex.c
+++ b/lib/cmsis_rtos_v2/mutex.c
@@ -40,7 +40,7 @@ osMutexId_t osMutexNew(const osMutexAttr
 		 "Zephyr does not support osMutexRobust.\n");
 
 	if (k_mem_slab_alloc(&cv2_mutex_slab, (void **)&mutex, K_MSEC(100)) == 0) {
-		memset(mutex, 0, sizeof(struct cv2_mutex));
+		(void) memset(mutex, 0, sizeof(struct cv2_mutex));
 	} else {
 		return NULL;
 	}
diff -u -p a/lib/os/ring_buffer.c b/lib/os/ring_buffer.c
--- a/lib/os/ring_buffer.c
+++ b/lib/os/ring_buffer.c
@@ -148,7 +148,7 @@ uint32_t ring_buf_put(struct ring_buf *b
 
 	do {
 		partial_size = ring_buf_put_claim(buf, &dst, size);
-		memcpy(dst, data, partial_size);
+		(void) memcpy(dst, data, partial_size);
 		total_size += partial_size;
 		size -= partial_size;
 		data += partial_size;
@@ -206,7 +206,7 @@ uint32_t ring_buf_get(struct ring_buf *b
 
 	do {
 		partial_size = ring_buf_get_claim(buf, &src, size);
-		memcpy(data, src, partial_size);
+		(void) memcpy(data, src, partial_size);
 		total_size += partial_size;
 		size -= partial_size;
 		data += partial_size;
diff -u -p a/drivers/wifi/simplelink/simplelink_sockets.c b/drivers/wifi/simplelink/simplelink_sockets.c
--- a/drivers/wifi/simplelink/simplelink_sockets.c
+++ b/drivers/wifi/simplelink/simplelink_sockets.c
@@ -338,9 +338,9 @@ static SlSockAddr_t *translate_z_to_sl_a
 		*sl_addrlen = sizeof(SlSockAddrIn6_t);
 		sl_addr_in6->sin6_family = SL_AF_INET6;
 		sl_addr_in6->sin6_port = z_sockaddr_in6->sin6_port;
-		memcpy(sl_addr_in6->sin6_addr._S6_un._S6_u32,
-		       z_sockaddr_in6->sin6_addr.s6_addr,
-		       sizeof(sl_addr_in6->sin6_addr._S6_un._S6_u32));
+		(void) memcpy(sl_addr_in6->sin6_addr._S6_un._S6_u32,
+				z_sockaddr_in6->sin6_addr.s6_addr,
+				sizeof(sl_addr_in6->sin6_addr._S6_un._S6_u32));
 
 		sl_addr = (SlSockAddr_t *)sl_addr_in6;
 	}
@@ -380,9 +380,9 @@ static void translate_sl_to_z_addr(SlSoc
 			z_sockaddr_in6->sin6_port = sl_addr_in6->sin6_port;
 			z_sockaddr_in6->sin6_scope_id =
 				(uint8_t)sl_addr_in6->sin6_scope_id;
-			memcpy(z_sockaddr_in6->sin6_addr.s6_addr,
-			       sl_addr_in6->sin6_addr._S6_un._S6_u32,
-			       sizeof(z_sockaddr_in6->sin6_addr.s6_addr));
+			(void) memcpy(z_sockaddr_in6->sin6_addr.s6_addr,
+					sl_addr_in6->sin6_addr._S6_un._S6_u32,
+					sizeof(z_sockaddr_in6->sin6_addr.s6_addr));
 			*addrlen = sizeof(struct sockaddr_in6);
 		} else {
 			*addrlen = sl_addrlen;
diff -u -p a/drivers/wifi/eswifi/eswifi_core.c b/drivers/wifi/eswifi/eswifi_core.c
--- a/drivers/wifi/eswifi/eswifi_core.c
+++ b/drivers/wifi/eswifi/eswifi_core.c
@@ -395,7 +395,7 @@ static void eswifi_iface_init(struct net
 	LOG_DBG("MAC Address %02X:%02X:%02X:%02X:%02X:%02X",
 		   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 
-	memcpy(eswifi->mac, mac, sizeof(eswifi->mac));
+	(void) memcpy(eswifi->mac, mac, sizeof(eswifi->mac));
 	net_if_set_link_addr(iface, eswifi->mac, sizeof(eswifi->mac),
 			     NET_LINK_ETHERNET);
 
@@ -446,7 +446,7 @@ static int eswifi_mgmt_disconnect(const 
 static int __eswifi_sta_config(struct eswifi_dev *eswifi,
 			       struct wifi_connect_req_params *params)
 {
-	memcpy(eswifi->sta.ssid, params->ssid, params->ssid_length);
+	(void) memcpy(eswifi->sta.ssid, params->ssid, params->ssid_length);
 	eswifi->sta.ssid[params->ssid_length] = '\0';
 
 	switch (params->security) {
@@ -455,7 +455,7 @@ static int __eswifi_sta_config(struct es
 		eswifi->sta.security = ESWIFI_SEC_OPEN;
 		break;
 	case WIFI_SECURITY_TYPE_PSK:
-		memcpy(eswifi->sta.pass, params->psk, params->psk_length);
+		(void) memcpy(eswifi->sta.pass, params->psk, params->psk_length);
 		eswifi->sta.pass[params->psk_length] = '\0';
 		eswifi->sta.security = ESWIFI_SEC_WPA2_MIXED;
 		break;
diff -u -p a/drivers/ieee802154/ieee802154_dw1000.c b/drivers/ieee802154/ieee802154_dw1000.c
--- a/drivers/ieee802154/ieee802154_dw1000.c
+++ b/drivers/ieee802154/ieee802154_dw1000.c
@@ -474,7 +474,7 @@ static inline void dwt_irq_handle_rx(str
 		struct net_ptp_time timestamp;
 		uint64_t ts_fsec;
 
-		memcpy(ts_buf, rx_inf_reg.rx_time, DWT_RX_TIME_RX_STAMP_LEN);
+		(void) memcpy(ts_buf, rx_inf_reg.rx_time, DWT_RX_TIME_RX_STAMP_LEN);
 		ts_fsec = sys_get_le64(ts_buf) * DWT_TS_TIME_UNITS_FS;
 		timestamp.second = (ts_fsec / 1000000) / NSEC_PER_SEC;
 		timestamp.nanosecond = (ts_fsec / 1000000) % NSEC_PER_SEC;
diff -u -p a/drivers/ieee802154/ieee802154_kw41z.c b/drivers/ieee802154/ieee802154_kw41z.c
--- a/drivers/ieee802154/ieee802154_kw41z.c
+++ b/drivers/ieee802154/ieee802154_kw41z.c
@@ -414,10 +414,10 @@ static int kw41z_set_ieee_addr(const str
 {
 	uint32_t val;
 
-	memcpy(&val, ieee_addr, sizeof(val));
+	(void) memcpy(&val, ieee_addr, sizeof(val));
 	ZLL->MACLONGADDRS0_LSB = val;
 
-	memcpy(&val, ieee_addr + sizeof(val), sizeof(val));
+	(void) memcpy(&val, ieee_addr + sizeof(val), sizeof(val));
 	ZLL->MACLONGADDRS0_MSB = val;
 
 	return 0;
@@ -650,12 +650,12 @@ static int kw41z_tx(const struct device 
 
 #if CONFIG_SOC_MKW41Z4
 	((uint8_t *)ZLL->PKT_BUFFER_TX)[0] = payload_len + KW41Z_FCS_LENGTH;
-	memcpy(((uint8_t *)ZLL->PKT_BUFFER_TX) + 1,
-		(void *)frag->data, payload_len);
+	(void) memcpy(((uint8_t *)ZLL->PKT_BUFFER_TX) + 1,
+			(void *)frag->data, payload_len);
 #else /* CONFIG_SOC_MKW40Z4 */
 	((uint8_t *)ZLL->PKT_BUFFER)[0] = payload_len + KW41Z_FCS_LENGTH;
-	memcpy(((uint8_t *)ZLL->PKT_BUFFER) + 1,
-		(void *)frag->data, payload_len);
+	(void) memcpy(((uint8_t *)ZLL->PKT_BUFFER) + 1,
+			(void *)frag->data, payload_len);
 #endif
 
 	/* Set CCA mode */
diff -u -p a/drivers/crypto/crypto_nrf_ecb.c b/drivers/crypto/crypto_nrf_ecb.c
--- a/drivers/crypto/crypto_nrf_ecb.c
+++ b/drivers/crypto/crypto_nrf_ecb.c
@@ -41,8 +41,8 @@ static int do_ecb_encrypt(struct cipher_
 	}
 
 	if (pkt->in_buf != drv_state.data.cleartext) {
-		memcpy(drv_state.data.cleartext, pkt->in_buf,
-		       ECB_AES_BLOCK_SIZE);
+		(void) memcpy(drv_state.data.cleartext, pkt->in_buf,
+				ECB_AES_BLOCK_SIZE);
 	}
 
 	nrf_ecb_event_clear(NRF_ECB, NRF_ECB_EVENT_ENDECB);
@@ -56,8 +56,8 @@ static int do_ecb_encrypt(struct cipher_
 		return -EIO;
 	}
 	if (pkt->out_buf != drv_state.data.ciphertext) {
-		memcpy(pkt->out_buf, drv_state.data.ciphertext,
-		       ECB_AES_BLOCK_SIZE);
+		(void) memcpy(pkt->out_buf, drv_state.data.ciphertext,
+				ECB_AES_BLOCK_SIZE);
 	}
 	pkt->out_len = pkt->in_len;
 	return 0;
@@ -112,8 +112,8 @@ static int nrf_ecb_session_setup(const s
 	ctx->ops.cipher_mode = mode;
 
 	if (ctx->key.bit_stream != drv_state.data.key) {
-		memcpy(drv_state.data.key, ctx->key.bit_stream,
-		       ECB_AES_KEY_SIZE);
+		(void) memcpy(drv_state.data.key, ctx->key.bit_stream,
+				ECB_AES_KEY_SIZE);
 	}
 
 	return 0;
diff -u -p a/drivers/net/ppp.c b/drivers/net/ppp.c
--- a/drivers/net/ppp.c
+++ b/drivers/net/ppp.c
@@ -467,7 +467,7 @@ void ppp_driver_feed_data(uint8_t *data,
 	/* We are expecting that the tests are feeding data in large
 	 * chunks so we can reset the uart buffer here.
 	 */
-	memset(ppp->buf, 0, UART_BUF_LEN);
+	(void) memset(ppp->buf, 0, UART_BUF_LEN);
 
 	ppp_change_state(ppp, STATE_HDLC_FRAME_START);
 
@@ -477,7 +477,7 @@ void ppp_driver_feed_data(uint8_t *data,
 
 		LOG_DBG("Feeding %d bytes", data_to_copy);
 
-		memcpy(ppp->buf, data, data_to_copy);
+		(void) memcpy(ppp->buf, data, data_to_copy);
 
 		recv_off = data_to_copy;
 
@@ -755,7 +755,7 @@ use_random_mac:
 	net_if_set_link_addr(iface, ll_addr->addr, ll_addr->len,
 			     NET_LINK_ETHERNET);
 
-	memset(ppp->buf, 0, sizeof(ppp->buf));
+	(void) memset(ppp->buf, 0, sizeof(ppp->buf));
 
 	/* If we have a GSM modem with PPP support, then do not start the
 	 * interface automatically but only after the modem is ready.
diff -u -p a/drivers/hwinfo/hwinfo_stm32.c b/drivers/hwinfo/hwinfo_stm32.c
--- a/drivers/hwinfo/hwinfo_stm32.c
+++ b/drivers/hwinfo/hwinfo_stm32.c
@@ -25,7 +25,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = sizeof(dev_id.id);
 	}
 
-	memcpy(buffer, dev_id.id, length);
+	(void) memcpy(buffer, dev_id.id, length);
 
 	return length;
 }
diff -u -p a/drivers/hwinfo/hwinfo_nrf.c b/drivers/hwinfo/hwinfo_nrf.c
--- a/drivers/hwinfo/hwinfo_nrf.c
+++ b/drivers/hwinfo/hwinfo_nrf.c
@@ -25,7 +25,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = sizeof(dev_id.id);
 	}
 
-	memcpy(buffer, dev_id.id, length);
+	(void) memcpy(buffer, dev_id.id, length);
 
 	return length;
 }
diff -u -p a/drivers/i2c/i2c_nrfx_twim.c b/drivers/i2c/i2c_nrfx_twim.c
--- a/drivers/i2c/i2c_nrfx_twim.c
+++ b/drivers/i2c/i2c_nrfx_twim.c
@@ -92,9 +92,9 @@ static int i2c_nrfx_twim_transfer(const 
 				break;
 			}
 			if (!(msgs[i].flags & I2C_MSG_READ)) {
-				memcpy(concat_buf + concat_len,
-				       msgs[i].buf,
-				       msgs[i].len);
+				(void) memcpy(concat_buf + concat_len,
+						msgs[i].buf,
+						msgs[i].len);
 			}
 			concat_len += msgs[i].len;
 		}
@@ -162,9 +162,9 @@ static int i2c_nrfx_twim_transfer(const 
 
 			while (concat_len >= msgs[j].len) {
 				concat_len -= msgs[j].len;
-				memcpy(msgs[j].buf,
-				       concat_buf + concat_len,
-				       msgs[j].len);
+				(void) memcpy(msgs[j].buf,
+						concat_buf + concat_len,
+						msgs[j].len);
 				j--;
 			}
 
diff -u -p a/drivers/entropy/entropy_sam.c b/drivers/entropy/entropy_sam.c
--- a/drivers/entropy/entropy_sam.c
+++ b/drivers/entropy/entropy_sam.c
@@ -91,7 +91,7 @@ static int entropy_sam_get_entropy_inter
 		value = _data(trng);
 		to_copy = MIN(length, sizeof(value));
 
-		memcpy(buffer, &value, to_copy);
+		(void) memcpy(buffer, &value, to_copy);
 		buffer += to_copy;
 		length -= to_copy;
 	}
@@ -131,7 +131,7 @@ static int entropy_sam_get_entropy_isr(c
 			value = _data(trng);
 			to_copy = MIN(length, sizeof(value));
 
-			memcpy(buffer, &value, to_copy);
+			(void) memcpy(buffer, &value, to_copy);
 			buffer += to_copy;
 			length -= to_copy;
 
diff -u -p a/drivers/ethernet/eth_stm32_hal.c b/drivers/ethernet/eth_stm32_hal.c
--- a/drivers/ethernet/eth_stm32_hal.c
+++ b/drivers/ethernet/eth_stm32_hal.c
@@ -214,7 +214,7 @@ static int eth_tx(const struct device *d
 #if defined(CONFIG_SOC_SERIES_STM32H7X)
 	ETH_BufferTypeDef tx_buffer_def[ETH_TXBUF_DEF_NB];
 
-	memset(tx_buffer_def, 0, ETH_TXBUF_DEF_NB*sizeof(ETH_BufferTypeDef));
+	(void) memset(tx_buffer_def, 0, ETH_TXBUF_DEF_NB*sizeof(ETH_BufferTypeDef));
 
 	tx_buffer_def[cur_tx_desc_idx].buffer = dma_buffer;
 	tx_buffer_def[cur_tx_desc_idx].len = total_len;
@@ -684,7 +684,7 @@ static int eth_initialize(const struct d
 
 #if defined(CONFIG_SOC_SERIES_STM32H7X)
 	/* Tx config init: */
-	memset(&tx_config, 0, sizeof(ETH_TxPacketConfig));
+	(void) memset(&tx_config, 0, sizeof(ETH_TxPacketConfig));
 	tx_config.Attributes = ETH_TX_PACKETS_FEATURES_CSUM |
 				ETH_TX_PACKETS_FEATURES_CRCPAD;
 	tx_config.ChecksumCtrl = ETH_CHECKSUM_IPHDR_PAYLOAD_INSERT_PHDR_CALC;
@@ -820,7 +820,7 @@ static int eth_stm32_hal_set_config(cons
 		dev_data = DEV_DATA(dev);
 		heth = &dev_data->heth;
 
-		memcpy(dev_data->mac_addr, config->mac_address.addr, 6);
+		(void) memcpy(dev_data->mac_addr, config->mac_address.addr, 6);
 		heth->Instance->MACA0HR = (dev_data->mac_addr[5] << 8) |
 			dev_data->mac_addr[4];
 		heth->Instance->MACA0LR = (dev_data->mac_addr[3] << 24) |
diff -u -p a/drivers/usb/device/usb_dc_stm32.c b/drivers/usb/device/usb_dc_stm32.c
--- a/drivers/usb/device/usb_dc_stm32.c
+++ b/drivers/usb/device/usb_dc_stm32.c
@@ -834,8 +834,9 @@ int usb_dc_ep_read_wait(uint8_t ep, uint
 	 */
 	if (data) {
 		read_count = MIN(read_count, max_data_len);
-		memcpy(data, usb_dc_stm32_state.ep_buf[USB_EP_GET_IDX(ep)] +
-		       ep_state->read_offset, read_count);
+		(void) memcpy(data,
+				usb_dc_stm32_state.ep_buf[USB_EP_GET_IDX(ep)] +
+				ep_state->read_offset, read_count);
 		ep_state->read_count -= read_count;
 		ep_state->read_offset += read_count;
 	} else if (max_data_len) {
@@ -1010,8 +1011,8 @@ void HAL_PCD_SetupStageCallback(PCD_Hand
 
 	ep_state->read_count = SETUP_SIZE;
 	ep_state->read_offset = 0U;
-	memcpy(&usb_dc_stm32_state.ep_buf[EP0_IDX],
-	       usb_dc_stm32_state.pcd.Setup, ep_state->read_count);
+	(void) memcpy(&usb_dc_stm32_state.ep_buf[EP0_IDX],
+			usb_dc_stm32_state.pcd.Setup, ep_state->read_count);
 
 	if (ep_state->cb) {
 		ep_state->cb(EP0_OUT, USB_DC_EP_SETUP);
diff -u -p a/drivers/flash/soc_flash_nrf.c b/drivers/flash/soc_flash_nrf.c
--- a/drivers/flash/soc_flash_nrf.c
+++ b/drivers/flash/soc_flash_nrf.c
@@ -128,7 +128,7 @@ static int flash_nrf_read(const struct d
 		return 0;
 	}
 
-	memcpy(data, (void *)addr, len);
+	(void) memcpy(data, (void *)addr, len);
 
 	return 0;
 }
diff -u -p a/drivers/flash/soc_flash_rv32m1.c b/drivers/flash/soc_flash_rv32m1.c
--- a/drivers/flash/soc_flash_rv32m1.c
+++ b/drivers/flash/soc_flash_rv32m1.c
@@ -78,7 +78,7 @@ static int flash_mcux_read(const struct 
 	 */
 	addr = offset + priv->pflash_block_base;
 
-	memcpy(data, (void *) addr, len);
+	(void) memcpy(data, (void *) addr, len);
 
 	return 0;
 }
diff -u -p a/drivers/flash/flash_simulator.c b/drivers/flash/flash_simulator.c
--- a/drivers/flash/flash_simulator.c
+++ b/drivers/flash/flash_simulator.c
@@ -191,7 +191,7 @@ static int flash_sim_read(const struct d
 
 	STATS_INC(flash_sim_stats, flash_read_calls);
 
-	memcpy(data, FLASH(offset), len);
+	(void) memcpy(data, FLASH(offset), len);
 	STATS_INCN(flash_sim_stats, bytes_read, len);
 
 #ifdef CONFIG_FLASH_SIMULATOR_SIMULATE_TIMING
@@ -225,7 +225,7 @@ static int flash_sim_write(const struct 
 	STATS_INC(flash_sim_stats, flash_write_calls);
 
 	/* check if any unit has been already programmed */
-	memset(buf, FLASH_SIMULATOR_ERASE_VALUE, sizeof(buf));
+	(void) memset(buf, FLASH_SIMULATOR_ERASE_VALUE, sizeof(buf));
 	for (uint32_t i = 0; i < len; i += FLASH_SIMULATOR_PROG_UNIT) {
 		if (memcmp(buf, FLASH(offset + i), sizeof(buf))) {
 			STATS_INC(flash_sim_stats, double_writes);
@@ -284,8 +284,8 @@ static void unit_erase(const uint32_t un
 				(unit * FLASH_SIMULATOR_ERASE_UNIT);
 
 	/* erase the memory unit by setting it to erase value */
-	memset(FLASH(unit_addr), FLASH_SIMULATOR_ERASE_VALUE,
-	       FLASH_SIMULATOR_ERASE_UNIT);
+	(void) memset(FLASH(unit_addr), FLASH_SIMULATOR_ERASE_VALUE,
+			FLASH_SIMULATOR_ERASE_UNIT);
 }
 
 static int flash_sim_erase(const struct device *dev, const off_t offset,
@@ -426,7 +426,7 @@ static int flash_mock_init(const struct 
 
 static int flash_mock_init(const struct device *dev)
 {
-	memset(mock_flash, FLASH_SIMULATOR_ERASE_VALUE, ARRAY_SIZE(mock_flash));
+	(void) memset(mock_flash, FLASH_SIMULATOR_ERASE_VALUE, ARRAY_SIZE(mock_flash));
 	return 0;
 }
 
diff -u -p a/drivers/spi/spi_handlers.c b/drivers/spi/spi_handlers.c
--- a/drivers/spi/spi_handlers.c
+++ b/drivers/spi/spi_handlers.c
@@ -85,10 +85,10 @@ static inline int z_vrfy_spi_transceive(
 
 		Z_OOPS(Z_SYSCALL_MEMORY_READ(tx_bufs,
 					     sizeof(struct spi_buf_set)));
-		memcpy(&tx_bufs_copy, tx, sizeof(tx_bufs_copy));
+		(void) memcpy(&tx_bufs_copy, tx, sizeof(tx_bufs_copy));
 		Z_OOPS(Z_SYSCALL_VERIFY(tx_bufs_copy.count < 32));
 	} else {
-		memset(&tx_bufs_copy, 0, sizeof(tx_bufs_copy));
+		(void) memset(&tx_bufs_copy, 0, sizeof(tx_bufs_copy));
 	}
 
 	if (rx_bufs) {
@@ -97,13 +97,13 @@ static inline int z_vrfy_spi_transceive(
 
 		Z_OOPS(Z_SYSCALL_MEMORY_READ(rx_bufs,
 					     sizeof(struct spi_buf_set)));
-		memcpy(&rx_bufs_copy, rx, sizeof(rx_bufs_copy));
+		(void) memcpy(&rx_bufs_copy, rx, sizeof(rx_bufs_copy));
 		Z_OOPS(Z_SYSCALL_VERIFY(rx_bufs_copy.count < 32));
 	} else {
-		memset(&rx_bufs_copy, 0, sizeof(rx_bufs_copy));
+		(void) memset(&rx_bufs_copy, 0, sizeof(rx_bufs_copy));
 	}
 
-	memcpy(&config_copy, config, sizeof(*config));
+	(void) memcpy(&config_copy, config, sizeof(*config));
 	if (config_copy.cs) {
 		const struct spi_cs_control *cs = config_copy.cs;
 
diff -u -p a/drivers/sensor/vl53l0x/vl53l0x_platform.c b/drivers/sensor/vl53l0x/vl53l0x_platform.c
--- a/drivers/sensor/vl53l0x/vl53l0x_platform.c
+++ b/drivers/sensor/vl53l0x/vl53l0x_platform.c
@@ -28,7 +28,7 @@ VL53L0X_Error VL53L0X_WriteMulti(VL53L0X
 	uint8_t I2CBuffer[count+1];
 
 	I2CBuffer[0] = index;
-	memcpy(&I2CBuffer[1], pdata, count);
+	(void) memcpy(&I2CBuffer[1], pdata, count);
 
 	status_int = i2c_write(Dev->i2c, I2CBuffer, count+1, Dev->I2cDevAddr);
 
diff -u -p a/drivers/bluetooth/hci/h5.c b/drivers/bluetooth/hci/h5.c
--- a/drivers/bluetooth/hci/h5.c
+++ b/drivers/bluetooth/hci/h5.c
@@ -457,7 +457,7 @@ static void bt_uart_isr(const struct dev
 				continue;
 			}
 
-			memcpy(&hdr[sizeof(hdr) - remaining], &byte, 1);
+			(void) memcpy(&hdr[sizeof(hdr) - remaining], &byte, 1);
 			remaining--;
 
 			if (remaining) {
@@ -595,7 +595,7 @@ static int h5_queue(struct net_buf *buf)
 		return -1;
 	}
 
-	memcpy(net_buf_push(buf, sizeof(type)), &type, sizeof(type));
+	(void) memcpy(net_buf_push(buf, sizeof(type)), &type, sizeof(type));
 
 	net_buf_put(&h5.tx_queue, buf);
 
diff -u -p a/drivers/modem/modem_cmd_handler.c b/drivers/modem/modem_cmd_handler.c
--- a/drivers/modem/modem_cmd_handler.c
+++ b/drivers/modem/modem_cmd_handler.c
@@ -177,7 +177,7 @@ static int process_cmd(struct modem_cmd 
 	uint16_t argc = 0U;
 
 	/* reset params */
-	memset(argv, 0, sizeof(argv[0]) * ARRAY_SIZE(argv));
+	(void) memset(argv, 0, sizeof(argv[0]) * ARRAY_SIZE(argv));
 
 	/* do we need to parse arguments? */
 	if (cmd->arg_count > 0U) {
diff -u -p a/drivers/ipm/ipm_intel_adsp.c b/drivers/ipm/ipm_intel_adsp.c
--- a/drivers/ipm/ipm_intel_adsp.c
+++ b/drivers/ipm/ipm_intel_adsp.c
@@ -131,7 +131,7 @@ static int ipm_adsp_send(const struct de
 		}
 	}
 
-	memcpy((void *)IPM_INTEL_ADSP_MAILBOX_OUT, data, size);
+	(void) memcpy((void *)IPM_INTEL_ADSP_MAILBOX_OUT, data, size);
 	SOC_DCACHE_FLUSH((void *)IPM_INTEL_ADSP_MAILBOX_OUT, size);
 
 	ipc_write(IPC_DIPCIE, 0);
diff -u -p a/drivers/display/ssd1306.c b/drivers/display/ssd1306.c
--- a/drivers/display/ssd1306.c
+++ b/drivers/display/ssd1306.c
@@ -324,7 +324,7 @@ static int ssd1306_set_contrast(const st
 static void ssd1306_get_capabilities(const struct device *dev,
 				     struct display_capabilities *caps)
 {
-	memset(caps, 0, sizeof(struct display_capabilities));
+	(void) memset(caps, 0, sizeof(struct display_capabilities));
 	caps->x_resolution = DT_INST_PROP(0, width);
 	caps->y_resolution = DT_INST_PROP(0, height);
 	caps->supported_pixel_formats = PIXEL_FORMAT_MONO10;
diff -u -p a/drivers/display/display_st7789v.c b/drivers/display/display_st7789v.c
--- a/drivers/display/display_st7789v.c
+++ b/drivers/display/display_st7789v.c
@@ -225,7 +225,7 @@ static void st7789v_get_capabilities(con
 {
 	struct st7789v_data *data = (struct st7789v_data *)dev->data;
 
-	memset(capabilities, 0, sizeof(struct display_capabilities));
+	(void) memset(capabilities, 0, sizeof(struct display_capabilities));
 	capabilities->x_resolution = data->width;
 	capabilities->y_resolution = data->height;
 
diff -u -p a/drivers/display/display_ili9340.c b/drivers/display/display_ili9340.c
--- a/drivers/display/display_ili9340.c
+++ b/drivers/display/display_ili9340.c
@@ -253,7 +253,7 @@ static int ili9340_set_orientation(const
 static void ili9340_get_capabilities(const struct device *dev,
 				     struct display_capabilities *capabilities)
 {
-	memset(capabilities, 0, sizeof(struct display_capabilities));
+	(void) memset(capabilities, 0, sizeof(struct display_capabilities));
 	capabilities->x_resolution = 320U;
 	capabilities->y_resolution = 240U;
 #ifdef CONFIG_ILI9340_RGB565
diff -u -p a/drivers/i2s/i2s_sam_ssc.c b/drivers/i2s/i2s_sam_ssc.c
--- a/drivers/i2s/i2s_sam_ssc.c
+++ b/drivers/i2s/i2s_sam_ssc.c
@@ -593,7 +593,7 @@ static int i2s_sam_configure(const struc
 		return -EINVAL;
 	}
 
-	memcpy(&stream->cfg, i2s_cfg, sizeof(struct i2s_config));
+	(void) memcpy(&stream->cfg, i2s_cfg, sizeof(struct i2s_config));
 
 	bit_clk_freq = i2s_cfg->frame_clk_freq * word_size_bits * num_words;
 	ret = bit_clock_set(ssc, bit_clk_freq);
diff -u -p a/drivers/eeprom/eeprom_simulator.c b/drivers/eeprom/eeprom_simulator.c
--- a/drivers/eeprom/eeprom_simulator.c
+++ b/drivers/eeprom/eeprom_simulator.c
@@ -120,7 +120,7 @@ static int eeprom_sim_read(const struct 
 	SYNC_LOCK();
 
 	STATS_INC(eeprom_sim_stats, eeprom_read_calls);
-	memcpy(data, EEPROM(offset), len);
+	(void) memcpy(data, EEPROM(offset), len);
 	STATS_INCN(eeprom_sim_stats, bytes_read, len);
 
 	SYNC_UNLOCK();
@@ -178,7 +178,7 @@ static int eeprom_sim_write(const struct
 		len = eeprom_sim_thresholds.max_len;
 	}
 
-	memcpy(EEPROM(offset), data, len);
+	(void) memcpy(EEPROM(offset), data, len);
 
 	STATS_INCN(eeprom_sim_stats, bytes_written, len);
 
@@ -251,7 +251,7 @@ static int eeprom_mock_init(const struct
 
 static int eeprom_mock_init(const struct device *dev)
 {
-	memset(mock_eeprom, 0xFF, ARRAY_SIZE(mock_eeprom));
+	(void) memset(mock_eeprom, 0xFF, ARRAY_SIZE(mock_eeprom));
 	return 0;
 }
 
diff -u -p a/drivers/serial/uart_nuvoton.c b/drivers/serial/uart_nuvoton.c
--- a/drivers/serial/uart_nuvoton.c
+++ b/drivers/serial/uart_nuvoton.c
@@ -131,7 +131,7 @@ static int uart_numicro_configure(const 
 	UART_SetLineConfig(UART_STRUCT(dev), cfg->baudrate, databits,
 			   parity, stopbits);
 
-	memcpy(&ddata->ucfg, cfg, sizeof(*cfg));
+	(void) memcpy(&ddata->ucfg, cfg, sizeof(*cfg));
 
 	return 0;
 }
@@ -141,7 +141,7 @@ static int uart_numicro_config_get(const
 {
 	struct uart_numicro_data *ddata = DRV_DATA(dev);
 
-	memcpy(cfg, &ddata->ucfg, sizeof(*cfg));
+	(void) memcpy(cfg, &ddata->ucfg, sizeof(*cfg));
 
 	return 0;
 }
diff -u -p a/soc/arm/st_stm32/stm32f0/soc.c b/soc/arm/st_stm32/stm32f0/soc.c
--- a/soc/arm/st_stm32/stm32f0/soc.c
+++ b/soc/arm/st_stm32/stm32f0/soc.c
@@ -41,7 +41,7 @@ void relocate_vector_table(void)
 
 	size_t vector_size = (size_t)_vector_end - (size_t)_vector_start;
 
-	memcpy(_ram_vector_start, _vector_start, vector_size);
+	(void) memcpy(_ram_vector_start, _vector_start, vector_size);
 	LL_SYSCFG_SetRemapMemory(LL_SYSCFG_REMAP_SRAM);
 #endif
 }
diff -u -p a/subsys/settings/src/settings_file.c b/subsys/settings/src/settings_file.c
--- a/subsys/settings/src/settings_file.c
+++ b/subsys/settings/src/settings_file.c
@@ -187,8 +187,8 @@ static void settings_tmpfile(char *dst, 
 	if (len + pfx_len >= SETTINGS_FILE_NAME_MAX) {
 		len = SETTINGS_FILE_NAME_MAX - pfx_len - 1;
 	}
-	memcpy(dst, src, len);
-	memcpy(dst + len, pfx, pfx_len);
+	(void) memcpy(dst, src, len);
+	(void) memcpy(dst + len, pfx, pfx_len);
 	dst[len + pfx_len] = '\0';
 }
 
diff -u -p a/subsys/mgmt/hawkbit/hawkbit.c b/subsys/mgmt/hawkbit/hawkbit.c
--- a/subsys/mgmt/hawkbit/hawkbit.c
+++ b/subsys/mgmt/hawkbit/hawkbit.c
@@ -846,8 +846,8 @@ static bool send_request(enum http_metho
 		hb_context.code_status = HAWKBIT_METADATA_ERROR;
 	}
 
-	memset(&hb_context.http_req, 0, sizeof(hb_context.http_req));
-	memset(&hb_context.recv_buf_tcp, 0, sizeof(hb_context.recv_buf_tcp));
+	(void) memset(&hb_context.http_req, 0, sizeof(hb_context.http_req));
+	(void) memset(&hb_context.recv_buf_tcp, 0, sizeof(hb_context.recv_buf_tcp));
 	hb_context.http_req.url = hb_context.url_buffer;
 	hb_context.http_req.method = method;
 	hb_context.http_req.host = CONFIG_HAWKBIT_SERVER;
@@ -869,7 +869,7 @@ static bool send_request(enum http_metho
 		break;
 
 	case HAWKBIT_CONFIG_DEVICE:
-		memset(&cfg, 0, sizeof(cfg));
+		(void) memset(&cfg, 0, sizeof(cfg));
 		cfg.mode = "merge";
 		cfg.data.VIN = device_id;
 		cfg.data.hwRevision = "3";
@@ -904,9 +904,9 @@ static bool send_request(enum http_metho
 		break;
 
 	case HAWKBIT_CLOSE:
-		memset(&close, 0, sizeof(close));
-		memset(&hb_context.status_buffer, 0,
-		       sizeof(hb_context.status_buffer));
+		(void) memset(&close, 0, sizeof(close));
+		(void) memset(&hb_context.status_buffer, 0,
+				sizeof(hb_context.status_buffer));
 		snprintk(acid, sizeof(acid), "%d", hb_context.action_id);
 		close.id = acid;
 		close.time = "";
@@ -957,7 +957,7 @@ static bool send_request(enum http_metho
 		LOG_INF("Reporting deployment feedback %s (%s) for action %d",
 			fini, exec, hb_context.json_action_id);
 		/* Build JSON */
-		memset(&feedback, 0, sizeof(feedback));
+		(void) memset(&feedback, 0, sizeof(feedback));
 		snprintk(acid, sizeof(acid), "%d", hb_context.json_action_id);
 		feedback.id = acid;
 		feedback.status.result.finished = fini;
@@ -1012,7 +1012,7 @@ enum hawkbit_response hawkbit_probe(void
 	     deployment_base[DEPLOYMENT_BASE_SIZE] = { 0 },
 	     firmware_version[BOOT_IMG_VER_STRLEN_MAX] = { 0 };
 
-	memset(&hb_context, 0, sizeof(hb_context));
+	(void) memset(&hb_context, 0, sizeof(hb_context));
 	hb_context.response_data = malloc(RESPONSE_BUFFER_SIZE);
 	k_sem_init(&hb_context.semaphore, 0, 1);
 
@@ -1043,12 +1043,12 @@ enum hawkbit_response hawkbit_probe(void
 	 */
 	LOG_INF("Polling target data from Hawkbit");
 
-	memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
+	(void) memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
 	hb_context.dl.http_content_size = 0;
 	hb_context.url_buffer_size = URL_BUFFER_SIZE;
 	snprintk(hb_context.url_buffer, hb_context.url_buffer_size, "%s/%s-%s",
 		 HAWKBIT_JSON_URL, CONFIG_BOARD, device_id);
-	memset(&hawkbit_results.base, 0, sizeof(hawkbit_results.base));
+	(void) memset(&hawkbit_results.base, 0, sizeof(hawkbit_results.base));
 
 	if (!send_request(HTTP_GET, HAWKBIT_PROBE, HAWKBIT_STATUS_FINISHED_NONE,
 			  HAWKBIT_STATUS_EXEC_NONE)) {
@@ -1071,14 +1071,14 @@ enum hawkbit_response hawkbit_probe(void
 	if (hawkbit_results.base._links.cancelAction.href) {
 		ret = hawkbit_find_cancelAction_base(&hawkbit_results.base,
 						     cancel_base);
-		memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
+		(void) memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
 		hb_context.dl.http_content_size = 0;
 		hb_context.url_buffer_size = URL_BUFFER_SIZE;
 		snprintk(hb_context.url_buffer, hb_context.url_buffer_size,
 			 "%s/%s-%s/%s/feedback", HAWKBIT_JSON_URL, CONFIG_BOARD,
 			 device_id, cancel_base);
-		memset(&hawkbit_results.cancel, 0,
-		       sizeof(hawkbit_results.cancel));
+		(void) memset(&hawkbit_results.cancel, 0,
+				sizeof(hawkbit_results.cancel));
 
 		if (!send_request(HTTP_POST, HAWKBIT_CLOSE,
 				  HAWKBIT_STATUS_FINISHED_SUCCESS,
@@ -1093,7 +1093,7 @@ enum hawkbit_response hawkbit_probe(void
 	}
 
 	if (hawkbit_results.base._links.configData.href) {
-		memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
+		(void) memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
 		hb_context.dl.http_content_size = 0;
 		hb_context.url_buffer_size = URL_BUFFER_SIZE;
 		snprintk(hb_context.url_buffer, hb_context.url_buffer_size,
@@ -1121,14 +1121,14 @@ enum hawkbit_response hawkbit_probe(void
 		goto cleanup;
 	}
 
-	memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
+	(void) memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
 	hb_context.dl.http_content_size = 0;
 	hb_context.url_buffer_size = URL_BUFFER_SIZE;
 	snprintk(hb_context.url_buffer, hb_context.url_buffer_size,
 		 "%s/%s-%s/%s", HAWKBIT_JSON_URL, CONFIG_BOARD, device_id,
 		 deployment_base);
-	memset(&hawkbit_results.dep, 0, sizeof(hawkbit_results.dep));
-	memset(hb_context.response_data, 0, RESPONSE_BUFFER_SIZE);
+	(void) memset(&hawkbit_results.dep, 0, sizeof(hawkbit_results.dep));
+	(void) memset(hb_context.response_data, 0, RESPONSE_BUFFER_SIZE);
 
 	if (!send_request(HTTP_GET, HAWKBIT_PROBE_DEPLOYMENT_BASE,
 			  HAWKBIT_STATUS_FINISHED_NONE,
@@ -1159,7 +1159,7 @@ enum hawkbit_response hawkbit_probe(void
 		LOG_INF("Preventing repeated attempt to install %d",
 			hb_context.json_action_id);
 		hb_context.dl.http_content_size = 0;
-		memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
+		(void) memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
 		hb_context.url_buffer_size = URL_BUFFER_SIZE;
 		snprintk(hb_context.url_buffer, hb_context.url_buffer_size,
 			 "%s/%s-%s/deploymentBase/%d/feedback",
@@ -1181,7 +1181,7 @@ enum hawkbit_response hawkbit_probe(void
 	LOG_INF("Ready to install update");
 
 	hb_context.dl.http_content_size = 0;
-	memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
+	(void) memset(hb_context.url_buffer, 0, sizeof(hb_context.url_buffer));
 	hb_context.url_buffer_size = URL_BUFFER_SIZE;
 
 	snprintk(hb_context.url_buffer, hb_context.url_buffer_size, "%s",
diff -u -p a/subsys/mgmt/mcumgr/buf.c b/subsys/mgmt/mcumgr/buf.c
--- a/subsys/mgmt/mcumgr/buf.c
+++ b/subsys/mgmt/mcumgr/buf.c
@@ -51,7 +51,7 @@ cbor_nb_reader_get16(struct cbor_decoder
 		return UINT16_MAX;
 	}
 
-	memcpy(&val, cnr->nb->data + offset, sizeof(val));
+	(void) memcpy(&val, cnr->nb->data + offset, sizeof(val));
 	return cbor_ntohs(val);
 }
 
@@ -67,7 +67,7 @@ cbor_nb_reader_get32(struct cbor_decoder
 		return UINT32_MAX;
 	}
 
-	memcpy(&val, cnr->nb->data + offset, sizeof(val));
+	(void) memcpy(&val, cnr->nb->data + offset, sizeof(val));
 	return cbor_ntohl(val);
 }
 
@@ -83,7 +83,7 @@ cbor_nb_reader_get64(struct cbor_decoder
 		return UINT64_MAX;
 	}
 
-	memcpy(&val, cnr->nb->data + offset, sizeof(val));
+	(void) memcpy(&val, cnr->nb->data + offset, sizeof(val));
 	return cbor_ntohll(val);
 }
 
diff -u -p a/subsys/mgmt/osdp/src/osdp_cp.c b/subsys/mgmt/osdp/src/osdp_cp.c
--- a/subsys/mgmt/osdp/src/osdp_cp.c
+++ b/subsys/mgmt/osdp/src/osdp_cp.c
@@ -532,7 +532,7 @@ static int cp_phy_state_update(struct os
 			break;
 		}
 		pd->cmd_id = cmd->id;
-		memcpy(pd->cmd_data, cmd, sizeof(struct osdp_cmd));
+		(void) memcpy(pd->cmd_data, cmd, sizeof(struct osdp_cmd));
 		osdp_cmd_free(pd, cmd);
 		/* fall-thru */
 	case OSDP_CP_PHY_STATE_SEND_CMD:
@@ -736,7 +736,7 @@ int osdp_cp_send_cmd_output(int pd, stru
 	}
 
 	cmd->id = CMD_OUT;
-	memcpy(&cmd->output, p, sizeof(struct osdp_cmd_output));
+	(void) memcpy(&cmd->output, p, sizeof(struct osdp_cmd_output));
 	osdp_cmd_enqueue(TO_PD(ctx, pd), cmd);
 	return 0;
 }
@@ -761,7 +761,7 @@ int osdp_cp_send_cmd_led(int pd, struct 
 	}
 
 	cmd->id = CMD_LED;
-	memcpy(&cmd->led, p, sizeof(struct osdp_cmd_led));
+	(void) memcpy(&cmd->led, p, sizeof(struct osdp_cmd_led));
 	osdp_cmd_enqueue(TO_PD(ctx, pd), cmd);
 	return 0;
 }
@@ -786,7 +786,7 @@ int osdp_cp_send_cmd_buzzer(int pd, stru
 	}
 
 	cmd->id = CMD_BUZ;
-	memcpy(&cmd->buzzer, p, sizeof(struct osdp_cmd_buzzer));
+	(void) memcpy(&cmd->buzzer, p, sizeof(struct osdp_cmd_buzzer));
 	osdp_cmd_enqueue(TO_PD(ctx, pd), cmd);
 	return 0;
 }
@@ -811,7 +811,7 @@ int osdp_cp_send_cmd_text(int pd, struct
 	}
 
 	cmd->id = CMD_TEXT;
-	memcpy(&cmd->text, p, sizeof(struct osdp_cmd_text));
+	(void) memcpy(&cmd->text, p, sizeof(struct osdp_cmd_text));
 	osdp_cmd_enqueue(TO_PD(ctx, pd), cmd);
 	return 0;
 }
@@ -836,7 +836,7 @@ int osdp_cp_send_cmd_comset(int pd, stru
 	}
 
 	cmd->id = CMD_COMSET;
-	memcpy(&cmd->text, p, sizeof(struct osdp_cmd_comset));
+	(void) memcpy(&cmd->text, p, sizeof(struct osdp_cmd_comset));
 	osdp_cmd_enqueue(TO_PD(ctx, pd), cmd);
 	return 0;
 }
diff -u -p a/subsys/net/l2/ieee802154/ieee802154_security.c b/subsys/net/l2/ieee802154/ieee802154_security.c
--- a/subsys/net/l2/ieee802154/ieee802154_security.c
+++ b/subsys/net/l2/ieee802154/ieee802154_security.c
@@ -44,7 +44,7 @@ int ieee802154_security_setup_session(st
 	sec_ctx->level = level;
 
 	if (level > IEEE802154_SECURITY_LEVEL_NONE) {
-		memcpy(sec_ctx->key, key, key_len);
+		(void) memcpy(sec_ctx->key, key, key_len);
 		sec_ctx->key_len = key_len;
 		sec_ctx->key_mode = key_mode;
 
@@ -99,7 +99,7 @@ bool ieee802154_decrypt_auth(struct ieee
 	}
 
 	/* See Section 7.3.2 */
-	memcpy(nonce, src_ext_addr, IEEE802154_EXT_ADDR_LENGTH);
+	(void) memcpy(nonce, src_ext_addr, IEEE802154_EXT_ADDR_LENGTH);
 	nonce[8] = (uint8_t)(frame_counter >> 24);
 	nonce[9] = (uint8_t)(frame_counter >> 16);
 	nonce[10] = (uint8_t)(frame_counter >> 8);
@@ -144,7 +144,7 @@ bool ieee802154_encrypt_auth(struct ieee
 	}
 
 	/* See Section 7.3.2 */
-	memcpy(nonce, src_ext_addr, IEEE802154_EXT_ADDR_LENGTH);
+	(void) memcpy(nonce, src_ext_addr, IEEE802154_EXT_ADDR_LENGTH);
 	sys_put_be32(sec_ctx->frame_counter, &nonce[8]);
 	nonce[12] = sec_ctx->level;
 
diff -u -p a/subsys/net/l2/ieee802154/ieee802154_fragment.c b/subsys/net/l2/ieee802154/ieee802154_fragment.c
--- a/subsys/net/l2/ieee802154/ieee802154_fragment.c
+++ b/subsys/net/l2/ieee802154/ieee802154_fragment.c
@@ -134,7 +134,7 @@ static inline uint8_t copy_data(struct i
 
 	move = MIN(move, max);
 
-	memcpy(frame_buf->data + frame_buf->len, ctx->pos, move);
+	(void) memcpy(frame_buf->data + frame_buf->len, ctx->pos, move);
 
 	net_buf_add(frame_buf, move);
 
diff -u -p a/subsys/net/l2/ppp/ppp_l2.c b/subsys/net/l2/ppp/ppp_l2.c
--- a/subsys/net/l2/ppp/ppp_l2.c
+++ b/subsys/net/l2/ppp/ppp_l2.c
@@ -446,7 +446,7 @@ void net_ppp_init(struct net_if *iface)
 
 	NET_DBG("Initializing PPP L2 %p for iface %p", ctx, iface);
 
-	memset(ctx, 0, sizeof(*ctx));
+	(void) memset(ctx, 0, sizeof(*ctx));
 
 	ctx->ppp_l2_flags = NET_L2_MULTICAST | NET_L2_POINT_TO_POINT;
 	ctx->iface = iface;
diff -u -p a/subsys/net/l2/ppp/ppp_stats.c b/subsys/net/l2/ppp/ppp_stats.c
--- a/subsys/net/l2/ppp/ppp_stats.c
+++ b/subsys/net/l2/ppp/ppp_stats.c
@@ -43,7 +43,7 @@ static int ppp_stats_get(uint32_t mgmt_r
 		return -EINVAL;
 	}
 
-	memcpy(data, src, len);
+	(void) memcpy(data, src, len);
 
 	return 0;
 }
diff -u -p a/subsys/net/l2/ethernet/ethernet_mgmt.c b/subsys/net/l2/ethernet/ethernet_mgmt.c
--- a/subsys/net/l2/ethernet/ethernet_mgmt.c
+++ b/subsys/net/l2/ethernet/ethernet_mgmt.c
@@ -112,8 +112,8 @@ static int ethernet_set_config(uint32_t 
 			(void)net_if_ipv6_addr_rm(iface, &iid);
 		}
 
-		memcpy(&config.mac_address, &params->mac_address,
-		       sizeof(struct net_eth_addr));
+		(void) memcpy(&config.mac_address, &params->mac_address,
+				sizeof(struct net_eth_addr));
 		type = ETHERNET_CONFIG_TYPE_MAC_ADDRESS;
 	} else if (mgmt_request == NET_REQUEST_ETHERNET_SET_QAV_PARAM) {
 		if (!is_hw_caps_supported(dev, ETHERNET_QAV)) {
@@ -136,8 +136,8 @@ static int ethernet_set_config(uint32_t 
 			break;
 		}
 
-		memcpy(&config.qav_param, &params->qav_param,
-		       sizeof(struct ethernet_qav_param));
+		(void) memcpy(&config.qav_param, &params->qav_param,
+				sizeof(struct ethernet_qav_param));
 		type = ETHERNET_CONFIG_TYPE_QAV_PARAM;
 	} else if (mgmt_request == NET_REQUEST_ETHERNET_SET_PROMISC_MODE) {
 		if (!is_hw_caps_supported(dev, ETHERNET_PROMISC_MODE)) {
diff -u -p a/subsys/net/l2/ethernet/gptp/gptp_md.c b/subsys/net/l2/ethernet/gptp/gptp_md.c
--- a/subsys/net/l2/ethernet/gptp/gptp_md.c
+++ b/subsys/net/l2/ethernet/gptp/gptp_md.c
@@ -20,8 +20,8 @@ static void gptp_md_sync_prepare(struct 
 
 	hdr = GPTP_HDR(pkt);
 
-	memcpy(&hdr->port_id.clk_id, &sync_send->src_port_id.clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(&hdr->port_id.clk_id, &sync_send->src_port_id.clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	hdr->port_id.port_number = htons(port_number);
 
@@ -53,8 +53,8 @@ static void gptp_md_follow_up_prepare(st
 	hdr->correction_field += sync_send->follow_up_correction_field;
 	hdr->correction_field <<= 16;
 
-	memcpy(&hdr->port_id.clk_id, &sync_send->src_port_id.clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(&hdr->port_id.clk_id, &sync_send->src_port_id.clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	hdr->port_id.port_number = htons(port_number);
 
@@ -116,8 +116,8 @@ static int gptp_set_md_sync_receive(int 
 
 	sync_rcv->follow_up_correction_field =
 		ntohll(fup_hdr->correction_field);
-	memcpy(&sync_rcv->src_port_id, &sync_hdr->port_id,
-	       sizeof(struct gptp_port_identity));
+	(void) memcpy(&sync_rcv->src_port_id, &sync_hdr->port_id,
+			sizeof(struct gptp_port_identity));
 	sync_rcv->log_msg_interval = fup_hdr->log_msg_interval;
 	sync_rcv->precise_orig_ts._sec.high =
 		ntohs(fup->prec_orig_ts_secs_high);
diff -u -p a/subsys/net/lib/websocket/websocket.c b/subsys/net/lib/websocket/websocket.c
--- a/subsys/net/lib/websocket/websocket.c
+++ b/subsys/net/lib/websocket/websocket.c
@@ -299,10 +299,10 @@ int websocket_connect(int sock, struct w
 		goto out;
 	}
 
-	memcpy(sec_ws_key + sizeof("Sec-Websocket-Key: ") - 1 + olen,
-	       HTTP_CRLF, sizeof(HTTP_CRLF));
+	(void) memcpy(sec_ws_key + sizeof("Sec-Websocket-Key: ") - 1 + olen,
+			HTTP_CRLF, sizeof(HTTP_CRLF));
 
-	memset(&req, 0, sizeof(req));
+	(void) memset(&req, 0, sizeof(req));
 
 	req.method = HTTP_GET;
 	req.url = wreq->url;
@@ -321,10 +321,10 @@ int websocket_connect(int sock, struct w
 	 * so setup HTTP callbacks so that we will get the needed fields.
 	 */
 	if (ctx->http_cb) {
-		memcpy(&http_parser_settings, ctx->http_cb,
-		       sizeof(http_parser_settings));
+		(void) memcpy(&http_parser_settings, ctx->http_cb,
+				sizeof(http_parser_settings));
 	} else {
-		memset(&http_parser_settings, 0, sizeof(http_parser_settings));
+		(void) memset(&http_parser_settings, 0, sizeof(http_parser_settings));
 	}
 
 	http_parser_settings.on_header_field = on_header_field;
@@ -452,7 +452,7 @@ static int websocket_prepare_and_send(st
 	io_vector[1].iov_base = payload;
 	io_vector[1].iov_len = payload_len;
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 
 	msg.msg_iov = io_vector;
 	msg.msg_iovlen = ARRAY_SIZE(io_vector);
@@ -516,7 +516,7 @@ int websocket_send_msg(int ws_sock, cons
 	NET_DBG("[%p] Len %zd %s/%d/%s", ctx, payload_len, opcode2str(opcode),
 		mask, final ? "final" : "more");
 
-	memset(header, 0, sizeof(header));
+	(void) memset(header, 0, sizeof(header));
 
 	/* Is this the last packet? */
 	header[0] = final ? BIT(7) : 0;
@@ -563,7 +563,7 @@ int websocket_send_msg(int ws_sock, cons
 			return -ENOMEM;
 		}
 
-		memcpy(data_to_send, payload, payload_len);
+		(void) memcpy(data_to_send, payload, payload_len);
 
 		for (i = 0; i < payload_len; i++) {
 			data_to_send[i] ^=
@@ -694,8 +694,9 @@ int websocket_recv_msg(int ws_sock, uint
 		size_t input_len = MIN(ctx->tmp_buf_len - ctx->tmp_buf_pos,
 				       test_data->input_len);
 
-		memcpy(&ctx->tmp_buf[ctx->tmp_buf_pos], test_data->input_buf,
-		       input_len);
+		(void) memcpy(&ctx->tmp_buf[ctx->tmp_buf_pos],
+				test_data->input_buf,
+				input_len);
 		test_data->input_buf += input_len;
 		ret = input_len;
 #else
@@ -781,7 +782,7 @@ int websocket_recv_msg(int ws_sock, uint
 #if defined(CONFIG_NET_TEST)
 		size_t input_len = MIN(ctx->tmp_buf_len, test_data->input_len);
 
-		memcpy(ctx->tmp_buf, test_data->input_buf, input_len);
+		(void) memcpy(ctx->tmp_buf, test_data->input_buf, input_len);
 		test_data->input_buf += input_len;
 
 		ret = input_len;
diff -u -p a/subsys/net/lib/sockets/sockets_can.c b/subsys/net/lib/sockets/sockets_can.c
--- a/subsys/net/lib/sockets/sockets_can.c
+++ b/subsys/net/lib/sockets/sockets_can.c
@@ -227,7 +227,7 @@ ssize_t zcan_sendto_ctx(struct net_conte
 	}
 
 	if (dest_addr == NULL) {
-		memset(&can_addr, 0, sizeof(can_addr));
+		(void) memset(&can_addr, 0, sizeof(can_addr));
 
 		can_addr.can_ifindex = -1;
 		can_addr.can_family = AF_CAN;
diff -u -p a/subsys/net/lib/config/init.c b/subsys/net/lib/config/init.c
--- a/subsys/net/lib/config/init.c
+++ b/subsys/net/lib/config/init.c
@@ -208,9 +208,9 @@ static void ipv6_event_handler(struct ne
 		/* save the last added IP address for this interface */
 		for (i = NET_IF_MAX_IPV6_ADDR - 1; i >= 0; i--) {
 			if (ipv6->unicast[i].is_used) {
-				memcpy(&laddr,
-				       &ipv6->unicast[i].address.in6_addr,
-				       sizeof(laddr));
+				(void) memcpy(&laddr,
+						&ipv6->unicast[i].address.in6_addr,
+						sizeof(laddr));
 				break;
 			}
 		}
diff -u -p a/subsys/net/lib/tftp/tftp_client.c b/subsys/net/lib/tftp/tftp_client.c
--- a/subsys/net/lib/tftp/tftp_client.c
+++ b/subsys/net/lib/tftp/tftp_client.c
@@ -152,8 +152,8 @@ static int tftpc_process_resp(int sock, 
 	}
 
 	/* Perform the actual copy and update the index. */
-	memcpy(client->user_buf + tftpc_index,
-	       tftpc_buffer + TFTP_HEADER_SIZE, RECV_DATA_SIZE());
+	(void) memcpy(client->user_buf + tftpc_index,
+			tftpc_buffer + TFTP_HEADER_SIZE, RECV_DATA_SIZE());
 	tftpc_index += RECV_DATA_SIZE();
 
 	/* "block" of data received. */
diff -u -p a/subsys/net/lib/http/http_client.c b/subsys/net/lib/http/http_client.c
--- a/subsys/net/lib/http/http_client.c
+++ b/subsys/net/lib/http/http_client.c
@@ -167,7 +167,7 @@ static int on_status(struct http_parser 
 	uint16_t len;
 
 	len = MIN(length, sizeof(req->internal.response.http_status) - 1);
-	memcpy(req->internal.response.http_status, at, len);
+	(void) memcpy(req->internal.response.http_status, at, len);
 	req->internal.response.http_status[len] = 0;
 
 	NET_DBG("HTTP response status %d %s", parser->status_code,
@@ -220,7 +220,7 @@ static int on_header_value(struct http_p
 		if (length <= MAX_NUM_DIGITS - 1) {
 			long int num;
 
-			memcpy(str, at, length);
+			(void) memcpy(str, at, length);
 			str[length] = 0;
 
 			num = strtol(str, NULL, 10);
@@ -483,7 +483,7 @@ int http_client_req(int sock, struct htt
 		return -EINVAL;
 	}
 
-	memset(&req->internal.response, 0, sizeof(req->internal.response));
+	(void) memset(&req->internal.response, 0, sizeof(req->internal.response));
 
 	req->internal.response.http_cb = req->http_cb;
 	req->internal.response.cb = req->response;
diff -u -p a/subsys/net/lib/dns/mdns_responder.c b/subsys/net/lib/dns/mdns_responder.c
--- a/subsys/net/lib/dns/mdns_responder.c
+++ b/subsys/net/lib/dns/mdns_responder.c
@@ -177,7 +177,7 @@ static void add_answer(struct net_buf *q
 	UNALIGNED_PUT(htons(addr_len), query->data + offset);
 
 	offset += DNS_RDLENGTH_LEN;
-	memcpy(query->data + offset, addr, addr_len);
+	(void) memcpy(query->data + offset, addr, addr_len);
 }
 
 static int create_answer(struct net_context *ctx,
diff -u -p a/subsys/net/lib/tls_credentials/tls_credentials.c b/subsys/net/lib/tls_credentials/tls_credentials.c
--- a/subsys/net/lib/tls_credentials/tls_credentials.c
+++ b/subsys/net/lib/tls_credentials/tls_credentials.c
@@ -135,7 +135,7 @@ int tls_credential_get(sec_tag_t tag, en
 	}
 
 	*credlen = credential->len;
-	memcpy(cred, credential->buf, credential->len);
+	(void) memcpy(cred, credential->buf, credential->len);
 
 exit:
 	credentials_unlock();
diff -u -p a/subsys/net/ip/tcp2.c b/subsys/net/ip/tcp2.c
--- a/subsys/net/ip/tcp2.c
+++ b/subsys/net/ip/tcp2.c
@@ -128,7 +128,7 @@ static int tcp_endpoint_set(union tcp_en
 			struct net_ipv4_hdr *ip = NET_IPV4_HDR(pkt);
 			struct tcphdr *th = th_get(pkt);
 
-			memset(ep, 0, sizeof(*ep));
+			(void) memset(ep, 0, sizeof(*ep));
 
 			ep->sin.sin_port = src == TCP_EP_SRC ? th->th_sport :
 							       th->th_dport;
@@ -147,7 +147,7 @@ static int tcp_endpoint_set(union tcp_en
 			struct net_ipv6_hdr *ip = NET_IPV6_HDR(pkt);
 			struct tcphdr *th = th_get(pkt);
 
-			memset(ep, 0, sizeof(*ep));
+			(void) memset(ep, 0, sizeof(*ep));
 
 			ep->sin6.sin6_port = src == TCP_EP_SRC ? th->th_sport :
 								 th->th_dport;
@@ -328,7 +328,7 @@ static int tcp_conn_unref(struct tcp *co
 
 	sys_slist_find_and_remove(&tcp_conns, (sys_snode_t *)conn);
 
-	memset(conn, 0, sizeof(*conn));
+	(void) memset(conn, 0, sizeof(*conn));
 
 	k_mem_slab_free(&tcp_conns_slab, (void **)&conn);
 
@@ -600,7 +600,7 @@ static int tcp_header_add(struct tcp *co
 		return -ENOBUFS;
 	}
 
-	memset(th, 0, sizeof(struct tcphdr));
+	(void) memset(th, 0, sizeof(struct tcphdr));
 
 	th->th_sport = conn->src.sin.sin_port;
 	th->th_dport = conn->dst.sin.sin_port;
@@ -868,7 +868,7 @@ static struct tcp *tcp_conn_alloc(void)
 		goto out;
 	}
 
-	memset(conn, 0, sizeof(*conn));
+	(void) memset(conn, 0, sizeof(*conn));
 
 	k_mutex_init(&conn->lock);
 
@@ -1035,7 +1035,7 @@ static struct tcp *tcp_conn_new(struct n
 		log_strdup(net_sprint_addr(conn->dst.sa.sa_family,
 				(const void *)&conn->dst.sin.sin_addr)));
 
-	memcpy(&context->remote, &conn->dst, sizeof(context->remote));
+	(void) memcpy(&context->remote, &conn->dst, sizeof(context->remote));
 	context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
 
 	net_sin_ptr(&context->local)->sin_family = af;
@@ -1426,8 +1426,8 @@ int net_tcp_connect(struct net_context *
 		const struct in6_addr *ip6;
 
 	case AF_INET:
-		memset(&conn->src, 0, sizeof(struct sockaddr_in));
-		memset(&conn->dst, 0, sizeof(struct sockaddr_in));
+		(void) memset(&conn->src, 0, sizeof(struct sockaddr_in));
+		(void) memset(&conn->dst, 0, sizeof(struct sockaddr_in));
 
 		conn->src.sa.sa_family = AF_INET;
 		conn->dst.sa.sa_family = AF_INET;
@@ -1448,8 +1448,8 @@ int net_tcp_connect(struct net_context *
 		break;
 
 	case AF_INET6:
-		memset(&conn->src, 0, sizeof(struct sockaddr_in6));
-		memset(&conn->dst, 0, sizeof(struct sockaddr_in6));
+		(void) memset(&conn->src, 0, sizeof(struct sockaddr_in6));
+		(void) memset(&conn->dst, 0, sizeof(struct sockaddr_in6));
 
 		conn->src.sin6.sin6_family = AF_INET6;
 		conn->dst.sin6.sin6_family = AF_INET6;
diff -u -p a/subsys/net/ip/udp.c b/subsys/net/ip/udp.c
--- a/subsys/net/ip/udp.c
+++ b/subsys/net/ip/udp.c
@@ -114,7 +114,7 @@ struct net_udp_hdr *net_udp_set_hdr(stru
 		goto out;
 	}
 
-	memcpy(udp_hdr, hdr, sizeof(struct net_udp_hdr));
+	(void) memcpy(udp_hdr, hdr, sizeof(struct net_udp_hdr));
 
 	net_pkt_set_data(pkt, &udp_access);
 out:
diff -u -p a/subsys/net/ip/connection.c b/subsys/net/ip/connection.c
--- a/subsys/net/ip/connection.c
+++ b/subsys/net/ip/connection.c
@@ -266,8 +266,8 @@ int net_conn_register(uint16_t proto, ui
 	if (remote_addr) {
 		if (IS_ENABLED(CONFIG_NET_IPV6) &&
 		    remote_addr->sa_family == AF_INET6) {
-			memcpy(&conn->remote_addr, remote_addr,
-			       sizeof(struct sockaddr_in6));
+			(void) memcpy(&conn->remote_addr, remote_addr,
+					sizeof(struct sockaddr_in6));
 
 			if (!net_ipv6_is_addr_unspecified(
 				    &net_sin6(remote_addr)->
@@ -276,8 +276,8 @@ int net_conn_register(uint16_t proto, ui
 			}
 		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 			   remote_addr->sa_family == AF_INET) {
-			memcpy(&conn->remote_addr, remote_addr,
-			       sizeof(struct sockaddr_in));
+			(void) memcpy(&conn->remote_addr, remote_addr,
+					sizeof(struct sockaddr_in));
 
 			if (net_sin(remote_addr)->sin_addr.s_addr) {
 				flags |= NET_CONN_REMOTE_ADDR_SPEC;
@@ -293,8 +293,8 @@ int net_conn_register(uint16_t proto, ui
 	if (local_addr) {
 		if (IS_ENABLED(CONFIG_NET_IPV6) &&
 		    local_addr->sa_family == AF_INET6) {
-			memcpy(&conn->local_addr, local_addr,
-			       sizeof(struct sockaddr_in6));
+			(void) memcpy(&conn->local_addr, local_addr,
+					sizeof(struct sockaddr_in6));
 
 			if (!net_ipv6_is_addr_unspecified(
 				    &net_sin6(local_addr)->
@@ -303,20 +303,20 @@ int net_conn_register(uint16_t proto, ui
 			}
 		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
 			   local_addr->sa_family == AF_INET) {
-			memcpy(&conn->local_addr, local_addr,
-			       sizeof(struct sockaddr_in));
+			(void) memcpy(&conn->local_addr, local_addr,
+					sizeof(struct sockaddr_in));
 
 			if (net_sin(local_addr)->sin_addr.s_addr) {
 				flags |= NET_CONN_LOCAL_ADDR_SPEC;
 			}
 		} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) &&
 			   local_addr->sa_family == AF_CAN) {
-			memcpy(&conn->local_addr, local_addr,
-			       sizeof(struct sockaddr_can));
+			(void) memcpy(&conn->local_addr, local_addr,
+					sizeof(struct sockaddr_can));
 		} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET) &&
 			   local_addr->sa_family == AF_PACKET) {
-			memcpy(&conn->local_addr, local_addr,
-			       sizeof(struct sockaddr_ll));
+			(void) memcpy(&conn->local_addr, local_addr,
+					sizeof(struct sockaddr_ll));
 		} else {
 			NET_ERR("Local address family not set");
 			goto error;
diff -u -p a/subsys/net/ip/net_shell.c b/subsys/net/ip/net_shell.c
--- a/subsys/net/ip/net_shell.c
+++ b/subsys/net/ip/net_shell.c
@@ -3766,7 +3766,7 @@ static void get_my_ipv6_addr(struct net_
 	my6addr = net_if_ipv6_select_src_addr(iface,
 					      &net_sin6(myaddr)->sin6_addr);
 
-	memcpy(&net_sin6(myaddr)->sin6_addr, my6addr, sizeof(struct in6_addr));
+	(void) memcpy(&net_sin6(myaddr)->sin6_addr, my6addr, sizeof(struct in6_addr));
 
 	net_sin6(myaddr)->sin6_port = 0U; /* let the IP stack to select */
 #endif
@@ -3777,9 +3777,9 @@ static void get_my_ipv4_addr(struct net_
 {
 #if defined(CONFIG_NET_NATIVE_IPV4)
 	/* Just take the first IPv4 address of an interface. */
-	memcpy(&net_sin(myaddr)->sin_addr,
-	       &iface->config.ip.ipv4->unicast[0].address.in_addr,
-	       sizeof(struct in_addr));
+	(void) memcpy(&net_sin(myaddr)->sin_addr,
+			&iface->config.ip.ipv4->unicast[0].address.in_addr,
+			sizeof(struct in_addr));
 
 	net_sin(myaddr)->sin_port = 0U; /* let the IP stack to select */
 #endif
@@ -4647,7 +4647,7 @@ static void nbr_populate_addresses(void)
 static char *set_nbr_address(size_t idx)
 {
 	if (idx == 0) {
-		memset(nbr_address_buffer, 0, sizeof(nbr_address_buffer));
+		(void) memset(nbr_address_buffer, 0, sizeof(nbr_address_buffer));
 		nbr_populate_addresses();
 	}
 
diff -u -p a/subsys/dfu/boot/mcuboot.c b/subsys/dfu/boot/mcuboot.c
--- a/subsys/dfu/boot/mcuboot.c
+++ b/subsys/dfu/boot/mcuboot.c
@@ -300,7 +300,7 @@ static int boot_write_trailer_byte(const
 	align = flash_area_align(fa);
 	assert(align <= BOOT_MAX_ALIGN);
 	erased_val = flash_area_erased_val(fa);
-	memset(buf, erased_val, BOOT_MAX_ALIGN);
+	(void) memset(buf, erased_val, BOOT_MAX_ALIGN);
 	buf[0] = val;
 
 	rc = flash_area_write(fa, off, buf, align);
diff -u -p a/subsys/shell/shell_history.c b/subsys/shell/shell_history.c
--- a/subsys/shell/shell_history.c
+++ b/subsys/shell/shell_history.c
@@ -78,7 +78,7 @@ bool shell_history_get(struct shell_hist
 	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
 
 	if (l_item) {
-		memcpy(dst, h_item->data, h_item->len);
+		(void) memcpy(dst, h_item->data, h_item->len);
 		*len = h_item->len;
 		dst[*len] = '\0';
 		return true;
@@ -94,7 +94,7 @@ static void add_to_head(struct shell_his
 {
 	item->len = len;
 	item->padding = padding;
-	memcpy(item->data, src, len);
+	(void) memcpy(item->data, src, len);
 	sys_dlist_prepend(&history->list, &item->dnode);
 }
 
diff -u -p a/subsys/shell/shell_telnet.c b/subsys/shell/shell_telnet.c
--- a/subsys/shell/shell_telnet.c
+++ b/subsys/shell/shell_telnet.c
@@ -337,7 +337,7 @@ static int init(const struct shell_trans
 		return err;
 	}
 
-	memset(sh_telnet, 0, sizeof(struct shell_telnet));
+	(void) memset(sh_telnet, 0, sizeof(struct shell_telnet));
 
 	sh_telnet->shell_handler = evt_handler;
 	sh_telnet->shell_context = context;
@@ -399,7 +399,7 @@ static int write(const struct shell_tran
 			copy_len = length - *cnt;
 		}
 
-		memcpy(lb->buf + lb->len, (uint8_t *)data + *cnt, copy_len);
+		(void) memcpy(lb->buf + lb->len, (uint8_t *)data + *cnt, copy_len);
 		lb->len += copy_len;
 
 		/* Send the data immediately if the buffer is full or line feed
diff -u -p a/subsys/usb/class/cdc_acm.c b/subsys/usb/class/cdc_acm.c
--- a/subsys/usb/class/cdc_acm.c
+++ b/subsys/usb/class/cdc_acm.c
@@ -236,8 +236,8 @@ int cdc_acm_class_handle_req(struct usb_
 	switch (pSetup->bRequest) {
 	case SET_LINE_CODING:
 		rate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
-		memcpy(&dev_data->line_coding,
-		       *data, sizeof(dev_data->line_coding));
+		(void) memcpy(&dev_data->line_coding,
+				*data, sizeof(dev_data->line_coding));
 		new_rate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
 		LOG_DBG("CDC_SET_LINE_CODING %d %d %d %d",
 			new_rate,
@@ -410,7 +410,7 @@ static void cdc_acm_reset_port(struct cd
 				CDC_ACM_DEFAULT_BAUDRATE;
 	dev_data->serial_state = 0;
 	dev_data->line_state = 0;
-	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
+	(void) memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
 }
 
 static void cdc_acm_do_cb(struct cdc_acm_dev_data_t *dev_data,
diff -u -p a/subsys/usb/class/netusb/function_eem.c b/subsys/usb/class/netusb/function_eem.c
--- a/subsys/usb/class/netusb/function_eem.c
+++ b/subsys/usb/class/netusb/function_eem.c
@@ -125,7 +125,7 @@ static int eem_send(struct net_pkt *pkt)
 	b_idx += len - sizeof(sentinel);
 
 	/* Add crc-sentinel */
-	memcpy(&tx_buf[b_idx], sentinel, sizeof(sentinel));
+	(void) memcpy(&tx_buf[b_idx], sentinel, sizeof(sentinel));
 	b_idx += sizeof(sentinel);
 
 	/* transfer data to host */
diff -u -p a/subsys/canbus/canopen/CO_driver.c b/subsys/canbus/canopen/CO_driver.c
--- a/subsys/canbus/canopen/CO_driver.c
+++ b/subsys/canbus/canopen/CO_driver.c
@@ -90,7 +90,7 @@ static void canopen_rx_isr_callback(stru
 
 	rxMsg.ident = msg->std_id;
 	rxMsg.DLC = msg->dlc;
-	memcpy(rxMsg.data, msg->data, msg->dlc);
+	(void) memcpy(rxMsg.data, msg->data, msg->dlc);
 	buffer->pFunct(buffer->object, &rxMsg);
 }
 
@@ -129,7 +129,7 @@ static void canopen_tx_retry(struct k_wo
 			msg.std_id = buffer->ident;
 			msg.dlc = buffer->DLC;
 			msg.rtr = (buffer->rtr ? 1 : 0);
-			memcpy(msg.data, buffer->data, buffer->DLC);
+			(void) memcpy(msg.data, buffer->data, buffer->DLC);
 
 			err = can_send(CANmodule->dev, &msg, K_NO_WAIT,
 				       canopen_tx_isr_callback, CANmodule);
@@ -342,7 +342,7 @@ CO_ReturnError_t CO_CANsend(CO_CANmodule
 	msg.std_id = buffer->ident;
 	msg.dlc = buffer->DLC;
 	msg.rtr = (buffer->rtr ? 1 : 0);
-	memcpy(msg.data, buffer->data, buffer->DLC);
+	(void) memcpy(msg.data, buffer->data, buffer->DLC);
 
 	err = can_send(CANmodule->dev, &msg, K_NO_WAIT, canopen_tx_isr_callback,
 		       CANmodule);
diff -u -p a/subsys/canbus/canopen/canopen_storage.c b/subsys/canbus/canopen/canopen_storage.c
--- a/subsys/canbus/canopen/canopen_storage.c
+++ b/subsys/canbus/canopen/canopen_storage.c
@@ -39,7 +39,7 @@ static CO_SDO_abortCode_t canopen_odf_10
 	}
 
 	/* Preserve old value */
-	memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
+	(void) memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
 
 	if (odf_arg->subIndex != 1U) {
 		return CO_SDO_AB_NONE;
@@ -77,7 +77,7 @@ static CO_SDO_abortCode_t canopen_odf_10
 	}
 
 	/* Preserve old value */
-	memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
+	(void) memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
 
 	if (odf_arg->subIndex < 1U) {
 		return CO_SDO_AB_NONE;
@@ -142,8 +142,8 @@ static int canopen_settings_set(const ch
 		} else {
 			if ((eeprom.FirstWord == CO_OD_FIRST_LAST_WORD) &&
 			    (eeprom.LastWord == CO_OD_FIRST_LAST_WORD)) {
-				memcpy(&CO_OD_EEPROM, &eeprom,
-				       sizeof(CO_OD_EEPROM));
+				(void) memcpy(&CO_OD_EEPROM, &eeprom,
+						sizeof(CO_OD_EEPROM));
 				LOG_DBG("restored object dictionary EEPROM"
 					" entries");
 			} else {
@@ -165,7 +165,7 @@ static int canopen_settings_set(const ch
 		} else {
 			if ((rom.FirstWord == CO_OD_FIRST_LAST_WORD) &&
 			    (rom.LastWord == CO_OD_FIRST_LAST_WORD)) {
-				memcpy(&CO_OD_ROM, &rom, sizeof(CO_OD_ROM));
+				(void) memcpy(&CO_OD_ROM, &rom, sizeof(CO_OD_ROM));
 				LOG_DBG("restored object dictionary ROM"
 					" entries");
 			} else {
diff -u -p a/subsys/bluetooth/mesh/cdb.c b/subsys/bluetooth/mesh/cdb.c
--- a/subsys/bluetooth/mesh/cdb.c
+++ b/subsys/bluetooth/mesh/cdb.c
@@ -122,7 +122,7 @@ int bt_mesh_cdb_create(const uint8_t key
 		return -ENOMEM;
 	}
 
-	memcpy(sub->keys[0].net_key, key, 16);
+	(void) memcpy(sub->keys[0].net_key, key, 16);
 	bt_mesh_cdb.iv_index = 0;
 
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
@@ -209,7 +209,7 @@ void bt_mesh_cdb_subnet_del(struct bt_me
 	}
 
 	sub->net_idx = BT_MESH_KEY_UNUSED;
-	memset(sub->keys, 0, sizeof(sub->keys));
+	(void) memset(sub->keys, 0, sizeof(sub->keys));
 }
 
 struct bt_mesh_cdb_subnet *bt_mesh_cdb_subnet_get(uint16_t net_idx)
@@ -265,7 +265,7 @@ struct bt_mesh_cdb_node *bt_mesh_cdb_nod
 		struct bt_mesh_cdb_node *node = &bt_mesh_cdb.nodes[i];
 
 		if (node->addr == BT_MESH_ADDR_UNASSIGNED) {
-			memcpy(node->uuid, uuid, 16);
+			(void) memcpy(node->uuid, uuid, 16);
 			node->addr = addr;
 			node->num_elem = num_elem;
 			node->net_idx = net_idx;
@@ -286,7 +286,7 @@ void bt_mesh_cdb_node_del(struct bt_mesh
 	}
 
 	node->addr = BT_MESH_ADDR_UNASSIGNED;
-	memset(node->dev_key, 0, sizeof(node->dev_key));
+	(void) memset(node->dev_key, 0, sizeof(node->dev_key));
 }
 
 struct bt_mesh_cdb_node *bt_mesh_cdb_node_get(uint16_t addr)
@@ -357,7 +357,7 @@ void bt_mesh_cdb_app_key_del(struct bt_m
 	}
 
 	key->net_idx = BT_MESH_ADDR_UNASSIGNED;
-	memset(key->keys, 0, sizeof(key->keys));
+	(void) memset(key->keys, 0, sizeof(key->keys));
 }
 
 struct bt_mesh_cdb_app_key *bt_mesh_cdb_app_key_get(uint16_t app_idx)
diff -u -p a/subsys/bluetooth/mesh/settings.c b/subsys/bluetooth/mesh/settings.c
--- a/subsys/bluetooth/mesh/settings.c
+++ b/subsys/bluetooth/mesh/settings.c
@@ -205,7 +205,7 @@ static int net_set(const char *name, siz
 		return err;
 	}
 
-	memcpy(bt_mesh.dev_key, net.dev_key, sizeof(bt_mesh.dev_key));
+	(void) memcpy(bt_mesh.dev_key, net.dev_key, sizeof(bt_mesh.dev_key));
 	bt_mesh_comp_provision(net.primary_addr);
 
 	BT_DBG("Provisioned with primary address 0x%04x", net.primary_addr);
@@ -396,8 +396,8 @@ static int net_key_set(const char *name,
 
 		sub->kr_flag = key.kr_flag;
 		sub->kr_phase = key.kr_phase;
-		memcpy(sub->keys[0].net, &key.val[0], 16);
-		memcpy(sub->keys[1].net, &key.val[1], 16);
+		(void) memcpy(sub->keys[0].net, &key.val[0], 16);
+		(void) memcpy(sub->keys[1].net, &key.val[1], 16);
 
 		return 0;
 	}
@@ -417,8 +417,8 @@ static int net_key_set(const char *name,
 	sub->net_idx = net_idx;
 	sub->kr_flag = key.kr_flag;
 	sub->kr_phase = key.kr_phase;
-	memcpy(sub->keys[0].net, &key.val[0], 16);
-	memcpy(sub->keys[1].net, &key.val[1], 16);
+	(void) memcpy(sub->keys[0].net, &key.val[0], 16);
+	(void) memcpy(sub->keys[1].net, &key.val[1], 16);
 
 	BT_DBG("NetKeyIndex 0x%03x recovered from storage", net_idx);
 
@@ -471,8 +471,8 @@ static int app_key_set(const char *name,
 	app->net_idx = key.net_idx;
 	app->app_idx = app_idx;
 	app->updated = key.updated;
-	memcpy(app->keys[0].val, key.val[0], 16);
-	memcpy(app->keys[1].val, key.val[1], 16);
+	(void) memcpy(app->keys[0].val, key.val[0], 16);
+	(void) memcpy(app->keys[1].val, key.val[1], 16);
 
 	bt_mesh_app_id(app->keys[0].val, &app->keys[0].id);
 	bt_mesh_app_id(app->keys[1].val, &app->keys[1].id);
@@ -773,7 +773,7 @@ static int va_set(const char *name, size
 		return -ENOBUFS;
 	}
 
-	memcpy(lab->uuid, va.uuid, 16);
+	(void) memcpy(lab->uuid, va.uuid, 16);
 	lab->addr = va.addr;
 	lab->ref = va.ref;
 
@@ -861,8 +861,8 @@ static int cdb_node_set(const char *name
 		atomic_set_bit(node->flags, BT_MESH_CDB_NODE_CONFIGURED);
 	}
 
-	memcpy(node->uuid, val.uuid, 16);
-	memcpy(node->dev_key, val.dev_key, 16);
+	(void) memcpy(node->uuid, val.uuid, 16);
+	(void) memcpy(node->dev_key, val.dev_key, 16);
 
 	BT_DBG("Node 0x%04x recovered from storage", addr);
 
@@ -908,8 +908,8 @@ static int cdb_subnet_set(const char *na
 
 		sub->kr_flag = key.kr_flag;
 		sub->kr_phase = key.kr_phase;
-		memcpy(sub->keys[0].net_key, &key.val[0], 16);
-		memcpy(sub->keys[1].net_key, &key.val[1], 16);
+		(void) memcpy(sub->keys[0].net_key, &key.val[0], 16);
+		(void) memcpy(sub->keys[1].net_key, &key.val[1], 16);
 
 		return 0;
 	}
@@ -922,8 +922,8 @@ static int cdb_subnet_set(const char *na
 
 	sub->kr_flag = key.kr_flag;
 	sub->kr_phase = key.kr_phase;
-	memcpy(sub->keys[0].net_key, &key.val[0], 16);
-	memcpy(sub->keys[1].net_key, &key.val[1], 16);
+	(void) memcpy(sub->keys[0].net_key, &key.val[0], 16);
+	(void) memcpy(sub->keys[1].net_key, &key.val[1], 16);
 
 	BT_DBG("NetKeyIndex 0x%03x recovered from storage", net_idx);
 
@@ -973,8 +973,8 @@ static int cdb_app_key_set(const char *n
 		return -ENOMEM;
 	}
 
-	memcpy(app->keys[0].app_key, key.val[0], 16);
-	memcpy(app->keys[1].app_key, key.val[1], 16);
+	(void) memcpy(app->keys[0].app_key, key.val[0], 16);
+	(void) memcpy(app->keys[1].app_key, key.val[1], 16);
 
 	BT_DBG("AppKeyIndex 0x%03x recovered from storage", app_idx);
 
@@ -1260,7 +1260,7 @@ static void store_pending_net(void)
 	       bt_hex(bt_mesh.dev_key, 16));
 
 	net.primary_addr = bt_mesh_primary_addr();
-	memcpy(net.dev_key, bt_mesh.dev_key, 16);
+	(void) memcpy(net.dev_key, bt_mesh.dev_key, 16);
 
 	err = settings_save_one("bt/mesh/Net", &net, sizeof(net));
 	if (err) {
@@ -1499,8 +1499,8 @@ static void store_net_key(struct bt_mesh
 	BT_DBG("NetKeyIndex 0x%03x NetKey %s", sub->net_idx,
 	       bt_hex(sub->keys[0].net, 16));
 
-	memcpy(&key.val[0], sub->keys[0].net, 16);
-	memcpy(&key.val[1], sub->keys[1].net, 16);
+	(void) memcpy(&key.val[0], sub->keys[0].net, 16);
+	(void) memcpy(&key.val[1], sub->keys[1].net, 16);
 	key.kr_flag = sub->kr_flag;
 	key.kr_phase = sub->kr_phase;
 
@@ -1522,8 +1522,8 @@ static void store_app_key(struct bt_mesh
 
 	key.net_idx = app->net_idx;
 	key.updated = app->updated;
-	memcpy(key.val[0], app->keys[0].val, 16);
-	memcpy(key.val[1], app->keys[1].val, 16);
+	(void) memcpy(key.val[0], app->keys[0].val, 16);
+	(void) memcpy(key.val[1], app->keys[1].val, 16);
 
 	snprintk(path, sizeof(path), "bt/mesh/AppKey/%x", app->app_idx);
 
@@ -1626,8 +1626,8 @@ static void store_cdb_node(const struct 
 		val.flags |= F_NODE_CONFIGURED;
 	}
 
-	memcpy(val.uuid, node->uuid, 16);
-	memcpy(val.dev_key, node->dev_key, 16);
+	(void) memcpy(val.uuid, node->uuid, 16);
+	(void) memcpy(val.dev_key, node->dev_key, 16);
 
 	snprintk(path, sizeof(path), "bt/mesh/cdb/Node/%x", node->addr);
 
@@ -1694,8 +1694,8 @@ static void store_cdb_subnet(const struc
 	BT_DBG("NetKeyIndex 0x%03x NetKey %s", sub->net_idx,
 	       bt_hex(sub->keys[0].net_key, 16));
 
-	memcpy(&key.val[0], sub->keys[0].net_key, 16);
-	memcpy(&key.val[1], sub->keys[1].net_key, 16);
+	(void) memcpy(&key.val[0], sub->keys[0].net_key, 16);
+	(void) memcpy(&key.val[1], sub->keys[1].net_key, 16);
 	key.kr_flag = sub->kr_flag;
 	key.kr_phase = sub->kr_phase;
 
@@ -1733,8 +1733,8 @@ static void store_cdb_app_key(const stru
 
 	key.net_idx = app->net_idx;
 	key.updated = false;
-	memcpy(key.val[0], app->keys[0].app_key, 16);
-	memcpy(key.val[1], app->keys[1].app_key, 16);
+	(void) memcpy(key.val[0], app->keys[0].app_key, 16);
+	(void) memcpy(key.val[1], app->keys[1].app_key, 16);
 
 	snprintk(path, sizeof(path), "bt/mesh/cdb/AppKey/%x", app->app_idx);
 
@@ -1973,7 +1973,7 @@ static void store_pending_va(void)
 		} else {
 			va.ref = lab->ref;
 			va.addr = lab->addr;
-			memcpy(va.uuid, lab->uuid, 16);
+			(void) memcpy(va.uuid, lab->uuid, 16);
 
 			err = settings_save_one(path, &va, sizeof(va));
 		}
diff -u -p a/subsys/bluetooth/mesh/cfg_srv.c b/subsys/bluetooth/mesh/cfg_srv.c
--- a/subsys/bluetooth/mesh/cfg_srv.c
+++ b/subsys/bluetooth/mesh/cfg_srv.c
@@ -418,7 +418,7 @@ static uint8_t app_key_set(uint16_t net_
 
 	key->net_idx = net_idx;
 	key->app_idx = app_idx;
-	memcpy(keys->val, val, 16);
+	(void) memcpy(keys->val, val, 16);
 
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 		BT_DBG("Storing AppKey persistently");
@@ -929,9 +929,9 @@ static void send_mod_pub_status(struct b
 	}
 
 	if (vnd) {
-		memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
+		(void) memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
 	} else {
-		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
+		(void) memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
 	}
 
 	if (bt_mesh_model_send(cfg_mod, ctx, &msg, NULL, NULL)) {
@@ -1113,7 +1113,7 @@ static uint8_t va_add(uint8_t *label_uui
 
 	free_slot->ref = 1U;
 	free_slot->addr = *addr;
-	memcpy(free_slot->uuid, label_uuid, 16);
+	(void) memcpy(free_slot->uuid, label_uuid, 16);
 	va_store(free_slot);
 
 	return STATUS_SUCCESS;
@@ -1325,9 +1325,9 @@ static void send_mod_sub_status(struct b
 	net_buf_simple_add_le16(&msg, sub_addr);
 
 	if (vnd) {
-		memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
+		(void) memcpy(net_buf_simple_add(&msg, 4), mod_id, 4);
 	} else {
-		memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
+		(void) memcpy(net_buf_simple_add(&msg, 2), mod_id, 2);
 	}
 
 	if (bt_mesh_model_send(model, ctx, &msg, NULL, NULL)) {
@@ -2431,9 +2431,9 @@ static void create_mod_app_status(struct
 	net_buf_simple_add_le16(msg, app_idx);
 
 	if (vnd) {
-		memcpy(net_buf_simple_add(msg, 4), mod_id, 4);
+		(void) memcpy(net_buf_simple_add(msg, 4), mod_id, 4);
 	} else {
-		memcpy(net_buf_simple_add(msg, 2), mod_id, 2);
+		(void) memcpy(net_buf_simple_add(msg, 2), mod_id, 2);
 	}
 }
 
@@ -2911,8 +2911,9 @@ static void hb_pub_send_status(struct bt
 	net_buf_simple_add_u8(&msg, status);
 
 	if (orig_msg) {
-		memcpy(net_buf_simple_add(&msg, sizeof(*orig_msg)), orig_msg,
-		       sizeof(*orig_msg));
+		(void) memcpy(net_buf_simple_add(&msg, sizeof(*orig_msg)),
+				orig_msg,
+				sizeof(*orig_msg));
 		goto send;
 	}
 
diff -u -p a/subsys/bluetooth/host/sdp.c b/subsys/bluetooth/host/sdp.c
--- a/subsys/bluetooth/host/sdp.c
+++ b/subsys/bluetooth/host/sdp.c
@@ -372,7 +372,7 @@ static uint32_t search_uuid(struct bt_sd
 			}
 		} else if (seq_size == 16U) {
 			u.uuid.type = BT_UUID_TYPE_128;
-			memcpy(u.u128.val, cur_elem, seq_size);
+			(void) memcpy(u.u128.val, cur_elem, seq_size);
 			if (!bt_uuid_cmp(&u.uuid, uuid)) {
 				*found = true;
 			}
@@ -1813,8 +1813,8 @@ static int sdp_client_receive(struct bt_
 		 */
 		if (cstate->length) {
 			/* Cache original Continuation State in context */
-			memcpy(&session->cstate, cstate,
-			       sizeof(struct bt_sdp_pdu_cstate));
+			(void) memcpy(&session->cstate, cstate,
+					sizeof(struct bt_sdp_pdu_cstate));
 
 			net_buf_pull(buf, cstate->length +
 				     sizeof(cstate->length));
@@ -2341,9 +2341,9 @@ static int sdp_get_uuid_data(const struc
 		/* check DTD and get stacked UUID value */
 		switch (p[0]) {
 		case BT_SDP_UUID16:
-			memcpy(&pd->uuid16,
-			       BT_UUID_DECLARE_16(sys_get_be16(++p)),
-			       sizeof(struct bt_uuid_16));
+			(void) memcpy(&pd->uuid16,
+					BT_UUID_DECLARE_16(sys_get_be16(++p)),
+					sizeof(struct bt_uuid_16));
 			p += sizeof(uint16_t);
 			left -= sizeof(uint16_t);
 			break;
@@ -2353,9 +2353,9 @@ static int sdp_get_uuid_data(const struc
 				return -EMSGSIZE;
 			}
 
-			memcpy(&pd->uuid32,
-			       BT_UUID_DECLARE_32(sys_get_be32(++p)),
-			       sizeof(struct bt_uuid_32));
+			(void) memcpy(&pd->uuid32,
+					BT_UUID_DECLARE_32(sys_get_be32(++p)),
+					sizeof(struct bt_uuid_32));
 			p += sizeof(uint32_t);
 			left -= sizeof(uint32_t);
 			break;
diff -u -p a/subsys/bluetooth/host/conn.c b/subsys/bluetooth/host/conn.c
--- a/subsys/bluetooth/host/conn.c
+++ b/subsys/bluetooth/host/conn.c
@@ -485,7 +485,7 @@ struct bt_conn *bt_conn_create_br(const 
 
 	(void)memset(cp, 0, sizeof(*cp));
 
-	memcpy(&cp->bdaddr, peer, sizeof(cp->bdaddr));
+	(void) memcpy(&cp->bdaddr, peer, sizeof(cp->bdaddr));
 	cp->packet_type = sys_cpu_to_le16(0xcc18); /* DM1 DH1 DM3 DH5 DM5 DH5 */
 	cp->pscan_rep_mode = 0x02; /* R2 */
 	cp->allow_role_switch = param->allow_role_switch ? 0x01 : 0x00;
@@ -659,7 +659,7 @@ static int bt_hci_connect_br_cancel(stru
 	}
 
 	cp = net_buf_add(buf, sizeof(*cp));
-	memcpy(&cp->bdaddr, &conn->br.dst, sizeof(cp->bdaddr));
+	(void) memcpy(&cp->bdaddr, &conn->br.dst, sizeof(cp->bdaddr));
 
 	err = bt_hci_cmd_send_sync(BT_HCI_OP_CONNECT_CANCEL, buf, &rsp);
 	if (err) {
@@ -709,10 +709,10 @@ int bt_conn_le_start_encryption(struct b
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	cp->handle = sys_cpu_to_le16(conn->handle);
-	memcpy(&cp->rand, rand, sizeof(cp->rand));
-	memcpy(&cp->ediv, ediv, sizeof(cp->ediv));
+	(void) memcpy(&cp->rand, rand, sizeof(cp->rand));
+	(void) memcpy(&cp->ediv, ediv, sizeof(cp->ediv));
 
-	memcpy(cp->ltk, ltk, len);
+	(void) memcpy(cp->ltk, ltk, len);
 	if (len < sizeof(cp->ltk)) {
 		(void)memset(cp->ltk + len, 0, sizeof(cp->ltk) - len);
 	}
diff -u -p a/subsys/bluetooth/host/keys.c b/subsys/bluetooth/host/keys.c
--- a/subsys/bluetooth/host/keys.c
+++ b/subsys/bluetooth/host/keys.c
@@ -360,7 +360,7 @@ static int keys_set(const char *name, si
 			    len == BT_KEYS_STORAGE_LEN_COMPAT) {
 				BT_WARN("Keys for %s have no aging counter",
 					bt_addr_le_str(&addr));
-				memcpy(keys->storage_start, val, len);
+				(void) memcpy(keys->storage_start, val, len);
 				continue;
 			}
 
@@ -371,7 +371,7 @@ static int keys_set(const char *name, si
 			return -EINVAL;
 		} while (0);
 	} else {
-		memcpy(keys->storage_start, val, len);
+		(void) memcpy(keys->storage_start, val, len);
 	}
 
 	BT_DBG("Successfully restored keys for %s", bt_addr_le_str(&addr));
diff -u -p a/subsys/bluetooth/host/att.c b/subsys/bluetooth/host/att.c
--- a/subsys/bluetooth/host/att.c
+++ b/subsys/bluetooth/host/att.c
@@ -754,8 +754,9 @@ static uint8_t find_info_cb(const struct
 		/* Fast forward to next item position */
 		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
 		data->info128->handle = sys_cpu_to_le16(handle);
-		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
-		       sizeof(data->info128->uuid));
+		(void) memcpy(data->info128->uuid,
+				BT_UUID_128(attr->uuid)->val,
+				sizeof(data->info128->uuid));
 
 		if (chan->chan.tx.mtu - data->buf->len >
 		    sizeof(*data->info128)) {
@@ -1856,7 +1857,7 @@ static uint8_t att_prep_write_rsp(struct
 	rsp->handle = sys_cpu_to_le16(handle);
 	rsp->offset = sys_cpu_to_le16(offset);
 	net_buf_add(data.buf, len);
-	memcpy(rsp->value, value, len);
+	(void) memcpy(rsp->value, value, len);
 
 	bt_att_chan_send_rsp(chan, data.buf, chan_rsp_sent);
 
@@ -2962,7 +2963,7 @@ struct bt_att_req *bt_att_req_alloc(k_ti
 
 	BT_DBG("req %p", req);
 
-	memset(req, 0, sizeof(*req));
+	(void) memset(req, 0, sizeof(*req));
 
 	return req;
 }
diff -u -p a/subsys/bluetooth/shell/bredr.c b/subsys/bluetooth/shell/bredr.c
--- a/subsys/bluetooth/shell/bredr.c
+++ b/subsys/bluetooth/shell/bredr.c
@@ -130,9 +130,9 @@ static void br_device_found(const bt_add
 		case BT_DATA_NAME_SHORTENED:
 		case BT_DATA_NAME_COMPLETE:
 			if (eir[0] > sizeof(name) - 1) {
-				memcpy(name, &eir[2], sizeof(name) - 1);
+				(void) memcpy(name, &eir[2], sizeof(name) - 1);
 			} else {
-				memcpy(name, &eir[2], eir[0] - 1);
+				(void) memcpy(name, &eir[2], eir[0] - 1);
 			}
 			break;
 		default:
diff -u -p a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c
--- a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c
+++ b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c
@@ -729,22 +729,23 @@ static inline int isr_rx_pdu(struct lll_
 		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 		if (lll->rpa_gen && lrpa) {
 			pdu_tx->tx_addr = 1;
-			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
-			       BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->connect_ind.init_addr[0],
+				      lrpa->val,
+				      BDADDR_SIZE);
 		} else {
 #else
 		if (1) {
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 			pdu_tx->tx_addr = lll->init_addr_type;
-			memcpy(&pdu_tx->connect_ind.init_addr[0],
-			       &lll->init_addr[0], BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->connect_ind.init_addr[0],
+					&lll->init_addr[0], BDADDR_SIZE);
 		}
-		memcpy(&pdu_tx->connect_ind.adv_addr[0],
-		       &pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
-		memcpy(&pdu_tx->connect_ind.access_addr[0],
-		       &lll_conn->access_addr[0], 4);
-		memcpy(&pdu_tx->connect_ind.crc_init[0],
-		       &lll_conn->crc_init[0], 3);
+		(void) memcpy(&pdu_tx->connect_ind.adv_addr[0],
+				&pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
+		(void) memcpy(&pdu_tx->connect_ind.access_addr[0],
+				&lll_conn->access_addr[0], 4);
+		(void) memcpy(&pdu_tx->connect_ind.crc_init[0],
+				&lll_conn->crc_init[0], 3);
 		pdu_tx->connect_ind.win_size = 1;
 
 		conn_interval_us = (uint32_t)lll_conn->interval * 1250U;
@@ -772,9 +773,9 @@ static inline int isr_rx_pdu(struct lll_
 			sys_cpu_to_le16(lll_conn->latency);
 		pdu_tx->connect_ind.timeout =
 			sys_cpu_to_le16(lll->conn_timeout);
-		memcpy(&pdu_tx->connect_ind.chan_map[0],
-		       &lll_conn->data_chan_map[0],
-		       sizeof(pdu_tx->connect_ind.chan_map));
+		(void) memcpy(&pdu_tx->connect_ind.chan_map[0],
+				&lll_conn->data_chan_map[0],
+				sizeof(pdu_tx->connect_ind.chan_map));
 		pdu_tx->connect_ind.hop = lll_conn->data_chan_hop;
 		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
 
@@ -827,8 +828,8 @@ static inline int isr_rx_pdu(struct lll_
 		rx->hdr.handle = 0xffff;
 
 		uint8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
-		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
-					  sizeof(struct pdu_adv_connect_ind)));
+		(void) memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
+						sizeof(struct pdu_adv_connect_ind)));
 
 		/* Overwrite the sent chan sel with received chan sel, when
 		 * giving this PDU to the higher layer. */
@@ -894,18 +895,19 @@ static inline int isr_rx_pdu(struct lll_
 		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 		if (lll->rpa_gen && lrpa) {
 			pdu_tx->tx_addr = 1;
-			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
-			       BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->scan_req.scan_addr[0],
+				      lrpa->val,
+				      BDADDR_SIZE);
 		} else {
 #else
 		if (1) {
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 			pdu_tx->tx_addr = lll->init_addr_type;
-			memcpy(&pdu_tx->scan_req.scan_addr[0],
-			       &lll->init_addr[0], BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->scan_req.scan_addr[0],
+					&lll->init_addr[0], BDADDR_SIZE);
 		}
-		memcpy(&pdu_tx->scan_req.adv_addr[0],
-		       &pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
+		(void) memcpy(&pdu_tx->scan_req.adv_addr[0],
+				&pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
 
 		radio_pkt_tx_set(pdu_tx);
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_chan.c b/subsys/bluetooth/controller/ll_sw/ull_chan.c
--- a/subsys/bluetooth/controller/ll_sw/ull_chan.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_chan.c
@@ -33,13 +33,13 @@ int ull_chan_reset(void)
 
 uint8_t ull_chan_map_get(uint8_t *const chan_map)
 {
-	memcpy(chan_map, map, sizeof(map));
+	(void) memcpy(chan_map, map, sizeof(map));
 
 	return count;
 }
 
 void ull_chan_map_set(uint8_t const *const chan_map)
 {
-	memcpy(map, chan_map, sizeof(map));
+	(void) memcpy(map, chan_map, sizeof(map));
 	count = util_ones_count_get(map, sizeof(map));
 }
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_master.c b/subsys/bluetooth/controller/ll_sw/ull_master.c
--- a/subsys/bluetooth/controller/ll_sw/ull_master.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_master.c
@@ -141,7 +141,7 @@ uint8_t ll_create_connection(uint16_t sc
 	ull_scan_params_set(lll, 0, scan_interval, scan_window, filter_policy);
 
 	lll->adv_addr_type = peer_addr_type;
-	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
+	(void) memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
 	lll->conn_timeout = timeout;
 	lll->conn_ticks_slot = 0; /* TODO: */
 
@@ -213,7 +213,7 @@ uint8_t ll_create_connection(uint16_t sc
 	conn_lll->role = 0;
 	/* FIXME: END: Move to ULL? */
 #if defined(CONFIG_BT_CTLR_CONN_META)
-	memset(&conn_lll->conn_meta, 0, sizeof(conn_lll->conn_meta));
+	(void) memset(&conn_lll->conn_meta, 0, sizeof(conn_lll->conn_meta));
 #endif /* CONFIG_BT_CTLR_CONN_META */
 
 	conn->connect_expire = 6U;
@@ -441,8 +441,8 @@ uint8_t ll_chm_update(uint8_t const *con
 			return ret;
 		}
 
-		memcpy(conn->llcp.chan_map.chm, chm,
-		       sizeof(conn->llcp.chan_map.chm));
+		(void) memcpy(conn->llcp.chan_map.chm, chm,
+				sizeof(conn->llcp.chan_map.chm));
 		/* conn->llcp.chan_map.instant     = 0; */
 		conn->llcp.chan_map.initiate = 1U;
 
@@ -477,7 +477,7 @@ uint8_t ll_enc_req_send(uint16_t handle,
 
 		pdu_data_tx = (void *)tx->pdu;
 
-		memcpy(&conn->llcp_enc.ltk[0], ltk, sizeof(conn->llcp_enc.ltk));
+		(void) memcpy(&conn->llcp_enc.ltk[0], ltk, sizeof(conn->llcp_enc.ltk));
 
 		if (!conn->lll.enc_rx && !conn->lll.enc_tx) {
 			struct pdu_data_llctrl_enc_req *enc_req;
@@ -490,14 +490,14 @@ uint8_t ll_enc_req_send(uint16_t handle,
 				PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 			enc_req = (void *)
 				&pdu_data_tx->llctrl.enc_req;
-			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
+			(void) memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
 			enc_req->ediv[0] = ediv[0];
 			enc_req->ediv[1] = ediv[1];
 			lll_csrand_get(enc_req->skdm, sizeof(enc_req->skdm));
 			lll_csrand_get(enc_req->ivm, sizeof(enc_req->ivm));
 		} else if (conn->lll.enc_rx && conn->lll.enc_tx) {
-			memcpy(&conn->llcp_enc.rand[0], rand,
-			       sizeof(conn->llcp_enc.rand));
+			(void) memcpy(&conn->llcp_enc.rand[0], rand,
+					sizeof(conn->llcp_enc.rand));
 
 			conn->llcp_enc.ediv[0] = ediv[0];
 			conn->llcp_enc.ediv[1] = ediv[1];
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull.c b/subsys/bluetooth/controller/ll_sw/ull.c
--- a/subsys/bluetooth/controller/ll_sw/ull.c
+++ b/subsys/bluetooth/controller/ll_sw/ull.c
@@ -1204,7 +1204,7 @@ int ull_prepare_enqueue(lll_is_abort_cb_
 		return -ENOBUFS;
 	}
 
-	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
+	(void) memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
 	e->prepare_cb = prepare_cb;
 	e->is_abort_cb = is_abort_cb;
 	e->abort_cb = abort_cb;
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_test.c b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_test.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_test.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_test.c
@@ -221,35 +221,35 @@ uint32_t ll_test_tx(uint8_t chan, uint8_
 
 	switch (type) {
 	case 0x00:
-		memcpy(payload, prbs9, len);
+		(void) memcpy(payload, prbs9, len);
 		break;
 
 	case 0x01:
-		memset(payload, 0x0f, len);
+		(void) memset(payload, 0x0f, len);
 		break;
 
 	case 0x02:
-		memset(payload, 0x55, len);
+		(void) memset(payload, 0x55, len);
 		break;
 
 	case 0x03:
-		memcpy(payload, prbs15, len);
+		(void) memcpy(payload, prbs15, len);
 		break;
 
 	case 0x04:
-		memset(payload, 0xff, len);
+		(void) memset(payload, 0xff, len);
 		break;
 
 	case 0x05:
-		memset(payload, 0x00, len);
+		(void) memset(payload, 0x00, len);
 		break;
 
 	case 0x06:
-		memset(payload, 0xf0, len);
+		(void) memset(payload, 0xf0, len);
 		break;
 
 	case 0x07:
-		memset(payload, 0xaa, len);
+		(void) memset(payload, 0xaa, len);
 		break;
 	}
 
diff -u -p a/subsys/bluetooth/controller/util/mem.c b/subsys/bluetooth/controller/util/mem.c
--- a/subsys/bluetooth/controller/util/mem.c
+++ b/subsys/bluetooth/controller/util/mem.c
@@ -32,8 +32,8 @@ void mem_init(void *mem_pool, uint16_t m
 
 		next = (uint32_t)((uint8_t *) mem_pool +
 			       (mem_size * (mem_count + 1)));
-		memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
-		       (void *)&next, sizeof(next));
+		(void) memcpy(((uint8_t *)mem_pool + (mem_size * mem_count)),
+				(void *)&next, sizeof(next));
 	}
 }
 
@@ -50,7 +50,7 @@ void *mem_acquire(void **mem_head)
 		free_count--;
 
 		mem = *mem_head;
-		memcpy(&head, mem, sizeof(head));
+		(void) memcpy(&head, mem, sizeof(head));
 
 		/* Store free mem_count after the list's next pointer */
 		if (head) {
@@ -76,7 +76,7 @@ void mem_release(void *mem, void **mem_h
 	}
 	free_count++;
 
-	memcpy(mem, mem_head, sizeof(mem));
+	(void) memcpy(mem, mem_head, sizeof(mem));
 
 	/* Store free mem_count after the list's next pointer */
 	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
diff -u -p a/subsys/bluetooth/services/ots/ots.c b/subsys/bluetooth/services/ots/ots.c
--- a/subsys/bluetooth/services/ots/ots.c
+++ b/subsys/bluetooth/services/ots/ots.c
@@ -174,7 +174,7 @@ int bt_ots_obj_add(struct bt_ots *ots,
 	}
 
 	/* Initialize object. */
-	memcpy(&obj->metadata, obj_init, sizeof(obj->metadata));
+	(void) memcpy(&obj->metadata, obj_init, sizeof(obj->metadata));
 
 	/* Request object data. */
 	if (ots->cb->obj_created) {
diff -u -p a/subsys/disk/disk_access_usdhc.c b/subsys/disk/disk_access_usdhc.c
--- a/subsys/disk/disk_access_usdhc.c
+++ b/subsys/disk/disk_access_usdhc.c
@@ -1648,8 +1648,8 @@ static inline void usdhc_op_ctx_init(str
 
 	priv->op_context.cmd_only = cmd_only;
 
-	memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
-	memset((char *)data, 0, sizeof(struct usdhc_data));
+	(void) memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
+	(void) memset((char *)data, 0, sizeof(struct usdhc_data));
 
 	cmd->index = cmd_idx;
 	cmd->argument = arg;
@@ -2023,8 +2023,8 @@ static int usdhc_select_bus_timing(struc
 		/* execute tuning */
 		priv->op_context.cmd_only = 0;
 
-		memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
-		memset((char *)data, 0, sizeof(struct usdhc_data));
+		(void) memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
+		(void) memset((char *)data, 0, sizeof(struct usdhc_data));
 
 		cmd->index = SDHC_SEND_TUNING_BLOCK;
 		cmd->rsp_type = SDHC_RSP_TYPE_R1;
@@ -2055,8 +2055,8 @@ static int usdhc_write_sector(void *bus_
 	struct usdhc_cmd *cmd = &priv->op_context.cmd;
 	struct usdhc_data *data = &priv->op_context.data;
 
-	memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
-	memset((char *)data, 0, sizeof(struct usdhc_data));
+	(void) memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
+	(void) memset((char *)data, 0, sizeof(struct usdhc_data));
 
 	priv->op_context.cmd_only = 0;
 	cmd->index = SDHC_WRITE_MULTIPLE_BLOCK;
@@ -2084,8 +2084,8 @@ static int usdhc_read_sector(void *bus_d
 	struct usdhc_cmd *cmd = &priv->op_context.cmd;
 	struct usdhc_data *data = &priv->op_context.data;
 
-	memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
-	memset((char *)data, 0, sizeof(struct usdhc_data));
+	(void) memset((char *)cmd, 0, sizeof(struct usdhc_cmd));
+	(void) memset((char *)data, 0, sizeof(struct usdhc_data));
 
 	priv->op_context.cmd_only = 0;
 	cmd->index = SDHC_READ_MULTIPLE_BLOCK;
@@ -2419,8 +2419,8 @@ APP_SEND_OP_COND_AGAIN:
 
 	ret = usdhc_xfer(priv);
 	if (!ret) {
-		memcpy(priv->card_info.raw_cid, cmd->response,
-			sizeof(priv->card_info.raw_cid));
+		(void) memcpy(priv->card_info.raw_cid, cmd->response,
+				sizeof(priv->card_info.raw_cid));
 		sdhc_decode_cid(&priv->card_info.cid,
 			priv->card_info.raw_cid);
 	} else {
@@ -2444,8 +2444,8 @@ APP_SEND_OP_COND_AGAIN:
 
 	ret = usdhc_xfer(priv);
 	if (!ret) {
-		memcpy(priv->card_info.raw_csd, cmd->response,
-			sizeof(priv->card_info.raw_csd));
+		(void) memcpy(priv->card_info.raw_csd, cmd->response,
+				sizeof(priv->card_info.raw_csd));
 		sdhc_decode_csd(&priv->card_info.csd, priv->card_info.raw_csd,
 			&priv->card_info.sd_block_count,
 			&priv->card_info.sd_block_size);
@@ -2664,7 +2664,7 @@ static int usdhc_access_init(const struc
 
 	(void)k_mutex_lock(&z_usdhc_init_lock, K_FOREVER);
 
-	memset((char *)priv, 0, sizeof(struct usdhc_priv));
+	(void) memset((char *)priv, 0, sizeof(struct usdhc_priv));
 	priv->config = config;
 
 	priv->clock_dev = device_get_binding(config->clock_name);
diff -u -p a/subsys/logging/log_backend_spinel.c b/subsys/logging/log_backend_spinel.c
--- a/subsys/logging/log_backend_spinel.c
+++ b/subsys/logging/log_backend_spinel.c
@@ -64,7 +64,7 @@ static void sync_hexdump(const struct lo
 
 static void log_backend_spinel_init(void)
 {
-	memset(char_buf, '\0', sizeof(char_buf));
+	(void) memset(char_buf, '\0', sizeof(char_buf));
 }
 
 static void panic(struct log_backend const *const backend)
@@ -113,7 +113,7 @@ static int write(uint8_t *data, size_t l
 	}
 
 	/* make sure that buffer will be clean in next attempt */
-	memset(char_buf, '\0', length);
+	(void) memset(char_buf, '\0', length);
 	return length;
 }
 
diff -u -p a/tests/net/ieee802154/l2/src/ieee802154_test.c b/tests/net/ieee802154/l2/src/ieee802154_test.c
--- a/tests/net/ieee802154/l2/src/ieee802154_test.c
+++ b/tests/net/ieee802154/l2/src/ieee802154_test.c
@@ -222,7 +222,7 @@ static bool test_ack_reply(struct ieee80
 	pkt = net_pkt_rx_alloc(K_FOREVER);
 	frag = net_pkt_get_frag(pkt, K_FOREVER);
 
-	memcpy(frag->data, data_pkt, sizeof(data_pkt));
+	(void) memcpy(frag->data, data_pkt, sizeof(data_pkt));
 	frag->len = sizeof(data_pkt);
 
 	net_pkt_frag_add(pkt, frag);
diff -u -p a/tests/net/ethernet_mgmt/src/main.c b/tests/net/ethernet_mgmt/src/main.c
--- a/tests/net/ethernet_mgmt/src/main.c
+++ b/tests/net/ethernet_mgmt/src/main.c
@@ -159,7 +159,7 @@ static int eth_fake_set_config(const str
 
 		break;
 	case ETHERNET_CONFIG_TYPE_MAC_ADDRESS:
-		memcpy(ctx->mac_address, config->mac_address.addr, 6);
+		(void) memcpy(ctx->mac_address, config->mac_address.addr, 6);
 
 		net_if_set_link_addr(ctx->iface, ctx->mac_address,
 				     sizeof(ctx->mac_address),
@@ -282,7 +282,7 @@ static int eth_fake_init(const struct de
 	ctx->link_10bt = true;
 	ctx->link_100bt = false;
 
-	memcpy(ctx->mac_address, mac_addr_init, 6);
+	(void) memcpy(ctx->mac_address, mac_addr_init, 6);
 
 	/* Initialize priority queues */
 	for (i = 0; i < ARRAY_SIZE(ctx->priority_queues); ++i) {
@@ -311,7 +311,7 @@ static void test_change_mac_when_up(void
 	struct ethernet_req_params params;
 	int ret;
 
-	memcpy(params.mac_address.addr, mac_addr_change, 6);
+	(void) memcpy(params.mac_address.addr, mac_addr_change, 6);
 
 	ret = net_mgmt(NET_REQUEST_ETHERNET_SET_MAC_ADDRESS, iface,
 		       &params, sizeof(struct ethernet_req_params));
@@ -326,7 +326,7 @@ static void test_change_mac_when_down(vo
 	struct ethernet_req_params params;
 	int ret;
 
-	memcpy(params.mac_address.addr, mac_addr_change, 6);
+	(void) memcpy(params.mac_address.addr, mac_addr_change, 6);
 
 	net_if_down(iface);
 
diff -u -p a/tests/net/tx_timestamp/src/main.c b/tests/net/tx_timestamp/src/main.c
--- a/tests/net/tx_timestamp/src/main.c
+++ b/tests/net/tx_timestamp/src/main.c
@@ -442,8 +442,8 @@ static void send_some_data(struct net_if
 			      &udp_v6_ctx);
 	zassert_equal(ret, 0, "Create IPv6 UDP context failed\n");
 
-	memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = net_context_bind(udp_v6_ctx, (struct sockaddr *)&src_addr6,
 			       sizeof(struct sockaddr_in6));
diff -u -p a/tests/net/buf/src/main.c b/tests/net/buf/src/main.c
--- a/tests/net/buf/src/main.c
+++ b/tests/net/buf/src/main.c
@@ -336,7 +336,7 @@ static void test_net_buf_big_buf(void)
 	for (i = 0; i < 2; i++) {
 		zassert_true(net_buf_tailroom(frag) >= len,
 			    "Allocated buffer is too small");
-		memcpy(net_buf_add(frag, len), example_data, len);
+		(void) memcpy(net_buf_add(frag, len), example_data, len);
 	}
 
 	ipv6 = (struct ipv6_hdr *)(frag->data - net_buf_headroom(frag));
@@ -388,7 +388,7 @@ static void test_net_buf_multi_frags(voi
 	for (i = 0; i < bufs_pool.buf_count - 2; i++) {
 		zassert_true(net_buf_tailroom(frags[i]) >= len,
 			    "Allocated buffer is too small");
-		memcpy(net_buf_add(frags[i], len), example_data, len);
+		(void) memcpy(net_buf_add(frags[i], len), example_data, len);
 		occupied += frags[i]->len;
 	}
 
diff -u -p a/tests/net/tcp/src/main.c b/tests/net/tcp/src/main.c
--- a/tests/net/tcp/src/main.c
+++ b/tests/net/tcp/src/main.c
@@ -179,7 +179,7 @@ struct net_tcp_hdr *net_tcp_set_hdr(stru
 		goto out;
 	}
 
-	memcpy(tcp_hdr, hdr, sizeof(struct net_tcp_hdr));
+	(void) memcpy(tcp_hdr, hdr, sizeof(struct net_tcp_hdr));
 
 	net_pkt_set_data(pkt, &tcp_access);
 out:
diff -u -p a/tests/net/lib/coap/src/main.c b/tests/net/lib/coap/src/main.c
--- a/tests/net/lib/coap/src/main.c
+++ b/tests/net/lib/coap/src/main.c
@@ -173,7 +173,7 @@ static int test_parse_empty_pdu(void)
 		goto done;
 	}
 
-	memcpy(data, pdu, sizeof(pdu));
+	(void) memcpy(data, pdu, sizeof(pdu));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(pdu), NULL, 0);
 	if (r) {
@@ -234,7 +234,7 @@ static int test_parse_empty_pdu_1(void)
 		goto done;
 	}
 
-	memcpy(data, pdu, sizeof(pdu));
+	(void) memcpy(data, pdu, sizeof(pdu));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(pdu), NULL, 0);
 	if (r) {
@@ -299,7 +299,7 @@ static int test_parse_simple_pdu(void)
 		goto done;
 	}
 
-	memcpy(data, pdu, sizeof(pdu));
+	(void) memcpy(data, pdu, sizeof(pdu));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(pdu), NULL, 0);
 	if (r) {
@@ -392,7 +392,7 @@ static int test_parse_malformed_opt(void
 		goto done;
 	}
 
-	memcpy(data, opt, sizeof(opt));
+	(void) memcpy(data, opt, sizeof(opt));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(opt), NULL, 0);
 	if (r < 0) {
@@ -421,7 +421,7 @@ static int test_parse_malformed_opt_len(
 		goto done;
 	}
 
-	memcpy(data, opt, sizeof(opt));
+	(void) memcpy(data, opt, sizeof(opt));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(opt), NULL, 0);
 	if (r < 0) {
@@ -450,7 +450,7 @@ static int test_parse_malformed_opt_ext(
 		goto done;
 	}
 
-	memcpy(data, opt, sizeof(opt));
+	(void) memcpy(data, opt, sizeof(opt));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(opt), NULL, 0);
 	if (r < 0) {
@@ -479,7 +479,7 @@ static int test_parse_malformed_opt_len_
 		goto done;
 	}
 
-	memcpy(data, opt, sizeof(opt));
+	(void) memcpy(data, opt, sizeof(opt));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(opt), NULL, 0);
 	if (r < 0) {
@@ -508,7 +508,7 @@ static int test_parse_malformed_marker(v
 		goto done;
 	}
 
-	memcpy(data, pdu, sizeof(pdu));
+	(void) memcpy(data, pdu, sizeof(pdu));
 
 	r = coap_packet_parse(&cpkt, data, sizeof(pdu), NULL, 0);
 	if (r < 0) {
@@ -785,8 +785,8 @@ static int test_block1_size(void)
 	i = 0U;
 	result = TC_FAIL;
 	more = 1;
-	memset(&req_ctx, 0, sizeof(req_ctx));
-	memset(&rsp_ctx, 0, sizeof(rsp_ctx));
+	(void) memset(&req_ctx, 0, sizeof(req_ctx));
+	(void) memset(&rsp_ctx, 0, sizeof(rsp_ctx));
 
 	while (more) {
 		r = prepare_block1_request(&req, &req_ctx, &more);
@@ -1021,8 +1021,8 @@ static int test_block2_size(void)
 	i = 0U;
 	result = TC_FAIL;
 	more = 1;
-	memset(&req_ctx, 0, sizeof(req_ctx));
-	memset(&rsp_ctx, 0, sizeof(rsp_ctx));
+	(void) memset(&req_ctx, 0, sizeof(req_ctx));
+	(void) memset(&rsp_ctx, 0, sizeof(rsp_ctx));
 
 	while (more) {
 		r = prepare_block2_request(&req, &req_ctx, &rsp);
@@ -1286,7 +1286,7 @@ static int test_observer_server(void)
 		goto done;
 	}
 
-	memcpy(data, valid_request_pdu, sizeof(valid_request_pdu));
+	(void) memcpy(data, valid_request_pdu, sizeof(valid_request_pdu));
 
 	r = coap_packet_parse(&req, data, sizeof(valid_request_pdu),
 			      options, opt_num);
@@ -1318,7 +1318,7 @@ static int test_observer_server(void)
 		goto done;
 	}
 
-	memcpy(data, not_found_request_pdu, sizeof(not_found_request_pdu));
+	(void) memcpy(data, not_found_request_pdu, sizeof(not_found_request_pdu));
 
 	r = coap_packet_parse(&req, data, sizeof(not_found_request_pdu),
 			      options, opt_num);
diff -u -p a/tests/net/traffic_class/src/main.c b/tests/net/traffic_class/src/main.c
--- a/tests/net/traffic_class/src/main.c
+++ b/tests/net/traffic_class/src/main.c
@@ -385,8 +385,8 @@ static void setup_net_context(struct net
 	zassert_equal(ret, 0, "Create IPv6 UDP context %p failed (%d)\n",
 		      *ctx, ret);
 
-	memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = add_neighbor(iface1, &dst_addr);
 	zassert_true(ret, "Cannot add neighbor");
@@ -467,7 +467,7 @@ static void traffic_class_send_packets_w
 	/* Convert num to ascii */
 	data[0] = tc + 0x30;
 	len = strlen(test_data);
-	memcpy(data+1, test_data, strlen(test_data));
+	(void) memcpy(data+1, test_data, strlen(test_data));
 
 	len += 1;
 
@@ -748,7 +748,7 @@ static void traffic_class_recv_packets_w
 	/* Convert num to ascii */
 	data[0] = tc + 0x30;
 	len = strlen(test_data);
-	memcpy(data+1, test_data, strlen(test_data));
+	(void) memcpy(data+1, test_data, strlen(test_data));
 
 	len += 1;
 
diff -u -p a/tests/net/socket/udp/src/main.c b/tests/net/socket/udp/src/main.c
--- a/tests/net/socket/udp/src/main.c
+++ b/tests/net/socket/udp/src/main.c
@@ -442,7 +442,7 @@ void test_v4_sendmsg_recvfrom(void)
 	io_vector[0].iov_base = TEST_STR_SMALL;
 	io_vector[0].iov_len = strlen(TEST_STR_SMALL);
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 	msg.msg_control = &cmsgbuf.buf;
 	msg.msg_controllen = sizeof(cmsgbuf.buf);
 	msg.msg_iov = io_vector;
@@ -498,7 +498,7 @@ void test_v4_sendmsg_recvfrom_no_aux_dat
 	io_vector[0].iov_base = TEST_STR_SMALL;
 	io_vector[0].iov_len = strlen(TEST_STR_SMALL);
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 	msg.msg_iov = io_vector;
 	msg.msg_iovlen = 1;
 	msg.msg_name = &server_addr;
@@ -550,7 +550,7 @@ void test_v6_sendmsg_recvfrom(void)
 	io_vector[0].iov_base = TEST_STR_SMALL;
 	io_vector[0].iov_len = strlen(TEST_STR_SMALL);
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 	msg.msg_control = &cmsgbuf.buf;
 	msg.msg_controllen = sizeof(cmsgbuf.buf);
 	msg.msg_iov = io_vector;
@@ -615,7 +615,7 @@ void test_v4_sendmsg_recvfrom_connected(
 	io_vector[0].iov_base = TEST_STR_SMALL;
 	io_vector[0].iov_len = strlen(TEST_STR_SMALL);
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 	msg.msg_control = &cmsgbuf.buf;
 	msg.msg_controllen = sizeof(cmsgbuf.buf);
 	msg.msg_iov = io_vector;
@@ -677,7 +677,7 @@ void test_v6_sendmsg_recvfrom_connected(
 	io_vector[0].iov_base = TEST_STR_SMALL;
 	io_vector[0].iov_len = strlen(TEST_STR_SMALL);
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 	msg.msg_control = &cmsgbuf.buf;
 	msg.msg_controllen = sizeof(cmsgbuf.buf);
 	msg.msg_iov = io_vector;
@@ -915,7 +915,7 @@ void test_v6_sendmsg_with_txtime(void)
 	io_vector[0].iov_base = TEST_STR_SMALL;
 	io_vector[0].iov_len = strlen(TEST_STR_SMALL);
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 	msg.msg_control = &cmsgbuf.buf;
 	msg.msg_controllen = sizeof(cmsgbuf.buf);
 	msg.msg_iov = io_vector;
diff -u -p a/tests/net/socket/socketpair/src/test_socketpair_closed_ends.c b/tests/net/socket/socketpair/src/test_socketpair_closed_ends.c
--- a/tests/net/socket/socketpair/src/test_socketpair_closed_ends.c
+++ b/tests/net/socket/socketpair/src/test_socketpair_closed_ends.c
@@ -65,7 +65,7 @@ void test_socketpair_close_one_end_and_r
 		res = close(sv[i]);
 		zassert_equal(res, 0, "close(sv[%u]) failed: %d", i, errno);
 
-		memset(xx, 0, sizeof(xx));
+		(void) memset(xx, 0, sizeof(xx));
 		res = read(sv[(!i) & 1], xx, sizeof(xx));
 		zassert_not_equal(res, -1, "read(2) failed: %d", errno);
 		zassert_equal(res, 2, "expected to read 2 bytes but read %d",
diff -u -p a/tests/net/socket/poll/src/main.c b/tests/net/socket/poll/src/main.c
--- a/tests/net/socket/poll/src/main.c
+++ b/tests/net/socket/poll/src/main.c
@@ -57,7 +57,7 @@ void test_poll(void)
 	res = connect(c_sock, (struct sockaddr *)&s_addr, sizeof(s_addr));
 	zassert_equal(res, 0, "connect failed");
 
-	memset(pollfds, 0, sizeof(pollfds));
+	(void) memset(pollfds, 0, sizeof(pollfds));
 	pollfds[0].fd = c_sock;
 	pollfds[0].events = POLLIN;
 	pollfds[1].fd = s_sock;
@@ -115,7 +115,7 @@ void test_poll(void)
 	zassert_equal(pollfds[1].revents, 0, "");
 
 	/* Make sure that POLLOUT does not wait if not really needed */
-	memset(pollout, 0, sizeof(pollout));
+	(void) memset(pollout, 0, sizeof(pollout));
 	pollout[0].fd = c_sock;
 	pollout[0].events = POLLOUT;
 
@@ -132,7 +132,7 @@ void test_poll(void)
 	/* First test that TCP POLLOUT will not wait if there is enough
 	 * room in TCP window
 	 */
-	memset(pollout, 0, sizeof(pollout));
+	(void) memset(pollout, 0, sizeof(pollout));
 	pollout[0].fd = c_sock_tcp;
 	pollout[0].events = POLLOUT;
 
diff -u -p a/tests/drivers/flash/src/main.c b/tests/drivers/flash/src/main.c
--- a/tests/drivers/flash/src/main.c
+++ b/tests/drivers/flash/src/main.c
@@ -103,7 +103,7 @@ static void test_read_unaligned_address(
 				/* buffer overflow protection */
 				buf[buf_o - 1] = CANARY;
 				buf[buf_o + len] = CANARY;
-				memset(buf + buf_o, 0, len);
+				(void) memset(buf + buf_o, 0, len);
 				rc = flash_read(flash_dev,
 						page_info.start_offset + ad_o,
 						buf + buf_o, len);
diff -u -p a/tests/ztest/base/src/main.c b/tests/ztest/base/src/main.c
--- a/tests/ztest/base/src/main.c
+++ b/tests/ztest/base/src/main.c
@@ -29,7 +29,7 @@ static void test_assert_mem_equal(void)
 		0xDEF0
 	};
 	uint32_t actual[4] = {0};
-	memcpy(actual, expected, sizeof(actual));
+	(void) memcpy(actual, expected, sizeof(actual));
 	zassert_mem_equal(actual, expected, sizeof(expected), NULL);
 }
 
diff -u -p a/tests/subsys/settings/nvs/src/settings_test_nvs.c b/tests/subsys/settings/nvs/src/settings_test_nvs.c
--- a/tests/subsys/settings/nvs/src/settings_test_nvs.c
+++ b/tests/subsys/settings/nvs/src/settings_test_nvs.c
@@ -75,13 +75,13 @@ int c1_handle_get(const char *name, char
 
 	if (settings_name_steq(name, "mybar", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val8));
-		memcpy(val, &val8, MIN(val_len_max, sizeof(val8)));
+		(void) memcpy(val, &val8, MIN(val_len_max, sizeof(val8)));
 		return val_len_max;
 	}
 
 	if (settings_name_steq(name, "mybar64", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val64));
-		memcpy(val, &val64, MIN(val_len_max, sizeof(val64)));
+		(void) memcpy(val, &val64, MIN(val_len_max, sizeof(val64)));
 		return val_len_max;
 	}
 
@@ -200,7 +200,7 @@ int c2_handle_get(const char *name, char
 		}
 
 		len = MIN(strlen(valptr), len);
-		memcpy(val, valptr, len);
+		(void) memcpy(val, valptr, len);
 		return len;
 	}
 
@@ -257,7 +257,7 @@ int c3_handle_get(const char *name, char
 
 	if (settings_name_steq(name, "v", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val32));
-		memcpy(val, &val32, MIN(val_len_max, sizeof(val32)));
+		(void) memcpy(val, &val32, MIN(val_len_max, sizeof(val32)));
 		return val_len_max;
 	}
 	return -EINVAL;
diff -u -p a/tests/subsys/storage/stream/stream_flash/src/main.c b/tests/subsys/storage/stream/stream_flash/src/main.c
--- a/tests/subsys/storage/stream/stream_flash/src/main.c
+++ b/tests/subsys/storage/stream/stream_flash/src/main.c
@@ -86,8 +86,8 @@ static void init_target(void)
 	int rc;
 
 	/* Ensure that target is clean */
-	memset(&ctx, 0, sizeof(ctx));
-	memset(buf, 0, BUF_LEN);
+	(void) memset(&ctx, 0, sizeof(ctx));
+	(void) memset(buf, 0, BUF_LEN);
 
 	/* Disable callback tests */
 	cb_len = 0;
@@ -334,8 +334,8 @@ static void test_stream_flash_buffered_w
 	VERIFY_WRITTEN(page_size, page_size);
 
 	/* Reset stream_flash context */
-	memset(&ctx, 0, sizeof(ctx));
-	memset(buf, 0, BUF_LEN);
+	(void) memset(&ctx, 0, sizeof(ctx));
+	(void) memset(buf, 0, BUF_LEN);
 	rc = stream_flash_init(&ctx, fdev, buf, BUF_LEN, FLASH_BASE, 0,
 			       stream_flash_callback);
 	zassert_equal(rc, 0, "expected success");
diff -u -p a/tests/subsys/canbus/isotp/conformance/src/main.c b/tests/subsys/canbus/isotp/conformance/src/main.c
--- a/tests/subsys/canbus/isotp/conformance/src/main.c
+++ b/tests/subsys/canbus/isotp/conformance/src/main.c
@@ -159,7 +159,7 @@ static void get_sf(struct isotp_recv_ctx
 {
 	int ret;
 
-	memset(data_buf, 0, sizeof(data_buf));
+	(void) memset(data_buf, 0, sizeof(data_buf));
 	ret = isotp_recv(recv_ctx, data_buf, sizeof(data_buf), K_MSEC(1000));
 	zassert_equal(ret, data_size, "recv returned %d", ret);
 
@@ -192,7 +192,7 @@ static void receive_test_data(struct iso
 	const uint8_t *data_ptr = data;
 
 	do {
-		memset(data_buf, 0, sizeof(data_buf));
+		(void) memset(data_buf, 0, sizeof(data_buf));
 		recv_len = isotp_recv(recv_ctx, data_buf, sizeof(data_buf),
 				      K_MSEC(1000));
 		zassert_true(recv_len >= 0, "recv error: %d", recv_len);
@@ -227,7 +227,7 @@ static void send_frame_series(struct fra
 
 	for (i = 0; i < length; i++) {
 		frame.dlc = desired->length;
-		memcpy(frame.data, desired->data, desired->length);
+		(void) memcpy(frame.data, desired->data, desired->length);
 		ret = can_send(can_dev, &frame, K_MSEC(500), NULL, NULL);
 		zassert_equal(ret, CAN_TX_OK, "Sending msg %d failed.", i);
 		desired++;
@@ -286,7 +286,7 @@ static void prepare_cf_frames(struct fra
 	for (i = 0; i < frames_cnt && remaining_length; i++) {
 		frames[i].data[0] = CF_PCI_BYTE_1 | ((i+1) & 0x0F);
 		frames[i].length = CAN_DL;
-		memcpy(&des_frames[i].data[1], data_ptr, DATA_SIZE_CF);
+		(void) memcpy(&des_frames[i].data[1], data_ptr, DATA_SIZE_CF);
 
 		if (remaining_length < DATA_SIZE_CF) {
 			frames[i].length = remaining_length + 1;
@@ -304,7 +304,7 @@ static void test_send_sf(void)
 	struct frame_desired des_frame;
 
 	des_frame.data[0] = SF_PCI_BYTE_1;
-	memcpy(&des_frame.data[1], random_data, DATA_SIZE_SF);
+	(void) memcpy(&des_frame.data[1], random_data, DATA_SIZE_SF);
 	des_frame.length = DATA_SIZE_SF + 1;
 
 	filter_id = attach_msgq(rx_addr.std_id);
@@ -324,7 +324,7 @@ static void test_receive_sf(void)
 	struct frame_desired single_frame;
 
 	single_frame.data[0] = SF_PCI_BYTE_1;
-	memcpy(&single_frame.data[1], random_data, DATA_SIZE_SF);
+	(void) memcpy(&single_frame.data[1], random_data, DATA_SIZE_SF);
 	single_frame.length  = DATA_SIZE_SF + 1;
 
 	ret = isotp_bind(&recv_ctx, can_dev, &rx_addr, &tx_addr,
@@ -354,7 +354,7 @@ static void test_send_sf_ext(void)
 
 	des_frame.data[0] = rx_addr_ext.ext_addr;
 	des_frame.data[1] = SF_PCI_BYTE_2_EXT;
-	memcpy(&des_frame.data[2], random_data, DATA_SIZE_SF_EXT);
+	(void) memcpy(&des_frame.data[2], random_data, DATA_SIZE_SF_EXT);
 	des_frame.length = DATA_SIZE_SF_EXT + 2;
 
 	filter_id = attach_msgq(rx_addr_ext.std_id);
@@ -378,7 +378,7 @@ static void test_receive_sf_ext(void)
 
 	single_frame.data[0] = EXT_ADDR;
 	single_frame.data[1] = SF_PCI_BYTE_2_EXT;
-	memcpy(&single_frame.data[2], random_data, DATA_SIZE_SF_EXT);
+	(void) memcpy(&single_frame.data[2], random_data, DATA_SIZE_SF_EXT);
 	single_frame.length  = DATA_SIZE_SF_EXT + 2;
 
 	ret = isotp_bind(&recv_ctx, can_dev, &rx_addr_ext, &tx_addr,
@@ -410,7 +410,7 @@ static void test_send_data(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
 	ff_frame.length = CAN_DL;
 	data_ptr += DATA_SIZE_FF;
 	remaining_length -= DATA_SIZE_FF;
@@ -449,7 +449,7 @@ static void test_send_data_blocks(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
 	ff_frame.length = DATA_SIZE_FF + 2;
 	data_ptr += DATA_SIZE_FF;
 	remaining_length -= DATA_SIZE_FF;
@@ -512,7 +512,7 @@ static void test_receive_data(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
 	ff_frame.length = CAN_DL;
 	data_ptr += DATA_SIZE_FF;
 	remaining_length -= DATA_SIZE_FF;
@@ -556,7 +556,7 @@ static void test_receive_data_blocks(voi
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], data_ptr, DATA_SIZE_FF);
 	ff_frame.length = DATA_SIZE_FF + 2;
 	data_ptr += DATA_SIZE_FF;
 	remaining_length -= DATA_SIZE_FF;
@@ -673,7 +673,7 @@ static void test_receive_timeouts(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
 	ff_frame.length = DATA_SIZE_FF + 2;
 
 	ret = isotp_bind(&recv_ctx, can_dev, &rx_addr, &tx_addr,
@@ -708,7 +708,7 @@ static void test_stmin(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SIZE_FF + DATA_SIZE_CF * 4);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SIZE_FF + DATA_SIZE_CF * 4);
-	memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
 	ff_frame.length = DATA_SIZE_FF + 2;
 
 	fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
@@ -763,7 +763,7 @@ void test_receiver_fc_errors(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
 	ff_frame.length = DATA_SIZE_FF + 2;
 
 	fc_frame.data[0] = FC_PCI_BYTE_1(FC_PCI_CTS);
@@ -808,7 +808,7 @@ void test_sender_fc_errors(void)
 
 	ff_frame.data[0] = FF_PCI_BYTE_1(DATA_SEND_LENGTH);
 	ff_frame.data[1] = FF_PCI_BYTE_2(DATA_SEND_LENGTH);
-	memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
+	(void) memcpy(&ff_frame.data[2], random_data, DATA_SIZE_FF);
 	ff_frame.length = DATA_SIZE_FF + 2;
 
 	filter_id = attach_msgq(tx_addr.std_id);
diff -u -p a/tests/subsys/fs/fat_fs_dual_drive/src/disk_access_test_drv.c b/tests/subsys/fs/fat_fs_dual_drive/src/disk_access_test_drv.c
--- a/tests/subsys/fs/fat_fs_dual_drive/src/disk_access_test_drv.c
+++ b/tests/subsys/fs/fat_fs_dual_drive/src/disk_access_test_drv.c
@@ -41,7 +41,7 @@ static int disk_ram_access_init(struct d
 static int disk_ram_access_read(struct disk_info *disk, uint8_t *buff,
 				uint32_t sector, uint32_t count)
 {
-	memcpy(buff, lba_to_address(sector), count * RAMDISK_SECTOR_SIZE);
+	(void) memcpy(buff, lba_to_address(sector), count * RAMDISK_SECTOR_SIZE);
 
 	return 0;
 }
@@ -49,7 +49,7 @@ static int disk_ram_access_read(struct d
 static int disk_ram_access_write(struct disk_info *disk, const uint8_t *buff,
 				 uint32_t sector, uint32_t count)
 {
-	memcpy(lba_to_address(sector), buff, count * RAMDISK_SECTOR_SIZE);
+	(void) memcpy(lba_to_address(sector), buff, count * RAMDISK_SECTOR_SIZE);
 
 	return 0;
 }
diff -u -p a/tests/subsys/logging/log_output/src/log_output_test.c b/tests/subsys/logging/log_output/src/log_output_test.c
--- a/tests/subsys/logging/log_output/src/log_output_test.c
+++ b/tests/subsys/logging/log_output/src/log_output_test.c
@@ -27,7 +27,7 @@ static uint32_t mock_len;
 static void reset_mock_buffer(void)
 {
 	mock_len = 0U;
-	memset(mock_buffer, 0, sizeof(mock_buffer));
+	(void) memset(mock_buffer, 0, sizeof(mock_buffer));
 }
 
 static void setup(void)
@@ -42,7 +42,7 @@ static void teardown(void)
 
 static int mock_output_func(uint8_t *buf, size_t size, void *ctx)
 {
-	memcpy(&mock_buffer[mock_len], buf, size);
+	(void) memcpy(&mock_buffer[mock_len], buf, size);
 	mock_len += size;
 
 	return size;
diff -u -p a/tests/bluetooth/tester/src/l2cap.c b/tests/bluetooth/tester/src/l2cap.c
--- a/tests/bluetooth/tester/src/l2cap.c
+++ b/tests/bluetooth/tester/src/l2cap.c
@@ -47,7 +47,7 @@ static int recv_cb(struct bt_l2cap_chan 
 
 	ev->chan_id = chan->chan_id;
 	ev->data_length = sys_cpu_to_le16(buf->len);
-	memcpy(ev->data, buf->data, buf->len);
+	(void) memcpy(ev->data, buf->data, buf->len);
 
 	tester_send(BTP_SERVICE_ID_L2CAP, L2CAP_EV_DATA_RECEIVED,
 		    CONTROLLER_INDEX, recv_cb_buf, sizeof(*ev) + buf->len);
@@ -71,12 +71,12 @@ static void connected_cb(struct bt_l2cap
 			ev.mtu_local = sys_cpu_to_le16(chan->le.rx.mtu);
 			ev.mps_local = sys_cpu_to_le16(chan->le.rx.mps);
 			ev.address_type = info.le.dst->type;
-			memcpy(ev.address, info.le.dst->a.val,
-			       sizeof(ev.address));
+			(void) memcpy(ev.address, info.le.dst->a.val,
+					sizeof(ev.address));
 			break;
 		case BT_CONN_TYPE_BR:
-			memcpy(ev.address, info.br.dst->val,
-			       sizeof(ev.address));
+			(void) memcpy(ev.address, info.br.dst->val,
+					sizeof(ev.address));
 			break;
 		}
 	}
@@ -100,12 +100,12 @@ static void disconnected_cb(struct bt_l2
 		switch (info.type) {
 		case BT_CONN_TYPE_LE:
 			ev.address_type = info.le.dst->type;
-			memcpy(ev.address, info.le.dst->a.val,
-			       sizeof(ev.address));
+			(void) memcpy(ev.address, info.le.dst->a.val,
+					sizeof(ev.address));
 			break;
 		case BT_CONN_TYPE_BR:
-			memcpy(ev.address, info.br.dst->val,
-			       sizeof(ev.address));
+			(void) memcpy(ev.address, info.br.dst->val,
+					sizeof(ev.address));
 			break;
 		}
 	}
diff -u -p a/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c b/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c
--- a/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c
+++ b/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c
@@ -758,7 +758,7 @@ static bool data_cb(struct bt_data *data
 	switch (data->type) {
 	case BT_DATA_NAME_SHORTENED:
 	case BT_DATA_NAME_COMPLETE:
-		memcpy(name, data->data, MIN(data->data_len, NAME_LEN - 1));
+		(void) memcpy(name, data->data, MIN(data->data_len, NAME_LEN - 1));
 		return false;
 	default:
 		return true;
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_2.c
@@ -91,7 +91,7 @@ static ssize_t write_value_v5(struct bt_
 	if (offset + len > sizeof(value_v5_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_2.c
@@ -133,7 +133,7 @@ static ssize_t write_value_v2(struct bt_
 	if (offset + len > sizeof(value_v2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -163,7 +163,7 @@ static ssize_t write_value_v2_1(struct b
 	if (offset + len > sizeof(value_v2_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -193,7 +193,7 @@ static ssize_t write_value_v2_2(struct b
 	if (offset + len > sizeof(value_v2_2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -223,7 +223,7 @@ static ssize_t write_value_v2_3(struct b
 	if (offset + len > sizeof(value_v2_3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -253,7 +253,7 @@ static ssize_t write_value_v2_4(struct b
 	if (offset + len > sizeof(value_v2_4_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -283,7 +283,7 @@ static ssize_t write_value_v2_5(struct b
 	if (offset + len > sizeof(value_v2_5_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_2_1.c
@@ -94,7 +94,7 @@ static ssize_t write_value_v5(struct bt_
 	if (!bAuthorized)
 		return BT_GATT_ERR(BT_ATT_ERR_AUTHORIZATION);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_2.c
@@ -116,7 +116,7 @@ static ssize_t write_value_v2(struct bt_
 	if (offset + len > sizeof(value_v2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -145,7 +145,7 @@ static ssize_t write_value_v3(struct bt_
 	if (offset + len > sizeof(value_v3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_3.c
@@ -74,7 +74,7 @@ static ssize_t write_value_v4(struct bt_
 	if (offset + len > sizeof(value_v4_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_3.c
@@ -52,7 +52,7 @@ static ssize_t write_value_v7(struct bt_
 	if (offset + len > sizeof(value_v7_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/lib/notify/src/main.c b/tests/lib/notify/src/main.c
--- a/tests/lib/notify/src/main.c
+++ b/tests/lib/notify/src/main.c
@@ -50,7 +50,7 @@ static void test_spinwait(void)
 	struct sys_notify notify;
 	uint32_t xflags = 0x1234;
 
-	memset(&notify, 0xac, sizeof(notify));
+	(void) memset(&notify, 0xac, sizeof(notify));
 	rc = sys_notify_validate(&notify);
 	zassert_equal(rc, -EINVAL,
 		      "invalid not diagnosed");
@@ -104,7 +104,7 @@ static void test_signal(void)
 	struct sys_notify notify;
 	uint32_t xflags = 0x1234;
 
-	memset(&notify, 0xac, sizeof(notify));
+	(void) memset(&notify, 0xac, sizeof(notify));
 	rc = sys_notify_validate(&notify);
 	zassert_equal(rc, -EINVAL,
 		      "invalid not diagnosed");
@@ -120,7 +120,7 @@ static void test_signal(void)
 	zassert_equal(rc, -EINVAL,
 		      "null signal not invalid");
 
-	memset(&notify, 0xac, sizeof(notify));
+	(void) memset(&notify, 0xac, sizeof(notify));
 	sys_notify_init_signal(&notify, &sig);
 	rc = sys_notify_validate(&notify);
 	zassert_equal(rc, 0,
@@ -176,7 +176,7 @@ static void test_callback(void)
 	struct sys_notify notify;
 	uint32_t xflags = 0x8765432;
 
-	memset(&notify, 0xac, sizeof(notify));
+	(void) memset(&notify, 0xac, sizeof(notify));
 	rc = sys_notify_validate(&notify);
 	zassert_equal(rc, -EINVAL,
 		      "invalid not diagnosed");
@@ -187,7 +187,7 @@ static void test_callback(void)
 	zassert_equal(rc, -EINVAL,
 		      "null callback not invalid");
 
-	memset(&notify, 0xac, sizeof(notify));
+	(void) memset(&notify, 0xac, sizeof(notify));
 	sys_notify_init_callback(&notify, callback);
 	rc = sys_notify_validate(&notify);
 	zassert_equal(rc, 0,
diff -u -p a/tests/lib/cmsis_dsp/transform/src/cq31.c b/tests/lib/cmsis_dsp/transform/src/cq31.c
--- a/tests/lib/cmsis_dsp/transform/src/cq31.c
+++ b/tests/lib/cmsis_dsp/transform/src/cq31.c
@@ -27,7 +27,7 @@ static void test_arm_cfft_q31(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(output, input, length * sizeof(q31_t));
+	(void) memcpy(output, input, length * sizeof(q31_t));
 
 	/* Run test function */
 	arm_cfft_q31(inst, output, false, true);
@@ -110,7 +110,7 @@ static void test_arm_cifft_q31(
 	zassert_not_null(scaled_ref, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(output, input, length * sizeof(q31_t));
+	(void) memcpy(output, input, length * sizeof(q31_t));
 
 	/* Run test function */
 	arm_cfft_q31(inst, output, true, true);
diff -u -p a/tests/lib/cmsis_dsp/transform/src/rq31.c b/tests/lib/cmsis_dsp/transform/src/rq31.c
--- a/tests/lib/cmsis_dsp/transform/src/rq31.c
+++ b/tests/lib/cmsis_dsp/transform/src/rq31.c
@@ -34,7 +34,7 @@ static void test_arm_rfft_q31(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load input data into the scratch buffer */
-	memcpy(scratch, input, length * sizeof(q31_t));
+	(void) memcpy(scratch, input, length * sizeof(q31_t));
 
 	/* Run test function */
 	arm_rfft_q31(&inst, scratch, output);
@@ -115,7 +115,7 @@ static void test_arm_rifft_q31(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load input data into the scratch buffer */
-	memcpy(scratch, input, length * sizeof(q31_t));
+	(void) memcpy(scratch, input, length * sizeof(q31_t));
 
 	/* Run test function */
 	arm_rfft_q31(&inst, scratch, output);
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/unary_f64.c b/tests/lib/cmsis_dsp/matrix/src/unary_f64.c
--- a/tests/lib/cmsis_dsp/matrix/src/unary_f64.c
+++ b/tests/lib/cmsis_dsp/matrix/src/unary_f64.c
@@ -53,8 +53,8 @@ static void test_arm_mat_inverse_f64(voi
 		mat_in1.numCols = mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input,
-		       rows * columns * sizeof(float64_t));
+		(void) memcpy(mat_in1.pData, input,
+				rows * columns * sizeof(float64_t));
 
 		/* Run test function */
 		status = arm_mat_inverse_f64(&mat_in1, &mat_out);
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/unary_f32.c b/tests/lib/cmsis_dsp/matrix/src/unary_f32.c
--- a/tests/lib/cmsis_dsp/matrix/src/unary_f32.c
+++ b/tests/lib/cmsis_dsp/matrix/src/unary_f32.c
@@ -66,11 +66,11 @@ static void test_op2(int op, const uint3
 		mat_in1.numCols = mat_in2.numCols = mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, in_com1,
-		       rows * columns * sizeof(float32_t));
+		(void) memcpy(mat_in1.pData, in_com1,
+				rows * columns * sizeof(float32_t));
 
-		memcpy(mat_in2.pData, in_com2,
-		       rows * columns * sizeof(float32_t));
+		(void) memcpy(mat_in2.pData, in_com2,
+				rows * columns * sizeof(float32_t));
 
 		/* Run test function */
 		switch (op) {
@@ -144,8 +144,8 @@ static void test_op1(int op, const uint3
 		mat_out.numCols = transpose ? rows : columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, in_com1,
-		       rows * columns * sizeof(float32_t));
+		(void) memcpy(mat_in1.pData, in_com1,
+				rows * columns * sizeof(float32_t));
 
 		/* Run test function */
 		switch (op) {
@@ -217,8 +217,8 @@ static void test_arm_mat_inverse_f32(voi
 		mat_in1.numCols = mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData,
-		       input, rows * columns * sizeof(float32_t));
+		(void) memcpy(mat_in1.pData,
+				input, rows * columns * sizeof(float32_t));
 
 		/* Run test function */
 		status = arm_mat_inverse_f32(&mat_in1, &mat_out);
diff -u -p a/tests/portability/cmsis_rtos_v1/src/mailq.c b/tests/portability/cmsis_rtos_v1/src/mailq.c
--- a/tests/portability/cmsis_rtos_v1/src/mailq.c
+++ b/tests/portability/cmsis_rtos_v1/src/mailq.c
@@ -36,7 +36,7 @@ void send_thread(void const *argument)
 	osStatus status;
 
 	/* This is used for comparison later in the function */
-	memset(&zeroblock, 0, sizeof(struct sample_data));
+	(void) memset(&zeroblock, 0, sizeof(struct sample_data));
 
 	status = osMailPut(mail_id, NULL);
 	zassert_true(status == osErrorValue,
diff -u -p a/tests/kernel/mem_protect/protection/src/main.c b/tests/kernel/mem_protect/protection/src/main.c
--- a/tests/kernel/mem_protect/protection/src/main.c
+++ b/tests/kernel/mem_protect/protection/src/main.c
@@ -55,7 +55,7 @@ static void execute_from_buffer(uint8_t 
 	int i = 1;
 
 	/* Copy add_one() code to destination buffer. */
-	memcpy(dst, src, BUF_SIZE);
+	(void) memcpy(dst, src, BUF_SIZE);
 	DO_BARRIERS();
 
 	/*
@@ -124,7 +124,7 @@ static void test_write_text(void)
 	 * confirmation that we truly executed the code we wrote.
 	 */
 	INFO("trying to write to text at %p\n", dst);
-	memcpy(dst, src, BUF_SIZE);
+	(void) memcpy(dst, src, BUF_SIZE);
 	DO_BARRIERS();
 	i = overwrite_target(i);
 	if (i == 2) {
diff -u -p a/samples/net/sockets/can/src/main.c b/samples/net/sockets/can/src/main.c
--- a/samples/net/sockets/can/src/main.c
+++ b/samples/net/sockets/can/src/main.c
@@ -113,7 +113,7 @@ static void rx(int *can_fd, int *do_clos
 	while (1) {
 		uint8_t *data;
 
-		memset(&frame, 0, sizeof(frame));
+		(void) memset(&frame, 0, sizeof(frame));
 		addr_len = sizeof(can_addr);
 
 		ret = recvfrom(fd, &frame, sizeof(struct can_frame),
diff -u -p a/samples/net/sockets/sntp_client/src/main.c b/samples/net/sockets/sntp_client/src/main.c
--- a/samples/net/sockets/sntp_client/src/main.c
+++ b/samples/net/sockets/sntp_client/src/main.c
@@ -28,7 +28,7 @@ void main(void)
 	int rv;
 
 	/* ipv4 */
-	memset(&addr, 0, sizeof(addr));
+	(void) memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
 	addr.sin_port = htons(SNTP_PORT);
 	inet_pton(AF_INET, SERVER_ADDR, &addr.sin_addr);
@@ -55,7 +55,7 @@ void main(void)
 	sntp_close(&ctx);
 
 	/* ipv6 */
-	memset(&addr6, 0, sizeof(addr6));
+	(void) memset(&addr6, 0, sizeof(addr6));
 	addr6.sin6_family = AF_INET6;
 	addr6.sin6_port = htons(SNTP_PORT);
 	inet_pton(AF_INET6, SERVER_ADDR6, &addr6.sin6_addr);
diff -u -p a/samples/net/sockets/echo_client/src/vlan.c b/samples/net/sockets/echo_client/src/vlan.c
--- a/samples/net/sockets/echo_client/src/vlan.c
+++ b/samples/net/sockets/echo_client/src/vlan.c
@@ -87,7 +87,7 @@ int init_vlan(void)
 	struct ud ud;
 	int ret;
 
-	memset(&ud, 0, sizeof(ud));
+	(void) memset(&ud, 0, sizeof(ud));
 
 	net_if_foreach(iface_cb, &ud);
 
diff -u -p a/samples/net/zperf/src/zperf_tcp_receiver.c b/samples/net/zperf/src/zperf_tcp_receiver.c
--- a/samples/net/zperf/src/zperf_tcp_receiver.c
+++ b/samples/net/zperf/src/zperf_tcp_receiver.c
@@ -187,8 +187,8 @@ void zperf_tcp_receiver_init(const struc
 					      "Unable to get IPv4 by default\n");
 				return;
 			}
-			memcpy(&in4_addr_my->sin_addr, in4_addr,
-				sizeof(struct in_addr));
+			(void) memcpy(&in4_addr_my->sin_addr, in4_addr,
+					sizeof(struct in_addr));
 		}
 
 		shell_fprintf(shell, SHELL_NORMAL, "Binding to %s\n",
@@ -224,8 +224,8 @@ void zperf_tcp_receiver_init(const struc
 					      "Unable to get IPv4 by default\n");
 				return;
 			}
-			memcpy(&in6_addr_my->sin6_addr, in6_addr,
-				sizeof(struct in6_addr));
+			(void) memcpy(&in6_addr_my->sin6_addr, in6_addr,
+					sizeof(struct in6_addr));
 		}
 
 		shell_fprintf(shell, SHELL_NORMAL, "Binding to %s\n",
diff -u -p a/samples/drivers/led_apa102/src/main.c b/samples/drivers/led_apa102/src/main.c
--- a/samples/drivers/led_apa102/src/main.c
+++ b/samples/drivers/led_apa102/src/main.c
@@ -74,8 +74,8 @@ void main(void)
 	time = 0;
 	while (1) {
 		for (i = 0; i < STRIP_NUM_LEDS; i++) {
-			memcpy(&strip_colors[i], color_at(time, i),
-			       sizeof(strip_colors[i]));
+			(void) memcpy(&strip_colors[i], color_at(time, i),
+					sizeof(strip_colors[i]));
 		}
 		led_strip_update_rgb(strip, strip_colors, STRIP_NUM_LEDS);
 		k_sleep(DELAY_TIME);
diff -u -p a/samples/drivers/display/src/main.c b/samples/drivers/display/src/main.c
--- a/samples/drivers/display/src/main.c
+++ b/samples/drivers/display/src/main.c
@@ -187,7 +187,7 @@ static void fill_buffer_mono(enum corner
 		break;
 	}
 
-	memset(buf, color, buf_size);
+	(void) memset(buf, color, buf_size);
 }
 
 void main(void)
diff -u -p a/samples/subsys/usb/hid-cdc/src/main.c b/samples/subsys/usb/hid-cdc/src/main.c
--- a/samples/subsys/usb/hid-cdc/src/main.c
+++ b/samples/subsys/usb/hid-cdc/src/main.c
@@ -369,13 +369,13 @@ static volatile bool data_arrived;
 static void flush_buffer_mouse(void)
 {
 	chr_ptr_mouse = 0U;
-	memset(data_buf_mouse, 0, sizeof(data_buf_mouse));
+	(void) memset(data_buf_mouse, 0, sizeof(data_buf_mouse));
 }
 
 static void flush_buffer_kbd(void)
 {
 	chr_ptr_kbd = 0U;
-	memset(data_buf_kbd, 0, sizeof(data_buf_kbd));
+	(void) memset(data_buf_kbd, 0, sizeof(data_buf_kbd));
 }
 
 static void write_data(const struct device *dev, const char *buf, int len)
diff -u -p a/samples/subsys/logging/syst/src/main.c b/samples/subsys/logging/syst/src/main.c
--- a/samples/subsys/logging/syst/src/main.c
+++ b/samples/subsys/logging/syst/src/main.c
@@ -57,7 +57,7 @@ void main(void)
 	frame.id_type = 1U;
 	frame.std_id = 1234U;
 	frame.dlc = sizeof(data);
-	memcpy(frame.data, data, sizeof(data));
+	(void) memcpy(frame.data, data, sizeof(data));
 
 	LOG_HEXDUMP_ERR((const uint8_t *)&frame, sizeof(frame), "frame");
 	LOG_HEXDUMP_WRN((const uint8_t *)&frame, sizeof(frame), "frame");
diff -u -p a/samples/bluetooth/peripheral_ots/src/main.c b/samples/bluetooth/peripheral_ots/src/main.c
--- a/samples/bluetooth/peripheral_ots/src/main.c
+++ b/samples/bluetooth/peripheral_ots/src/main.c
@@ -155,7 +155,7 @@ static int ots_init(void)
 	}
 
 	/* Configure OTS initialization. */
-	memset(&ots_init, 0, sizeof(ots_init));
+	(void) memset(&ots_init, 0, sizeof(ots_init));
 	BT_OTS_OACP_SET_FEAT_READ(ots_init.features.oacp);
 	BT_OTS_OLCP_SET_FEAT_GO_TO(ots_init.features.olcp);
 	ots_init.cb = &ots_callbacks;
@@ -172,7 +172,7 @@ static int ots_init(void)
 		objects[0][i] = i + 1;
 	}
 
-	memset(&obj_init, 0, sizeof(obj_init));
+	(void) memset(&obj_init, 0, sizeof(obj_init));
 	obj_init.name = "first_object.txt";
 	obj_init.type.uuid.type = BT_UUID_TYPE_16;
 	obj_init.type.uuid_16.val = BT_UUID_OTS_TYPE_UNSPECIFIED_VAL;
@@ -191,7 +191,7 @@ static int ots_init(void)
 		objects[1][i] = i * 2;
 	}
 
-	memset(&obj_init, 0, sizeof(obj_init));
+	(void) memset(&obj_init, 0, sizeof(obj_init));
 	obj_init.name = "second_object.gif";
 	obj_init.type.uuid.type = BT_UUID_TYPE_16;
 	obj_init.type.uuid_16.val = BT_UUID_OTS_TYPE_UNSPECIFIED_VAL;
diff -u -p a/samples/bluetooth/peripheral/src/main.c b/samples/bluetooth/peripheral/src/main.c
--- a/samples/bluetooth/peripheral/src/main.c
+++ b/samples/bluetooth/peripheral/src/main.c
@@ -60,7 +60,7 @@ static ssize_t write_vnd(struct bt_conn 
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -115,7 +115,7 @@ static ssize_t write_long_vnd(struct bt_
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -149,7 +149,7 @@ static ssize_t write_signed(struct bt_co
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -180,7 +180,7 @@ static ssize_t write_without_rsp_vnd(str
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/samples/bluetooth/central_ht/src/main.c b/samples/bluetooth/central_ht/src/main.c
--- a/samples/bluetooth/central_ht/src/main.c
+++ b/samples/bluetooth/central_ht/src/main.c
@@ -84,7 +84,7 @@ static uint8_t discover_func(struct bt_c
 	printk("[ATTRIBUTE] handle %u\n", attr->handle);
 
 	if (!bt_uuid_cmp(discover_params.uuid, BT_UUID_HTS)) {
-		memcpy(&uuid, BT_UUID_HTS_MEASUREMENT, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_HTS_MEASUREMENT, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.start_handle = attr->handle + 1;
 		discover_params.type = BT_GATT_DISCOVER_CHARACTERISTIC;
@@ -95,7 +95,7 @@ static uint8_t discover_func(struct bt_c
 		}
 	} else if (!bt_uuid_cmp(discover_params.uuid,
 				BT_UUID_HTS_MEASUREMENT)) {
-		memcpy(&uuid, BT_UUID_GATT_CCC, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_GATT_CCC, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.start_handle = attr->handle + 2;
 		discover_params.type = BT_GATT_DISCOVER_DESCRIPTOR;
@@ -143,7 +143,7 @@ static void connected(struct bt_conn *co
 	printk("Connected: %s\n", addr);
 
 	if (conn == default_conn) {
-		memcpy(&uuid, BT_UUID_HTS, sizeof(uuid));
+		(void) memcpy(&uuid, BT_UUID_HTS, sizeof(uuid));
 		discover_params.uuid = &uuid.uuid;
 		discover_params.func = discover_func;
 		discover_params.start_handle = 0x0001;
@@ -178,7 +178,7 @@ static bool eir_found(struct bt_data *da
 			uint16_t u16;
 			int err;
 
-			memcpy(&u16, &data->data[i], sizeof(u16));
+			(void) memcpy(&u16, &data->data[i], sizeof(u16));
 			uuid = BT_UUID_DECLARE_16(sys_le16_to_cpu(u16));
 			if (bt_uuid_cmp(uuid, BT_UUID_HTS)) {
 				continue;
diff -u -p a/samples/boards/intel_s1000_crb/audio/src/audio_driver.c b/samples/boards/intel_s1000_crb/audio/src/audio_driver.c
--- a/samples/boards/intel_s1000_crb/audio/src/audio_driver.c
+++ b/samples/boards/intel_s1000_crb/audio/src/audio_driver.c
@@ -149,8 +149,8 @@ static int audio_driver_send_zeros_frame
 	}
 
 	/* fill buffer with zeros */
-	memset(spk_out_buf, 0, SPK_FRAME_BYTES);
-	memset(host_out_buf, 0, HOST_FRAME_BYTES);
+	(void) memset(spk_out_buf, 0, SPK_FRAME_BYTES);
+	(void) memset(host_out_buf, 0, HOST_FRAME_BYTES);
 
 	ret = i2s_write(i2s_spk_out_dev, spk_out_buf, SPK_FRAME_BYTES);
 	if (ret) {
diff -u -p a/samples/userspace/shared_mem/src/main.c b/samples/userspace/shared_mem/src/main.c
--- a/samples/userspace/shared_mem/src/main.c
+++ b/samples/userspace/shared_mem/src/main.c
@@ -181,7 +181,7 @@ void enc(void)
 		if (fBUFIN == 1) { /* 1 is process text */
 			printk("ENC Thread Received Data\n");
 			/* copy message form shared mem and clear flag */
-			memcpy((void *)&enc_pt, (void *)BUFIN, SAMP_BLOCKSIZE);
+			(void) memcpy((void *)&enc_pt, (void *)BUFIN, SAMP_BLOCKSIZE);
 			printk("ENC PT MSG: %s\n", (char *)&enc_pt);
 			fBUFIN = 0;
 			/* reset wheel: probably better as a flag option  */
@@ -189,7 +189,7 @@ void enc(void)
 			IW2 = 2;
 			IW3 = 3;
 			/* encode */
-			memset((void *)&enc_ct, 0, SAMP_BLOCKSIZE);
+			(void) memset((void *)&enc_ct, 0, SAMP_BLOCKSIZE);
 			for (index = 0, index_out = 0; index < SAMP_BLOCKSIZE; index++) {
 				if (enc_pt[index] == '\0') {
 					enc_ct[index_out] = '\0';
@@ -205,8 +205,8 @@ void enc(void)
 				k_sleep(K_MSEC(1));
 			}
 			/* ct thread has cleared the buffer */
-			memcpy((void *)&BUFOUT, (void *)&enc_ct,
-			       SAMP_BLOCKSIZE);
+			(void) memcpy((void *)&BUFOUT, (void *)&enc_ct,
+					SAMP_BLOCKSIZE);
 			fBUFOUT = 1;
 
 		}
@@ -227,8 +227,8 @@ void pt(void)
 		k_sem_take(&allforone, K_FOREVER);
 		if (fBUFIN == 0) { /* send message to encode */
 			printk("\nPT Sending Message 1\n");
-			memset((void *)&BUFIN, 0, SAMP_BLOCKSIZE);
-			memcpy((void *)&BUFIN, (void *)&ptMSG, sizeof(ptMSG));
+			(void) memset((void *)&BUFIN, 0, SAMP_BLOCKSIZE);
+			(void) memcpy((void *)&BUFIN, (void *)&ptMSG, sizeof(ptMSG));
 /* strlen should not be used if user provided data, needs a max length set  */
 			fBUFIN = 1;
 		}
@@ -236,8 +236,8 @@ void pt(void)
 		k_sem_take(&allforone, K_FOREVER);
 		if (fBUFIN == 0) { /* send message to decode  */
 			printk("\nPT Sending Message 1'\n");
-			memset((void *)&BUFIN, 0, SAMP_BLOCKSIZE);
-			memcpy((void *)&BUFIN, (void *)&ptMSG2, sizeof(ptMSG2));
+			(void) memset((void *)&BUFIN, 0, SAMP_BLOCKSIZE);
+			(void) memcpy((void *)&BUFIN, (void *)&ptMSG2, sizeof(ptMSG2));
 			fBUFIN = 1;
 		}
 		k_sem_give(&allforone);
@@ -258,8 +258,8 @@ void ct(void)
 		k_sem_take(&allforone, K_FOREVER);
 		if (fBUFOUT == 1) {
 			printk("CT Thread Receivedd Message\n");
-			memset((void *)&tbuf, 0, sizeof(tbuf));
-			memcpy((void *)&tbuf, (void *)BUFOUT, SAMP_BLOCKSIZE);
+			(void) memset((void *)&tbuf, 0, sizeof(tbuf));
+			(void) memcpy((void *)&tbuf, (void *)BUFOUT, SAMP_BLOCKSIZE);
 			fBUFOUT = 0;
 			printk("CT MSG: %s\n", (char *)&tbuf);
 		}
diff -u -p a/arch/arm/core/aarch32/fatal.c b/arch/arm/core/aarch32/fatal.c
--- a/arch/arm/core/aarch32/fatal.c
+++ b/arch/arm/core/aarch32/fatal.c
@@ -105,7 +105,7 @@ void z_do_kernel_oops(const z_arch_esf_t
 	 */
 	z_arch_esf_t esf_copy;
 
-	memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
+	(void) memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
 	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
 	z_arm_fatal_error(reason, &esf_copy);
 #endif /* CONFIG_EXTRA_EXCEPTION_INFO */
diff -u -p a/lib/posix/pthread.c b/lib/posix/pthread.c
--- a/lib/posix/pthread.c
+++ b/lib/posix/pthread.c
@@ -632,7 +632,7 @@ int pthread_getname_np(pthread_t thread,
 		return EINVAL;
 	}
 
-	memset(name, '\0', len);
+	(void) memset(name, '\0', len);
 	return k_thread_name_copy(kthread, name, len-1);
 #else
 	ARG_UNUSED(thread);
diff -u -p a/lib/os/json.c b/lib/os/json.c
--- a/lib/os/json.c
+++ b/lib/os/json.c
@@ -888,7 +888,7 @@ static int append_bytes_to_buf(const cha
 		return -ENOMEM;
 	}
 
-	memcpy(appender->buffer + appender->used, bytes, len);
+	(void) memcpy(appender->buffer + appender->used, bytes, len);
 	appender->used += len;
 	appender->buffer[appender->used] = '\0';
 
diff -u -p a/drivers/wifi/esp/esp.c b/drivers/wifi/esp/esp.c
--- a/drivers/wifi/esp/esp.c
+++ b/drivers/wifi/esp/esp.c
@@ -151,7 +151,7 @@ MODEM_CMD_DEFINE(on_cmd_cwlap)
 		i = sizeof(res.ssid);
 	}
 
-	memcpy(res.ssid, argv[1], i);
+	(void) memcpy(res.ssid, argv[1], i);
 	res.ssid_length = i;
 	res.rssi = strtol(argv[2], NULL, 10);
 	res.channel = strtol(argv[3], NULL, 10);
@@ -577,7 +577,7 @@ static void esp_mgmt_connect_work(struct
 			     cmds, ARRAY_SIZE(cmds), dev->conn_cmd,
 			     &dev->sem_response, ESP_CONNECT_TIMEOUT);
 
-	memset(dev->conn_cmd, 0, sizeof(dev->conn_cmd));
+	(void) memset(dev->conn_cmd, 0, sizeof(dev->conn_cmd));
 
 	if (ret < 0) {
 		if (esp_flag_is_set(dev, EDF_STA_CONNECTED)) {
@@ -615,13 +615,13 @@ static int esp_mgmt_connect(const struct
 
 	len = snprintk(data->conn_cmd, sizeof(data->conn_cmd),
 		       "AT+"_CWJAP"=\"");
-	memcpy(&data->conn_cmd[len], params->ssid, params->ssid_length);
+	(void) memcpy(&data->conn_cmd[len], params->ssid, params->ssid_length);
 	len += params->ssid_length;
 
 	if (params->security == WIFI_SECURITY_TYPE_PSK) {
 		len += snprintk(&data->conn_cmd[len],
 				sizeof(data->conn_cmd) - len, "\",\"");
-		memcpy(&data->conn_cmd[len], params->psk, params->psk_length);
+		(void) memcpy(&data->conn_cmd[len], params->psk, params->psk_length);
 		len += params->psk_length;
 	}
 
@@ -662,12 +662,12 @@ static int esp_mgmt_ap_enable(const stru
 	}
 
 	len = snprintk(cmd, sizeof(cmd), "AT+"_CWSAP"=\"");
-	memcpy(&cmd[len], params->ssid, params->ssid_length);
+	(void) memcpy(&cmd[len], params->ssid, params->ssid_length);
 	len += params->ssid_length;
 
 	if (params->security == WIFI_SECURITY_TYPE_PSK) {
 		len += snprintk(&cmd[len], sizeof(cmd) - len, "\",\"");
-		memcpy(&cmd[len], params->psk, params->psk_length);
+		(void) memcpy(&cmd[len], params->psk, params->psk_length);
 		len += params->psk_length;
 		ecn = 3;
 	} else {
diff -u -p a/drivers/wifi/eswifi/eswifi_offload.c b/drivers/wifi/eswifi/eswifi_offload.c
--- a/drivers/wifi/eswifi/eswifi_offload.c
+++ b/drivers/wifi/eswifi/eswifi_offload.c
@@ -397,7 +397,7 @@ static int eswifi_off_put(struct net_con
 	}
 
 	if (--socket->usage <= 0) {
-		memset(socket, 0, sizeof(*socket));
+		(void) memset(socket, 0, sizeof(*socket));
 	}
 done:
 	eswifi_unlock(eswifi);
@@ -487,15 +487,15 @@ void eswifi_offload_async_msg(struct esw
 		struct sockaddr_in *peer = net_sin(&socket->peer_addr);
 
 		sin_addr = &peer->sin_addr;
-		memcpy(&sin_addr->s4_addr, ip, 4);
+		(void) memcpy(&sin_addr->s4_addr, ip, 4);
 		peer->sin_port = htons(port);
 		socket->state = ESWIFI_SOCKET_STATE_CONNECTED;
 		socket->usage++;
 
 		/* Save information about remote. */
 		socket->context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
-		memcpy(&socket->context->remote, &socket->peer_addr,
-		       sizeof(struct sockaddr));
+		(void) memcpy(&socket->context->remote, &socket->peer_addr,
+				sizeof(struct sockaddr));
 
 		LOG_DBG("%u.%u.%u.%u connected to port %u",
 			ip[0], ip[1], ip[2], ip[3], port);
diff -u -p a/drivers/ieee802154/ieee802154_rf2xx.c b/drivers/ieee802154/ieee802154_rf2xx.c
--- a/drivers/ieee802154/ieee802154_rf2xx.c
+++ b/drivers/ieee802154/ieee802154_rf2xx.c
@@ -234,7 +234,7 @@ static void rf2xx_trx_rx(const struct de
 		return;
 	}
 
-	memcpy(pkt->buffer->data, rx_buf + RX2XX_FRAME_HEADER_SIZE, pkt_len);
+	(void) memcpy(pkt->buffer->data, rx_buf + RX2XX_FRAME_HEADER_SIZE, pkt_len);
 	net_buf_add(pkt->buffer, pkt_len);
 	net_pkt_set_ieee802154_lqi(pkt, ctx->pkt_lqi);
 	net_pkt_set_ieee802154_rssi(pkt, ctx->pkt_ed + ctx->trx_rssi_base);
diff -u -p a/drivers/ieee802154/ieee802154_nrf5.c b/drivers/ieee802154/ieee802154_nrf5.c
--- a/drivers/ieee802154/ieee802154_nrf5.c
+++ b/drivers/ieee802154/ieee802154_nrf5.c
@@ -79,7 +79,7 @@ static void nrf5_get_eui64(uint8_t *mac)
 	/* Use device identifier assigned during the production. */
 	factoryAddress = (uint64_t)NRF_FICR->DEVICEID[0] << 32;
 	factoryAddress |= NRF_FICR->DEVICEID[1];
-	memcpy(mac + index, &factoryAddress, sizeof(factoryAddress) - index);
+	(void) memcpy(mac + index, &factoryAddress, sizeof(factoryAddress) - index);
 }
 
 static void nrf5_rx_thread(void *arg1, void *arg2, void *arg3)
@@ -377,7 +377,7 @@ static int nrf5_tx(const struct device *
 	LOG_DBG("%p (%u)", payload, payload_len);
 
 	nrf5_radio->tx_psdu[0] = payload_len + NRF5_FCS_LENGTH;
-	memcpy(nrf5_radio->tx_psdu + 1, payload, payload_len);
+	(void) memcpy(nrf5_radio->tx_psdu + 1, payload, payload_len);
 
 	/* Reset semaphore in case ACK was received after timeout */
 	k_sem_reset(&nrf5_radio->tx_wait);
diff -u -p a/drivers/crypto/crypto_ataes132a.c b/drivers/crypto/crypto_ataes132a.c
--- a/drivers/crypto/crypto_ataes132a.c
+++ b/drivers/crypto/crypto_ataes132a.c
@@ -273,7 +273,7 @@ int ataes132a_aes_ccm_decrypt(const stru
 		param_buffer[1] = 0x0;
 		param_buffer[2] = 0x0;
 		param_buffer[3] = 0x0;
-		memcpy(param_buffer + 4,  nonce_buf, 12);
+		(void) memcpy(param_buffer + 4,  nonce_buf, 12);
 
 		return_code = ataes132a_send_command(dev, ATAES_NONCE_OP,
 						     0x0, param_buffer, 16,
@@ -345,9 +345,9 @@ int ataes132a_aes_ccm_decrypt(const stru
 	param_buffer[1] = key_id;
 	param_buffer[3] = expected_out_len;
 	if (aead_op->tag) {
-		memcpy(param_buffer + 4,  aead_op->tag, 16);
+		(void) memcpy(param_buffer + 4,  aead_op->tag, 16);
 	}
-	memcpy(param_buffer + 20, aead_op->pkt->in_buf, in_buf_len);
+	(void) memcpy(param_buffer + 20, aead_op->pkt->in_buf, in_buf_len);
 
 	return_code = ataes132a_send_command(dev, ATAES_DECRYPT_OP,
 					     command_mode, param_buffer,
@@ -382,7 +382,7 @@ int ataes132a_aes_ccm_decrypt(const stru
 		return -EINVAL;
 	}
 
-	memcpy(aead_op->pkt->out_buf, param_buffer + 1, out_len - 1);
+	(void) memcpy(aead_op->pkt->out_buf, param_buffer + 1, out_len - 1);
 
 	k_sem_give(&data->device_sem);
 
@@ -464,7 +464,7 @@ int ataes132a_aes_ccm_encrypt(const stru
 		param_buffer[1] = 0x0;
 		param_buffer[2] = 0x0;
 		param_buffer[3] = 0x0;
-		memcpy(param_buffer + 4,  nonce_buf, 12);
+		(void) memcpy(param_buffer + 4,  nonce_buf, 12);
 
 		return_code = ataes132a_send_command(dev, ATAES_NONCE_OP,
 						     0x0, param_buffer, 16,
@@ -519,7 +519,7 @@ int ataes132a_aes_ccm_encrypt(const stru
 
 	param_buffer[0] = key_id;
 	param_buffer[1] = buf_len;
-	memcpy(param_buffer + 2, aead_op->pkt->in_buf, buf_len);
+	(void) memcpy(param_buffer + 2, aead_op->pkt->in_buf, buf_len);
 
 	return_code = ataes132a_send_command(dev, ATAES_ENCRYPT_OP,
 					     command_mode, param_buffer,
@@ -547,9 +547,9 @@ int ataes132a_aes_ccm_encrypt(const stru
 	}
 
 	if (aead_op->tag) {
-		memcpy(aead_op->tag, param_buffer + 1, 16);
+		(void) memcpy(aead_op->tag, param_buffer + 1, 16);
 	}
-	memcpy(aead_op->pkt->out_buf, param_buffer + 17, out_len - 17U);
+	(void) memcpy(aead_op->pkt->out_buf, param_buffer + 17, out_len - 17U);
 
 	if (mac_mode) {
 		if (mac_mode->include_counter) {
@@ -632,7 +632,7 @@ int ataes132a_aes_ecb_block(const struct
 	param_buffer[0] = 0x0;
 	param_buffer[1] = key_id;
 	param_buffer[2] = 0x0;
-	memcpy(param_buffer + 3, pkt->in_buf, buf_len);
+	(void) memcpy(param_buffer + 3, pkt->in_buf, buf_len);
 	(void)memset(param_buffer + 3 + buf_len, 0x0, 16 - buf_len);
 
 	return_code = ataes132a_send_command(dev, ATAES_LEGACY_OP, 0x00,
@@ -658,7 +658,7 @@ int ataes132a_aes_ecb_block(const struct
 		return -EIO;
 	}
 
-	memcpy(pkt->out_buf, param_buffer + 1, 16);
+	(void) memcpy(pkt->out_buf, param_buffer + 1, 16);
 
 	k_sem_give(&data->device_sem);
 
diff -u -p a/drivers/led/lp503x.c b/drivers/led/lp503x.c
--- a/drivers/led/lp503x.c
+++ b/drivers/led/lp503x.c
@@ -169,7 +169,7 @@ static int lp503x_write_channels(const s
 	 * two I2C messages.
 	 */
 	data->chan_buf[0] = LP503X_CHANNEL_BASE + start_channel;
-	memcpy(data->chan_buf + 1, buf, num_channels);
+	(void) memcpy(data->chan_buf + 1, buf, num_channels);
 
 	return i2c_write(data->i2c, data->chan_buf,
 			 num_channels + 1, config->i2c_addr);
diff -u -p a/drivers/hwinfo/hwinfo_imxrt.c b/drivers/hwinfo/hwinfo_imxrt.c
--- a/drivers/hwinfo/hwinfo_imxrt.c
+++ b/drivers/hwinfo/hwinfo_imxrt.c
@@ -24,7 +24,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = sizeof(dev_id.id);
 	}
 
-	memcpy(buffer, dev_id.id, length);
+	(void) memcpy(buffer, dev_id.id, length);
 
 	return length;
 }
diff -u -p a/drivers/hwinfo/hwinfo_sam4l.c b/drivers/hwinfo/hwinfo_sam4l.c
--- a/drivers/hwinfo/hwinfo_sam4l.c
+++ b/drivers/hwinfo/hwinfo_sam4l.c
@@ -24,7 +24,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = DT_INST_REG_SIZE(0);
 	}
 
-	memcpy(buffer, uid_addr, length);
+	(void) memcpy(buffer, uid_addr, length);
 
 	return length;
 }
diff -u -p a/drivers/entropy/entropy_litex.c b/drivers/entropy/entropy_litex.c
--- a/drivers/entropy/entropy_litex.c
+++ b/drivers/entropy/entropy_litex.c
@@ -43,7 +43,7 @@ static int entropy_prbs_get_entropy(cons
 		value = prbs_read(PRBS_STATUS, PRBS_WIDTH);
 		to_copy = MIN(length, sizeof(value));
 
-		memcpy(buffer, &value, to_copy);
+		(void) memcpy(buffer, &value, to_copy);
 		buffer += to_copy;
 		length -= to_copy;
 	}
diff -u -p a/drivers/ethernet/eth_e1000.c b/drivers/ethernet/eth_e1000.c
--- a/drivers/ethernet/eth_e1000.c
+++ b/drivers/ethernet/eth_e1000.c
@@ -261,8 +261,8 @@ int e1000_probe(const struct device *dev
 	ral = ior32(dev, RAL);
 	rah = ior32(dev, RAH);
 
-	memcpy(dev->mac, &ral, 4);
-	memcpy(dev->mac + 4, &rah, 2);
+	(void) memcpy(dev->mac, &ral, 4);
+	(void) memcpy(dev->mac + 4, &rah, 2);
 
 	return 0;
 }
diff -u -p a/drivers/usb/device/usb_dc_sam0.c b/drivers/usb/device/usb_dc_sam0.c
--- a/drivers/usb/device/usb_dc_sam0.c
+++ b/drivers/usb/device/usb_dc_sam0.c
@@ -576,7 +576,7 @@ int usb_dc_ep_write(uint8_t ep, const ui
 	 * multi-packet and automatic zero-length packet features as
 	 * the upper layers in Zephyr implement these in code.
 	 */
-	memcpy((void *)addr, buf, len);
+	(void) memcpy((void *)addr, buf, len);
 	desc->DeviceDescBank[1].PCKSIZE.bit.MULTI_PACKET_SIZE = 0;
 	desc->DeviceDescBank[1].PCKSIZE.bit.BYTE_COUNT = len;
 	endpoint->EPINTFLAG.reg =
@@ -631,7 +631,7 @@ int usb_dc_ep_read_ex(uint8_t ep, uint8_
 
 	remain = bytes - data->out_at;
 	take = MIN(max_data_len, remain);
-	memcpy(buf, (uint8_t *)addr + data->out_at, take);
+	(void) memcpy(buf, (uint8_t *)addr + data->out_at, take);
 
 	if (read_bytes != NULL) {
 		*read_bytes = take;
diff -u -p a/drivers/usb/device/usb_dc_native_posix.c b/drivers/usb/device/usb_dc_native_posix.c
--- a/drivers/usb/device/usb_dc_native_posix.c
+++ b/drivers/usb/device/usb_dc_native_posix.c
@@ -135,7 +135,7 @@ int usb_dc_reset(void)
 	LOG_DBG("");
 
 	/* Clear private data */
-	memset(&usbip_ctrl, 0, sizeof(usbip_ctrl));
+	(void) memset(&usbip_ctrl, 0, sizeof(usbip_ctrl));
 
 	return 0;
 }
@@ -355,7 +355,7 @@ int usb_dc_ep_write(const uint8_t ep, co
 		uint8_t ep_idx = USB_EP_GET_IDX(ep);
 		struct usb_ep_ctrl_prv *ctrl = &usbip_ctrl.in_ep_ctrl[ep_idx];
 
-		memcpy(ctrl->buf, data, data_len);
+		(void) memcpy(ctrl->buf, data, data_len);
 		ctrl->buf_len = data_len;
 	}
 
diff -u -p a/drivers/flash/spi_nor.c b/drivers/flash/spi_nor.c
--- a/drivers/flash/spi_nor.c
+++ b/drivers/flash/spi_nor.c
@@ -652,7 +652,7 @@ static int spi_nor_process_bfp(const str
 	/* Copy over the erase types, preserving their order.  (The
 	 * Sector Map Parameter table references them by index.)
 	 */
-	memset(data->erase_types, 0, sizeof(data->erase_types));
+	(void) memset(data->erase_types, 0, sizeof(data->erase_types));
 	for (uint8_t ti = 1; ti <= ARRAY_SIZE(data->erase_types); ++ti) {
 		if (jesd216_bfp_erase(bfp, ti, etp) == 0) {
 			LOG_DBG("Erase %u with %02x", (uint32_t)BIT(etp->exp), etp->cmd);
diff -u -p a/drivers/flash/soc_flash_nios2_qspi.c b/drivers/flash/soc_flash_nios2_qspi.c
--- a/drivers/flash/soc_flash_nios2_qspi.c
+++ b/drivers/flash/soc_flash_nios2_qspi.c
@@ -226,7 +226,7 @@ static int flash_nios2_qspi_write_block(
 		}
 
 		/* prepare the word to be written */
-		memcpy((uint8_t *)&word_to_write + padding,
+		(void) memcpy((uint8_t *)&word_to_write + padding,
 				(const uint8_t *)data + buffer_offset,
 				bytes_to_copy);
 
@@ -362,8 +362,9 @@ static int flash_nios2_qspi_read(const s
 		}
 		/* read from flash 32 bits at a time */
 		word_to_read = IORD_32DIRECT(qspi_dev->data_base, read_offset);
-		memcpy((uint8_t *)data, (uint8_t *)&word_to_read + offset -
-		       read_offset, bytes_to_copy);
+		(void) memcpy((uint8_t *)data,
+				(uint8_t *)&word_to_read + offset -
+				read_offset, bytes_to_copy);
 		/* update offset and length variables */
 		read_offset += NIOS2_WRITE_BLOCK_SIZE;
 		buffer_offset += bytes_to_copy;
@@ -381,8 +382,8 @@ static int flash_nios2_qspi_read(const s
 
 		/* read from flash 32 bits at a time */
 		word_to_read = IORD_32DIRECT(qspi_dev->data_base, read_offset);
-		memcpy((uint8_t *)data + buffer_offset, &word_to_read,
-		       bytes_to_copy);
+		(void) memcpy((uint8_t *)data + buffer_offset, &word_to_read,
+				bytes_to_copy);
 		/* update offset and length variables */
 		read_offset += bytes_to_copy;
 		buffer_offset += bytes_to_copy;
diff -u -p a/drivers/flash/flash_sam.c b/drivers/flash/flash_sam.c
--- a/drivers/flash/flash_sam.c
+++ b/drivers/flash/flash_sam.c
@@ -225,7 +225,7 @@ static int flash_sam_read(const struct d
 		return -EINVAL;
 	}
 
-	memcpy(data, (uint8_t *)CONFIG_FLASH_BASE_ADDRESS + offset, len);
+	(void) memcpy(data, (uint8_t *)CONFIG_FLASH_BASE_ADDRESS + offset, len);
 
 	return 0;
 }
diff -u -p a/drivers/espi/espi_mchp_xec.c b/drivers/espi/espi_mchp_xec.c
--- a/drivers/espi/espi_mchp_xec.c
+++ b/drivers/espi/espi_mchp_xec.c
@@ -500,7 +500,7 @@ static int espi_xec_send_oob(const struc
 		return -EINVAL;
 	}
 
-	memcpy(slave_tx_mem, pckt->buf, pckt->len);
+	(void) memcpy(slave_tx_mem, pckt->buf, pckt->len);
 
 	ESPI_OOB_REGS->TX_LEN = pckt->len;
 	ESPI_OOB_REGS->TX_CTRL = MCHP_ESPI_OOB_TX_CTRL_START;
@@ -552,7 +552,7 @@ static int espi_xec_receive_oob(const st
 	}
 
 	pckt->len = rcvd_len;
-	memcpy(pckt->buf, slave_rx_mem, pckt->len);
+	(void) memcpy(pckt->buf, slave_rx_mem, pckt->len);
 
 	return 0;
 }
@@ -600,7 +600,7 @@ static int espi_xec_flash_read(const str
 		return -EIO;
 	}
 
-	memcpy(pckt->buf, slave_mem, pckt->len);
+	(void) memcpy(pckt->buf, slave_mem, pckt->len);
 
 	return 0;
 }
@@ -628,7 +628,7 @@ static int espi_xec_flash_write(const st
 		return -EBUSY;
 	}
 
-	memcpy(slave_mem, pckt->buf, pckt->len);
+	(void) memcpy(slave_mem, pckt->buf, pckt->len);
 
 	ESPI_FC_REGS->FL_ADDR_MSW = 0;
 	ESPI_FC_REGS->FL_ADDR_LSW = pckt->flash_addr;
@@ -651,7 +651,7 @@ static int espi_xec_flash_write(const st
 		return -EIO;
 	}
 
-	memcpy(pckt->buf, slave_rx_mem, pckt->len);
+	(void) memcpy(pckt->buf, slave_rx_mem, pckt->len);
 
 	return 0;
 }
diff -u -p a/drivers/sensor/ccs811/ccs811.c b/drivers/sensor/ccs811/ccs811.c
--- a/drivers/sensor/ccs811/ccs811.c
+++ b/drivers/sensor/ccs811/ccs811.c
@@ -154,7 +154,7 @@ int ccs811_baseline_update(const struct 
 	int rc;
 
 	buf[0] = CCS811_REG_BASELINE;
-	memcpy(buf + 1, &baseline, sizeof(baseline));
+	(void) memcpy(buf + 1, &baseline, sizeof(baseline));
 	set_wake(drv_data, true);
 	rc = i2c_write(drv_data->i2c, buf, sizeof(buf), DT_INST_REG_ADDR(0));
 	set_wake(drv_data, false);
diff -u -p a/drivers/bluetooth/hci/ipm_stm32wb.c b/drivers/bluetooth/hci/ipm_stm32wb.c
--- a/drivers/bluetooth/hci/ipm_stm32wb.c
+++ b/drivers/bluetooth/hci/ipm_stm32wb.c
@@ -316,9 +316,9 @@ static int bt_ipm_send(struct net_buf *b
 		       buf->len);
 		k_sem_take(&acl_data_ack, K_FOREVER);
 		net_buf_push_u8(buf, HCI_ACL);
-		memcpy((void *)
-		       &((TL_AclDataPacket_t *)HciAclDataBuffer)->AclDataSerial,
-		       buf->data, buf->len);
+		(void) memcpy((void *)
+				&((TL_AclDataPacket_t *)HciAclDataBuffer)->AclDataSerial,
+				buf->data, buf->len);
 		TL_BLE_SendAclData(NULL, 0);
 		break;
 	case BT_BUF_CMD:
@@ -326,8 +326,8 @@ static int bt_ipm_send(struct net_buf *b
 		       buf->len);
 		ble_cmd_buff->cmdserial.type = HCI_CMD;
 		ble_cmd_buff->cmdserial.cmd.plen = buf->len;
-		memcpy((void *)&ble_cmd_buff->cmdserial.cmd, buf->data,
-		       buf->len);
+		(void) memcpy((void *)&ble_cmd_buff->cmdserial.cmd, buf->data,
+				buf->len);
 		TL_BLE_SendCmd(NULL, 0);
 		break;
 	default:
diff -u -p a/drivers/modem/ublox-sara-r4.c b/drivers/modem/ublox-sara-r4.c
--- a/drivers/modem/ublox-sara-r4.c
+++ b/drivers/modem/ublox-sara-r4.c
@@ -249,7 +249,7 @@ int find_apn(char *apn, int apnlen, cons
 			int len = eos - s;
 
 			if (len < apnlen) {
-				memcpy(apn, s, len);
+				(void) memcpy(apn, s, len);
 				apn[len] = '\0';
 				rc = 0;
 			} else {
@@ -1237,7 +1237,7 @@ static int offload_bind(void *obj, const
 	struct modem_socket *sock = (struct modem_socket *)obj;
 
 	/* save bind address information */
-	memcpy(&sock->src, addr, sizeof(*addr));
+	(void) memcpy(&sock->src, addr, sizeof(*addr));
 
 	/* make sure we've created the socket */
 	if (sock->id == mdata.socket_config.sockets_len + 1) {
@@ -1276,7 +1276,7 @@ static int offload_connect(void *obj, co
 		}
 	}
 
-	memcpy(&sock->dst, addr, sizeof(*addr));
+	(void) memcpy(&sock->dst, addr, sizeof(*addr));
 	if (addr->sa_family == AF_INET6) {
 		dst_port = ntohs(net_sin6(addr)->sin6_port);
 	} else if (addr->sa_family == AF_INET) {
@@ -1405,7 +1405,7 @@ static ssize_t offload_recvfrom(void *ob
 	/* HACK: use dst address as from */
 	if (from && fromlen) {
 		*fromlen = sizeof(sock->dst);
-		memcpy(from, &sock->dst, *fromlen);
+		(void) memcpy(from, &sock->dst, *fromlen);
 	}
 
 	/* return length of received data */
diff -u -p a/drivers/dma/dma_mcux_edma.c b/drivers/dma/dma_mcux_edma.c
--- a/drivers/dma/dma_mcux_edma.c
+++ b/drivers/dma/dma_mcux_edma.c
@@ -419,8 +419,8 @@ static int dma_mcux_edma_init(const stru
 	EDMA_GetDefaultConfig(&userConfig);
 	EDMA_Init(DEV_BASE(dev), &userConfig);
 	DEV_CFG(dev)->irq_config_func(dev);
-	memset(DEV_DATA(dev), 0, sizeof(struct dma_mcux_edma_data));
-	memset(tcdpool, 0, sizeof(tcdpool));
+	(void) memset(DEV_DATA(dev), 0, sizeof(struct dma_mcux_edma_data));
+	(void) memset(tcdpool, 0, sizeof(tcdpool));
 	return 0;
 }
 
diff -u -p a/drivers/display/gd7965.c b/drivers/display/gd7965.c
--- a/drivers/display/gd7965.c
+++ b/drivers/display/gd7965.c
@@ -253,7 +253,7 @@ static int gd7965_set_contrast(const str
 static void gd7965_get_capabilities(const struct device *dev,
 				    struct display_capabilities *caps)
 {
-	memset(caps, 0, sizeof(struct display_capabilities));
+	(void) memset(caps, 0, sizeof(struct display_capabilities));
 	caps->x_resolution = EPD_PANEL_WIDTH;
 	caps->y_resolution = EPD_PANEL_HEIGHT;
 	caps->supported_pixel_formats = PIXEL_FORMAT_MONO10;
@@ -296,7 +296,7 @@ static int gd7965_clear_and_write_buffer
 		return -ENOMEM;
 	}
 
-	memset(line, pattern, GD7965_NUMOF_PAGES);
+	(void) memset(line, pattern, GD7965_NUMOF_PAGES);
 	for (int i = 0; i < EPD_PANEL_HEIGHT; i++) {
 		gd7965_write(dev, 0, i, &desc, line);
 	}
diff -u -p a/drivers/display/display_dummy.c b/drivers/display/display_dummy.c
--- a/drivers/display/display_dummy.c
+++ b/drivers/display/display_dummy.c
@@ -89,7 +89,7 @@ static void dummy_display_get_capabiliti
 	struct dummy_display_data *disp_data =
 		(struct dummy_display_data *)dev->data;
 
-	memset(capabilities, 0, sizeof(struct display_capabilities));
+	(void) memset(capabilities, 0, sizeof(struct display_capabilities));
 	capabilities->x_resolution = CONFIG_DUMMY_DISPLAY_X_RES;
 	capabilities->y_resolution = CONFIG_DUMMY_DISPLAY_Y_RES;
 	capabilities->supported_pixel_formats = PIXEL_FORMAT_ARGB_8888 |
diff -u -p a/drivers/i2s/i2s_common.c b/drivers/i2s/i2s_common.c
--- a/drivers/i2s/i2s_common.c
+++ b/drivers/i2s/i2s_common.c
@@ -19,7 +19,7 @@ int z_impl_i2s_buf_read(const struct dev
 		struct i2s_config *rx_cfg =
 			i2s_config_get((const struct device *)dev, I2S_DIR_RX);
 
-		memcpy(buf, mem_block, *size);
+		(void) memcpy(buf, mem_block, *size);
 		k_mem_slab_free(rx_cfg->mem_slab, &mem_block);
 	}
 
@@ -46,7 +46,7 @@ int z_impl_i2s_buf_write(const struct de
 		return -ENOMEM;
 	}
 
-	memcpy(mem_block, (void *)buf, size);
+	(void) memcpy(mem_block, (void *)buf, size);
 
 	ret = i2s_write((const struct device *)dev, mem_block, size);
 	if (ret != 0) {
diff -u -p a/drivers/eeprom/eeprom_shell.c b/drivers/eeprom/eeprom_shell.c
--- a/drivers/eeprom/eeprom_shell.c
+++ b/drivers/eeprom/eeprom_shell.c
@@ -165,7 +165,7 @@ static int cmd_fill(const struct shell *
 		shell_error(shell, "Error parsing pattern byte");
 		return -EINVAL;
 	}
-	memset(wr_buf, pattern, len);
+	(void) memset(wr_buf, pattern, len);
 
 	eeprom = device_get_binding(argv[args_indx.device]);
 	if (!eeprom) {
diff -u -p a/drivers/serial/uart_sam0.c b/drivers/serial/uart_sam0.c
--- a/drivers/serial/uart_sam0.c
+++ b/drivers/serial/uart_sam0.c
@@ -496,8 +496,8 @@ static int uart_sam0_config_get(const st
 				struct uart_config *out_cfg)
 {
 	struct uart_sam0_dev_data *const dev_data = DEV_DATA(dev);
-	memcpy(out_cfg, &(dev_data->config_cache),
-				sizeof(dev_data->config_cache));
+	(void) memcpy(out_cfg, &(dev_data->config_cache),
+			sizeof(dev_data->config_cache));
 
 	return 0;
 }
diff -u -p a/soc/xtensa/intel_apl_adsp/adsp.c b/soc/xtensa/intel_apl_adsp/adsp.c
--- a/soc/xtensa/intel_apl_adsp/adsp.c
+++ b/soc/xtensa/intel_apl_adsp/adsp.c
@@ -73,8 +73,8 @@ static void prepare_host_windows(void)
 	sys_write32((HP_SRAM_WIN0_SIZE | 0x7), DMWLO(0));
 	sys_write32((HP_SRAM_WIN0_BASE | DMWBA_READONLY | DMWBA_ENABLE),
 		    DMWBA(0));
-	memset((void *)(HP_SRAM_WIN0_BASE + SRAM_REG_FW_END), 0,
-	      HP_SRAM_WIN0_SIZE - SRAM_REG_FW_END);
+	(void) memset((void *)(HP_SRAM_WIN0_BASE + SRAM_REG_FW_END), 0,
+			HP_SRAM_WIN0_SIZE - SRAM_REG_FW_END);
 	SOC_DCACHE_FLUSH((void *)(HP_SRAM_WIN0_BASE + SRAM_REG_FW_END),
 			 HP_SRAM_WIN0_SIZE - SRAM_REG_FW_END);
 
@@ -82,7 +82,7 @@ static void prepare_host_windows(void)
 		/* window1, for inbox/downlink mbox */
 		sys_write32((HP_SRAM_WIN1_SIZE | 0x7), DMWLO(1));
 		sys_write32((HP_SRAM_WIN1_BASE | DMWBA_ENABLE), DMWBA(1));
-		memset((void *)HP_SRAM_WIN1_BASE, 0, HP_SRAM_WIN1_SIZE);
+		(void) memset((void *)HP_SRAM_WIN1_BASE, 0, HP_SRAM_WIN1_SIZE);
 		SOC_DCACHE_FLUSH((void *)HP_SRAM_WIN1_BASE, HP_SRAM_WIN1_SIZE);
 	}
 
@@ -92,7 +92,7 @@ static void prepare_host_windows(void)
 	sys_write32((HP_SRAM_WIN3_SIZE | 0x7), DMWLO(3));
 	sys_write32((HP_SRAM_WIN3_BASE | DMWBA_READONLY | DMWBA_ENABLE),
 		    DMWBA(3));
-	memset((void *)HP_SRAM_WIN3_BASE, 0, HP_SRAM_WIN3_SIZE);
+	(void) memset((void *)HP_SRAM_WIN3_BASE, 0, HP_SRAM_WIN3_SIZE);
 	SOC_DCACHE_FLUSH((void *)HP_SRAM_WIN3_BASE, HP_SRAM_WIN3_SIZE);
 }
 
@@ -102,11 +102,11 @@ static void prepare_host_windows(void)
  */
 static void send_fw_ready(void)
 {
-	memcpy((void *)MAILBOX_DSPBOX_BASE,
-	       &fw_ready_apl, sizeof(fw_ready_apl));
+	(void) memcpy((void *)MAILBOX_DSPBOX_BASE,
+			&fw_ready_apl, sizeof(fw_ready_apl));
 
-	memcpy((void *)(MAILBOX_DSPBOX_BASE + sizeof(fw_ready_apl)),
-	       &sram_window, sizeof(sram_window));
+	(void) memcpy((void *)(MAILBOX_DSPBOX_BASE + sizeof(fw_ready_apl)),
+			&sram_window, sizeof(sram_window));
 
 	SOC_DCACHE_FLUSH((void *)MAILBOX_DSPBOX_BASE, MAILBOX_DSPBOX_SIZE);
 
diff -u -p a/subsys/emul/i2c/emul_atmel_at24.c b/subsys/emul/i2c/emul_atmel_at24.c
--- a/subsys/emul/i2c/emul_atmel_at24.c
+++ b/subsys/emul/i2c/emul_atmel_at24.c
@@ -92,7 +92,7 @@ static int at24_emul_transfer(struct i2c
 		}
 		data->cur_reg = msgs->buf[0];
 		len = MIN(msgs->len - 1, cfg->size - data->cur_reg);
-		memcpy(&cfg->buf[data->cur_reg], &msgs->buf[1], len);
+		(void) memcpy(&cfg->buf[data->cur_reg], &msgs->buf[1], len);
 		return 0;
 	case 2:
 		if (msgs->flags & I2C_MSG_READ) {
@@ -115,7 +115,7 @@ static int at24_emul_transfer(struct i2c
 
 	/* Read data from the EEPROM into the buffer */
 	len = MIN(msgs->len, cfg->size - data->cur_reg);
-	memcpy(msgs->buf, &cfg->buf[data->cur_reg], len);
+	(void) memcpy(msgs->buf, &cfg->buf[data->cur_reg], len);
 	data->cur_reg += len;
 
 	return 0;
@@ -150,7 +150,7 @@ static int emul_atmel_at24_init(const st
 	data->cur_reg = 0;
 
 	/* Start with an erased EEPROM, assuming all 0xff */
-	memset(cfg->buf, 0xff, cfg->size);
+	(void) memset(cfg->buf, 0xff, cfg->size);
 
 	int rc = i2c_emul_register(parent, emul->dev_label, &data->emul);
 
diff -u -p a/subsys/tracing/tracing_format_common.c b/subsys/tracing/tracing_format_common.c
--- a/subsys/tracing/tracing_format_common.c
+++ b/subsys/tracing/tracing_format_common.c
@@ -71,7 +71,7 @@ bool tracing_format_data_put(tracing_dat
 
 		do {
 			claimed_size = tracing_buffer_put_claim(&buf, length);
-			memcpy(buf, data, claimed_size);
+			(void) memcpy(buf, data, claimed_size);
 			total_size += claimed_size;
 			length -= claimed_size;
 			data += claimed_size;
diff -u -p a/subsys/mgmt/mcumgr/smp_udp.c b/subsys/mgmt/mcumgr/smp_udp.c
--- a/subsys/mgmt/mcumgr/smp_udp.c
+++ b/subsys/mgmt/mcumgr/smp_udp.c
@@ -196,7 +196,7 @@ int smp_udp_open(void)
 #if CONFIG_MCUMGR_SMP_UDP_IPV4
 	struct sockaddr_in addr4;
 
-	memset(&addr4, 0, sizeof(addr4));
+	(void) memset(&addr4, 0, sizeof(addr4));
 	addr4.sin_family = AF_INET;
 	addr4.sin_port = htons(CONFIG_MCUMGR_SMP_UDP_PORT);
 	inet_pton(AF_INET, INADDR_ANY, &addr4.sin_addr);
@@ -214,7 +214,7 @@ int smp_udp_open(void)
 #if CONFIG_MCUMGR_SMP_UDP_IPV6
 	struct sockaddr_in6 addr6;
 
-	memset(&addr6, 0, sizeof(addr6));
+	(void) memset(&addr6, 0, sizeof(addr6));
 	addr6.sin6_family = AF_INET6;
 	addr6.sin6_port = htons(CONFIG_MCUMGR_SMP_UDP_PORT);
 	addr6.sin6_addr = in6addr_any;
diff -u -p a/subsys/mgmt/updatehub/updatehub_device.c b/subsys/mgmt/updatehub/updatehub_device.c
--- a/subsys/mgmt/updatehub/updatehub_device.c
+++ b/subsys/mgmt/updatehub/updatehub_device.c
@@ -17,7 +17,7 @@ bool updatehub_get_device_identity(char 
 		return false;
 	}
 
-	memset(id, 0, id_max_len);
+	(void) memset(id, 0, id_max_len);
 	length = bin2hex(hwinfo_id, length, id, id_max_len - 1);
 
 	return length > 0;
diff -u -p a/subsys/mgmt/osdp/src/osdp.c b/subsys/mgmt/osdp/src/osdp.c
--- a/subsys/mgmt/osdp/src/osdp.c
+++ b/subsys/mgmt/osdp/src/osdp.c
@@ -128,7 +128,7 @@ static struct osdp *osdp_build_ctx(struc
 		pd->__parent = ctx;
 		pd->address = pd_adddres[i];
 		pd->baud_rate = CONFIG_OSDP_UART_BAUD_RATE;
-		memcpy(&pd->channel, channel, sizeof(struct osdp_channel));
+		(void) memcpy(&pd->channel, channel, sizeof(struct osdp_channel));
 		k_mem_slab_init(&pd->cmd.slab,
 				pd->cmd.slab_buf, sizeof(struct osdp_cmd),
 				CONFIG_OSDP_PD_COMMAND_QUEUE_SIZE);
diff -u -p a/subsys/net/l2/ieee802154/ieee802154.c b/subsys/net/l2/ieee802154/ieee802154.c
--- a/subsys/net/l2/ieee802154/ieee802154.c
+++ b/subsys/net/l2/ieee802154/ieee802154.c
@@ -263,8 +263,8 @@ static int ieee802154_send(struct net_if
 			ieee802154_fragment(&f_ctx, &frame_buf, true);
 			buf = f_ctx.buf;
 		} else {
-			memcpy(frame_buf.data + frame_buf.len,
-			       buf->data, buf->len);
+			(void) memcpy(frame_buf.data + frame_buf.len,
+					buf->data, buf->len);
 			net_buf_add(&frame_buf, buf->len);
 			buf = buf->frags;
 		}
@@ -352,7 +352,7 @@ void ieee802154_init(struct net_if *ifac
 #endif
 
 	sys_memcpy_swap(long_addr, mac, 8);
-	memcpy(ctx->ext_addr, long_addr, 8);
+	(void) memcpy(ctx->ext_addr, long_addr, 8);
 	ieee802154_filter_ieee_addr(iface, ctx->ext_addr);
 
 	if (!ieee802154_set_tx_power(iface, tx_power)) {
diff -u -p a/subsys/net/l2/openthread/openthread.c b/subsys/net/l2/openthread/openthread.c
--- a/subsys/net/l2/openthread/openthread.c
+++ b/subsys/net/l2/openthread/openthread.c
@@ -129,7 +129,7 @@ void otPlatRadioGetIeeeEui64(otInstance 
 {
 	ARG_UNUSED(instance);
 
-	memcpy(ieee_eui64, ll_addr->addr, ll_addr->len);
+	(void) memcpy(ieee_eui64, ll_addr->addr, ll_addr->len);
 }
 
 void otTaskletsSignalPending(otInstance *instance)
diff -u -p a/subsys/net/l2/ppp/pap.c b/subsys/net/l2/ppp/pap.c
--- a/subsys/net/l2/ppp/pap.c
+++ b/subsys/net/l2/ppp/pap.c
@@ -121,7 +121,7 @@ static void pap_init(struct ppp_context 
 	NET_DBG("proto %s (0x%04x) fsm %p", ppp_proto2str(PPP_PAP), PPP_PAP,
 		&ctx->pap.fsm);
 
-	memset(&ctx->pap.fsm, 0, sizeof(ctx->pap.fsm));
+	(void) memset(&ctx->pap.fsm, 0, sizeof(ctx->pap.fsm));
 
 	ppp_fsm_init(&ctx->pap.fsm, PPP_PAP);
 
diff -u -p a/subsys/net/l2/ethernet/ethernet.c b/subsys/net/l2/ethernet/ethernet.c
--- a/subsys/net/l2/ethernet/ethernet.c
+++ b/subsys/net/l2/ethernet/ethernet.c
@@ -55,7 +55,7 @@ void net_eth_ipv6_mcast_to_mac_addr(cons
 	 * last four octets are the last four octets of DST."
 	 */
 	mac_addr->addr[0] = mac_addr->addr[1] = 0x33;
-	memcpy(mac_addr->addr + 2, &ipv6_addr->s6_addr[12], 4);
+	(void) memcpy(mac_addr->addr + 2, &ipv6_addr->s6_addr[12], 4);
 }
 
 #define print_ll_addrs(pkt, type, len, src, dst)			   \
@@ -378,11 +378,11 @@ static bool ethernet_fill_in_dst_on_ipv6
 {
 	if (net_pkt_family(pkt) == AF_INET6 &&
 	    net_ipv6_is_addr_mcast(&NET_IPV6_HDR(pkt)->dst)) {
-		memcpy(dst, (uint8_t *)multicast_eth_addr.addr,
-		       sizeof(struct net_eth_addr) - 4);
-		memcpy((uint8_t *)dst + 2,
-		       (uint8_t *)(&NET_IPV6_HDR(pkt)->dst) + 12,
-		       sizeof(struct net_eth_addr) - 2);
+		(void) memcpy(dst, (uint8_t *)multicast_eth_addr.addr,
+				sizeof(struct net_eth_addr) - 4);
+		(void) memcpy((uint8_t *)dst + 2,
+				(uint8_t *)(&NET_IPV6_HDR(pkt)->dst) + 12,
+				sizeof(struct net_eth_addr) - 2);
 
 		return true;
 	}
@@ -485,12 +485,13 @@ static struct net_buf *ethernet_fill_hea
 
 		if (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr_vlan->dst) &&
 		    !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr_vlan->dst)) {
-			memcpy(&hdr_vlan->dst, net_pkt_lladdr_dst(pkt)->addr,
-			       sizeof(struct net_eth_addr));
+			(void) memcpy(&hdr_vlan->dst,
+					net_pkt_lladdr_dst(pkt)->addr,
+					sizeof(struct net_eth_addr));
 		}
 
-		memcpy(&hdr_vlan->src, net_pkt_lladdr_src(pkt)->addr,
-		       sizeof(struct net_eth_addr));
+		(void) memcpy(&hdr_vlan->src, net_pkt_lladdr_src(pkt)->addr,
+				sizeof(struct net_eth_addr));
 
 		hdr_vlan->type = ptype;
 		hdr_vlan->vlan.tpid = htons(NET_ETH_PTYPE_VLAN);
@@ -506,12 +507,13 @@ static struct net_buf *ethernet_fill_hea
 
 		if (!ethernet_fill_in_dst_on_ipv4_mcast(pkt, &hdr->dst) &&
 		    !ethernet_fill_in_dst_on_ipv6_mcast(pkt, &hdr->dst)) {
-			memcpy(&hdr->dst, net_pkt_lladdr_dst(pkt)->addr,
-			       sizeof(struct net_eth_addr));
+			(void) memcpy(&hdr->dst,
+					net_pkt_lladdr_dst(pkt)->addr,
+					sizeof(struct net_eth_addr));
 		}
 
-		memcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,
-		       sizeof(struct net_eth_addr));
+		(void) memcpy(&hdr->src, net_pkt_lladdr_src(pkt)->addr,
+				sizeof(struct net_eth_addr));
 
 		hdr->type = ptype;
 		net_buf_add(hdr_frag, sizeof(struct net_eth_hdr));
diff -u -p a/subsys/net/l2/ethernet/gptp/gptp_user_api.c b/subsys/net/l2/ethernet/gptp/gptp_user_api.c
--- a/subsys/net/l2/ethernet/gptp/gptp_user_api.c
+++ b/subsys/net/l2/ethernet/gptp/gptp_user_api.c
@@ -87,8 +87,8 @@ void gptp_clk_src_time_invoke(struct gpt
 
 	state = &GPTP_STATE()->clk_master_sync_receive;
 
-	memcpy(&state->rcvd_clk_src_req, arg,
-	       sizeof(struct gptp_clk_src_time_invoke_params));
+	(void) memcpy(&state->rcvd_clk_src_req, arg,
+			sizeof(struct gptp_clk_src_time_invoke_params));
 
 	state->rcvd_clock_source_req = true;
 }
diff -u -p a/subsys/net/l2/canbus/6locan.c b/subsys/net/l2/canbus/6locan.c
--- a/subsys/net/l2/canbus/6locan.c
+++ b/subsys/net/l2/canbus/6locan.c
@@ -914,16 +914,16 @@ static inline int canbus_send_ff(struct 
 
 	if (!mcast && canbus_dest_is_translator(pkt)) {
 		lladdr_inline = net_pkt_lladdr_dst(pkt);
-		memcpy(&frame.data[index], lladdr_inline->addr,
-		       lladdr_inline->len);
+		(void) memcpy(&frame.data[index], lladdr_inline->addr,
+				lladdr_inline->len);
 		index += lladdr_inline->len;
 	}
 
 	if (IS_ENABLED(CONFIG_NET_L2_CANBUS_ETH_TRANSLATOR) &&
 	    net_pkt_lladdr_src(pkt)->type == NET_LINK_ETHERNET) {
 		lladdr_inline = net_pkt_lladdr_src(pkt);
-		memcpy(&frame.data[index], lladdr_inline->addr,
-		       lladdr_inline->len);
+		(void) memcpy(&frame.data[index], lladdr_inline->addr,
+				lladdr_inline->len);
 		index += lladdr_inline->len;
 	}
 
@@ -960,7 +960,7 @@ static inline int canbus_send_single_fra
 
 	if (!mcast && canbus_dest_is_translator(pkt)) {
 		lladdr_dest = net_pkt_lladdr_dst(pkt);
-		memcpy(&frame.data[index], lladdr_dest->addr, lladdr_dest->len);
+		(void) memcpy(&frame.data[index], lladdr_dest->addr, lladdr_dest->len);
 		index += lladdr_dest->len;
 	}
 
@@ -1321,8 +1321,8 @@ static void extend_llao(struct net_pkt *
 		goto done;
 	}
 
-	memcpy(llao_backup, llao, sizeof(struct net_canbus_lladdr));
-	memcpy(llao, mac_addr->addr, mac_addr->len);
+	(void) memcpy(llao_backup, llao, sizeof(struct net_canbus_lladdr));
+	(void) memcpy(llao, mac_addr->addr, mac_addr->len);
 
 	llao[4] = (llao[4] & 0xC0) | llao_backup[0];
 	llao[5] = llao_backup[1];
@@ -1382,8 +1382,8 @@ static void can_to_eth_lladdr(struct net
 
 	lladdr_src->addr = net_pkt_lladdr_src(pkt)->addr -
 			   (sizeof(struct net_eth_addr) - lladdr_src->len);
-	memcpy(lladdr_src->addr, net_if_get_link_addr(eth_iface)->addr,
-	       sizeof(struct net_eth_addr));
+	(void) memcpy(lladdr_src->addr, net_if_get_link_addr(eth_iface)->addr,
+			sizeof(struct net_eth_addr));
 	lladdr_src->addr[4] = (lladdr_src->addr[4] & 0xC0) | (src_can_addr >> 8U);
 	lladdr_src->addr[5] = src_can_addr & 0xFF;
 	lladdr_src->len = sizeof(struct net_eth_addr);
diff -u -p a/subsys/net/lib/sockets/sockets_tls.c b/subsys/net/lib/sockets/sockets_tls.c
--- a/subsys/net/lib/sockets/sockets_tls.c
+++ b/subsys/net/lib/sockets/sockets_tls.c
@@ -372,8 +372,8 @@ static struct tls_context *tls_clone(str
 	target_tls->tls_version = source_tls->tls_version;
 	target_tls->type = source_tls->type;
 
-	memcpy(&target_tls->options, &source_tls->options,
-	       sizeof(target_tls->options));
+	(void) memcpy(&target_tls->options, &source_tls->options,
+			sizeof(target_tls->options));
 
 #if defined(MBEDTLS_X509_CRT_PARSE_C)
 	if (target_tls->options.is_hostname_set) {
@@ -456,7 +456,7 @@ static void dtls_peer_address_set(struct
 				  socklen_t addrlen)
 {
 	if (addrlen <= sizeof(context->dtls_peer_addr)) {
-		memcpy(&context->dtls_peer_addr, peer_addr, addrlen);
+		(void) memcpy(&context->dtls_peer_addr, peer_addr, addrlen);
 		context->dtls_peer_addrlen = addrlen;
 	}
 }
@@ -467,7 +467,7 @@ static void dtls_peer_address_get(struct
 {
 	socklen_t len = MIN(context->dtls_peer_addrlen, *addrlen);
 
-	memcpy(peer_addr, &context->dtls_peer_addr, len);
+	(void) memcpy(peer_addr, &context->dtls_peer_addr, len);
 	*addrlen = len;
 }
 
@@ -953,7 +953,7 @@ static int tls_opt_sec_tag_list_set(stru
 		return -EINVAL;
 	}
 
-	memcpy(context->options.sec_tag_list.sec_tags, optval, optlen);
+	(void) memcpy(context->options.sec_tag_list.sec_tags, optval, optlen);
 	context->options.sec_tag_list.sec_tag_count = sec_tag_cnt;
 
 	return 0;
@@ -971,7 +971,7 @@ static int tls_opt_sec_tag_list_get(stru
 	len = MIN(context->options.sec_tag_list.sec_tag_count *
 		  sizeof(sec_tag_t), *optlen);
 
-	memcpy(optval, context->options.sec_tag_list.sec_tags, len);
+	(void) memcpy(optval, context->options.sec_tag_list.sec_tags, len);
 	*optlen = len;
 
 	return 0;
@@ -1015,7 +1015,7 @@ static int tls_opt_ciphersuite_list_set(
 		return -EINVAL;
 	}
 
-	memcpy(context->options.ciphersuites, optval, optlen);
+	(void) memcpy(context->options.ciphersuites, optval, optlen);
 	context->options.ciphersuites[cipher_cnt] = 0;
 
 	return 0;
diff -u -p a/subsys/net/lib/sockets/getaddrinfo.c b/subsys/net/lib/sockets/getaddrinfo.c
--- a/subsys/net/lib/sockets/getaddrinfo.c
+++ b/subsys/net/lib/sockets/getaddrinfo.c
@@ -75,12 +75,12 @@ static void dns_resolve_cb(enum dns_reso
 	}
 
 	ai = &state->ai_arr[state->idx];
-	memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);
+	(void) memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen);
 	net_sin(&ai->_ai_addr)->sin_port = state->port;
 	ai->ai_addr = &ai->_ai_addr;
 	ai->ai_addrlen = info->ai_addrlen;
-	memcpy(&ai->_ai_canonname, &info->ai_canonname,
-	       sizeof(ai->_ai_canonname));
+	(void) memcpy(&ai->_ai_canonname, &info->ai_canonname,
+			sizeof(ai->_ai_canonname));
 	ai->ai_canonname = ai->_ai_canonname;
 	ai->ai_family = info->ai_family;
 
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_rw_json.c b/subsys/net/lib/lwm2m/lwm2m_rw_json.c
--- a/subsys/net/lib/lwm2m/lwm2m_rw_json.c
+++ b/subsys/net/lib/lwm2m/lwm2m_rw_json.c
@@ -827,7 +827,7 @@ int do_write_op_json(struct lwm2m_messag
 	engine_set_in_user_data(&msg->in, &fd);
 
 	/* store a copy of the original path */
-	memcpy(&orig_path, &msg->path, sizeof(msg->path));
+	(void) memcpy(&orig_path, &msg->path, sizeof(msg->path));
 
 	/* PARSE base name "bn" */
 	json_next_token(&msg->in, &fd);
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c b/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c
--- a/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c
+++ b/subsys/net/lib/lwm2m/lwm2m_obj_firmware_pull.c
@@ -272,8 +272,8 @@ do_firmware_transfer_reply_cb(const stru
 	}
 
 	/* save main firmware block context */
-	memcpy(&received_block_ctx, &firmware_block_ctx,
-	       sizeof(firmware_block_ctx));
+	(void) memcpy(&received_block_ctx, &firmware_block_ctx,
+			sizeof(firmware_block_ctx));
 
 	ret = coap_update_from_block(check_response, &firmware_block_ctx);
 	if (ret < 0) {
@@ -287,8 +287,8 @@ do_firmware_transfer_reply_cb(const stru
 		LOG_WRN("Duplicate packet ignored");
 
 		/* restore main firmware block context */
-		memcpy(&firmware_block_ctx, &received_block_ctx,
-		       sizeof(firmware_block_ctx));
+		(void) memcpy(&firmware_block_ctx, &received_block_ctx,
+				sizeof(firmware_block_ctx));
 
 		/* set reply->user_data to error to avoid releasing */
 		reply->user_data = (void *)COAP_REPLY_STATUS_ERROR;
diff -u -p a/subsys/net/lib/mqtt/mqtt_encoder.c b/subsys/net/lib/mqtt/mqtt_encoder.c
--- a/subsys/net/lib/mqtt/mqtt_encoder.c
+++ b/subsys/net/lib/mqtt/mqtt_encoder.c
@@ -104,7 +104,7 @@ static int pack_utf8_str(const struct mq
 	/* Pack length followed by string. */
 	(void)pack_uint16(str->size, buf);
 
-	memcpy(buf->cur, str->utf8, str->size);
+	(void) memcpy(buf->cur, str->utf8, str->size);
 	buf->cur += str->size;
 
 	return 0;
@@ -472,7 +472,7 @@ int disconnect_encode(struct buf_ctx *bu
 		return -ENOMEM;
 	}
 
-	memcpy(buf->cur, disc_packet, sizeof(disc_packet));
+	(void) memcpy(buf->cur, disc_packet, sizeof(disc_packet));
 	buf->end = buf->cur + sizeof(disc_packet);
 
 	return 0;
@@ -548,7 +548,7 @@ int ping_request_encode(struct buf_ctx *
 		return -ENOMEM;
 	}
 
-	memcpy(buf->cur, ping_packet, sizeof(ping_packet));
+	(void) memcpy(buf->cur, ping_packet, sizeof(ping_packet));
 	buf->end = buf->cur + sizeof(ping_packet);
 
 	return 0;
diff -u -p a/subsys/net/lib/dns/dns_pack.c b/subsys/net/lib/dns/dns_pack.c
--- a/subsys/net/lib/dns/dns_pack.c
+++ b/subsys/net/lib/dns/dns_pack.c
@@ -285,7 +285,7 @@ int dns_msg_pack_query(uint8_t *buf, uin
 	}
 
 	offset = DNS_MSG_HEADER_SIZE;
-	memcpy(buf + offset, qname, qname_len);
+	(void) memcpy(buf + offset, qname, qname_len);
 
 	offset += qname_len;
 
@@ -398,7 +398,7 @@ int dns_copy_qname(uint8_t *buf, uint16_
 		}
 
 		/* copy the lb_size value and label elements */
-		memcpy(buf + *len, msg + pos, DNS_LABEL_LEN_SIZE + lb_size);
+		(void) memcpy(buf + *len, msg + pos, DNS_LABEL_LEN_SIZE + lb_size);
 		/* update destination buffer len */
 		*len += DNS_LABEL_LEN_SIZE + lb_size;
 		/* update msg ptr position */
diff -u -p a/subsys/net/lib/coap/coap.c b/subsys/net/lib/coap/coap.c
--- a/subsys/net/lib/coap/coap.c
+++ b/subsys/net/lib/coap/coap.c
@@ -92,7 +92,7 @@ static inline bool append(struct coap_pa
 		return false;
 	}
 
-	memcpy(cpkt->data + cpkt->offset, data, len);
+	(void) memcpy(cpkt->data + cpkt->offset, data, len);
 	cpkt->offset += len;
 
 	return true;
@@ -109,7 +109,7 @@ int coap_packet_init(struct coap_packet 
 		return -EINVAL;
 	}
 
-	memset(cpkt, 0, sizeof(*cpkt));
+	(void) memset(cpkt, 0, sizeof(*cpkt));
 
 	cpkt->data = data;
 	cpkt->offset = 0U;
@@ -385,7 +385,7 @@ static int read(uint8_t *data, uint16_t 
 		return -EINVAL;
 	}
 
-	memcpy(value, data + offset, len);
+	(void) memcpy(value, data + offset, len);
 	offset += len;
 	*pos = offset;
 
@@ -551,7 +551,7 @@ int coap_packet_parse(struct coap_packet
 	}
 
 	if (options) {
-		memset(options, 0, opt_num * sizeof(struct coap_option));
+		(void) memset(options, 0, opt_num * sizeof(struct coap_option));
 	}
 
 	cpkt->data = data;
@@ -673,7 +673,7 @@ uint8_t coap_header_get_token(const stru
 
 	tkl = cpkt->data[0] & 0x0f;
 	if (tkl) {
-		memcpy(token, cpkt->data + BASIC_HEADER_SIZE, tkl);
+		(void) memcpy(token, cpkt->data + BASIC_HEADER_SIZE, tkl);
 	}
 
 	return tkl;
@@ -1074,11 +1074,11 @@ int coap_pending_init(struct coap_pendin
 		      const struct coap_packet *request,
 		      const struct sockaddr *addr)
 {
-	memset(pending, 0, sizeof(*pending));
+	(void) memset(pending, 0, sizeof(*pending));
 
 	pending->id = coap_header_get_id(request);
 
-	memcpy(&pending->addr, addr, sizeof(*addr));
+	(void) memcpy(&pending->addr, addr, sizeof(*addr));
 
 	pending->data = request->data;
 	pending->len = request->offset;
@@ -1303,7 +1303,7 @@ void coap_reply_init(struct coap_reply *
 	tkl = coap_header_get_token(request, (uint8_t *)&token);
 
 	if (tkl > 0) {
-		memcpy(reply->token, token, tkl);
+		(void) memcpy(reply->token, token, tkl);
 	}
 
 	reply->tkl = tkl;
diff -u -p a/subsys/net/ip/net_stats.c b/subsys/net/ip/net_stats.c
--- a/subsys/net/ip/net_stats.c
+++ b/subsys/net/ip/net_stats.c
@@ -309,7 +309,7 @@ static int net_stats_get(uint32_t mgmt_r
 		return -EINVAL;
 	}
 
-	memcpy(data, src, len);
+	(void) memcpy(data, src, len);
 
 	return 0;
 }
@@ -371,5 +371,5 @@ void net_stats_reset(struct net_if *ifac
 	}
 
 	net_if_stats_reset_all();
-	memset(&net_stats, 0, sizeof(net_stats));
+	(void) memset(&net_stats, 0, sizeof(net_stats));
 }
diff -u -p a/subsys/net/ip/net_if.c b/subsys/net/ip/net_if.c
--- a/subsys/net/ip/net_if.c
+++ b/subsys/net/ip/net_if.c
@@ -254,8 +254,9 @@ static bool net_if_tx(struct net_if *ifa
 		}
 
 		if (IS_ENABLED(CONFIG_NET_PKT_TXTIME_STATS)) {
-			memcpy(&start_timestamp, net_pkt_timestamp(pkt),
-			       sizeof(start_timestamp));
+			(void) memcpy(&start_timestamp,
+					net_pkt_timestamp(pkt),
+					sizeof(start_timestamp));
 			pkt_priority = net_pkt_priority(pkt);
 
 			if (IS_ENABLED(CONFIG_NET_PKT_TXTIME_STATS_DETAIL)) {
@@ -394,7 +395,7 @@ void net_if_stats_reset(struct net_if *i
 #if defined(CONFIG_NET_STATISTICS_PER_INTERFACE)
 	Z_STRUCT_SECTION_FOREACH(net_if, tmp) {
 		if (iface == tmp) {
-			memset(&iface->stats, 0, sizeof(iface->stats));
+			(void) memset(&iface->stats, 0, sizeof(iface->stats));
 			return;
 		}
 	}
@@ -406,7 +407,7 @@ void net_if_stats_reset_all(void)
 #if defined(CONFIG_NET_STATISTICS_PER_INTERFACE)
 
 	Z_STRUCT_SECTION_FOREACH(net_if, iface) {
-		memset(&iface->stats, 0, sizeof(iface->stats));
+		(void) memset(&iface->stats, 0, sizeof(iface->stats));
 	}
 #endif
 }
@@ -760,8 +761,8 @@ static struct net_if_router *iface_route
 		}
 
 		if (IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
-			memcpy(net_if_router_ipv6(&routers[i]), addr,
-			       sizeof(struct in6_addr));
+			(void) memcpy(net_if_router_ipv6(&routers[i]), addr,
+					sizeof(struct in6_addr));
 			net_mgmt_event_notify_with_info(
 					NET_EVENT_IPV6_ROUTER_ADD, iface,
 					&routers[i].address.in6_addr,
@@ -773,8 +774,8 @@ static struct net_if_router *iface_route
 						   (struct in6_addr *)addr)),
 				lifetime, routers[i].is_default);
 		} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
-			memcpy(net_if_router_ipv4(&routers[i]), addr,
-			       sizeof(struct in_addr));
+			(void) memcpy(net_if_router_ipv4(&routers[i]), addr,
+					sizeof(struct in_addr));
 			routers[i].is_default = is_default;
 
 			net_mgmt_event_notify_with_info(
@@ -1734,7 +1735,7 @@ struct net_if_mcast_addr *net_if_ipv6_ma
 
 		ipv6->mcast[i].is_used = true;
 		ipv6->mcast[i].address.family = AF_INET6;
-		memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
+		(void) memcpy(&ipv6->mcast[i].address.in6_addr, addr, 16);
 
 		NET_DBG("[%d] interface %p address %s added", i, iface,
 			log_strdup(net_sprint_ipv6_addr(addr)));
diff -u -p a/subsys/net/ip/dhcpv4.c b/subsys/net/ip/dhcpv4.c
--- a/subsys/net/ip/dhcpv4.c
+++ b/subsys/net/ip/dhcpv4.c
@@ -224,11 +224,11 @@ static struct net_pkt *dhcpv4_create_mes
 		 * asked to send a ciaddr then fill it in now
 		 * otherwise leave it as all zeros.
 		 */
-		memcpy(msg->ciaddr, ciaddr, 4);
+		(void) memcpy(msg->ciaddr, ciaddr, 4);
 	}
 
-	memcpy(msg->chaddr, net_if_get_link_addr(iface)->addr,
-	       net_if_get_link_addr(iface)->len);
+	(void) memcpy(msg->chaddr, net_if_get_link_addr(iface)->addr,
+			net_if_get_link_addr(iface)->len);
 
 	if (net_pkt_set_data(pkt, &dhcp_access)) {
 		goto fail;
@@ -991,8 +991,8 @@ static enum net_verdict net_dhcpv4_input
 		return NET_DROP;
 	}
 
-	memcpy(iface->config.dhcpv4.requested_ip.s4_addr,
-	       msg->yiaddr, sizeof(msg->yiaddr));
+	(void) memcpy(iface->config.dhcpv4.requested_ip.s4_addr,
+			msg->yiaddr, sizeof(msg->yiaddr));
 
 	net_pkt_acknowledge_data(pkt, &dhcp_access);
 
diff -u -p a/subsys/net/buf.c b/subsys/net/buf.c
--- a/subsys/net/buf.c
+++ b/subsys/net/buf.c
@@ -108,7 +108,7 @@ static uint8_t *mem_pool_data_alloc(stru
 	}
 
 	/* save the block descriptor info at the start of the actual block */
-	memcpy(block.data, &block.id, sizeof(block.id));
+	(void) memcpy(block.data, &block.id, sizeof(block.id));
 
 	ref_count = (uint8_t *)block.data + sizeof(block.id);
 	*ref_count = 1U;
@@ -128,7 +128,7 @@ static void mem_pool_data_unref(struct n
 	}
 
 	/* Need to copy to local variable due to alignment */
-	memcpy(&id, ref_count - sizeof(id), sizeof(id));
+	(void) memcpy(&id, ref_count - sizeof(id), sizeof(id));
 	k_mem_pool_free_id(&id);
 }
 
@@ -715,7 +715,7 @@ size_t net_buf_linearize(void *dst, size
 	copied = 0;
 	while (frag && len > 0) {
 		to_copy = MIN(len, frag->len - offset);
-		memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
+		(void) memcpy((uint8_t *)dst + copied, frag->data + offset, to_copy);
 
 		copied += to_copy;
 
@@ -781,7 +781,7 @@ size_t net_buf_append_bytes(struct net_b
 void net_buf_simple_clone(const struct net_buf_simple *original,
 			  struct net_buf_simple *clone)
 {
-	memcpy(clone, original, sizeof(struct net_buf_simple));
+	(void) memcpy(clone, original, sizeof(struct net_buf_simple));
 }
 
 void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
diff -u -p a/subsys/shell/shell.c b/subsys/shell/shell.c
--- a/subsys/shell/shell.c
+++ b/subsys/shell/shell.c
@@ -240,7 +240,7 @@ static bool tab_prepare(const struct she
 	}
 
 	/* Copy command from its beginning to cursor position. */
-	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
+	(void) memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
 			shell->ctx->cmd_buff_pos);
 	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
 
@@ -589,7 +589,7 @@ static int execute(const struct shell *s
 		cursor_next_line_move(shell);
 	}
 
-	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
+	(void) memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
 
 	shell_cmd_trim(shell);
 
@@ -1095,7 +1095,7 @@ static int instance_init(const struct sh
 	__ASSERT_NO_MSG((shell->shell_flag == SHELL_FLAG_CRLF_DEFAULT) ||
 			(shell->shell_flag == SHELL_FLAG_OLF_CRLF));
 
-	memset(shell->ctx, 0, sizeof(*shell->ctx));
+	(void) memset(shell->ctx, 0, sizeof(*shell->ctx));
 	shell->ctx->prompt = shell->default_prompt;
 
 	history_init(shell);
diff -u -p a/subsys/shell/shell_utils.c b/subsys/shell/shell_utils.c
--- a/subsys/shell/shell_utils.c
+++ b/subsys/shell/shell_utils.c
@@ -380,7 +380,7 @@ int shell_command_add(char *buff, uint16
 
 	/* make place for new command: + 1 for space + 1 for EOS */
 	memmove(cmd_source_addr + cmd_len + 1, cmd_source_addr, shift + 1);
-	memcpy(cmd_source_addr, new_cmd, cmd_len);
+	(void) memcpy(cmd_source_addr, new_cmd, cmd_len);
 	cmd_source_addr[cmd_len] = ' ';
 
 	*buff_len += cmd_len + 1; /* + 1 for space */
diff -u -p a/subsys/fb/cfb.c b/subsys/fb/cfb.c
--- a/subsys/fb/cfb.c
+++ b/subsys/fb/cfb.c
@@ -172,7 +172,7 @@ int cfb_framebuffer_clear(const struct d
 	desc.width = fb->x_res;
 	desc.height = fb->y_res;
 	desc.pitch = fb->x_res;
-	memset(fb->buf, 0, fb->size);
+	(void) memset(fb->buf, 0, fb->size);
 
 	return 0;
 }
@@ -312,7 +312,7 @@ int cfb_framebuffer_init(const struct de
 		return -1;
 	}
 
-	memset(fb->buf, 0, fb->size);
+	(void) memset(fb->buf, 0, fb->size);
 
 	return 0;
 }
diff -u -p a/subsys/usb/class/usb_dfu.c b/subsys/usb/class/usb_dfu.c
--- a/subsys/usb/class/usb_dfu.c
+++ b/subsys/usb/class/usb_dfu.c
@@ -454,7 +454,7 @@ static int dfu_class_handle_req(struct u
 			dfu_data.state = dfuDNBUSY;
 			dfu_data_worker.worker_state = dfuIDLE;
 			dfu_data_worker.worker_len  = pSetup->wLength;
-			memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
+			(void) memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
 			k_work_submit(&dfu_work);
 			break;
 		case dfuDNLOAD_IDLE:
@@ -466,7 +466,7 @@ static int dfu_class_handle_req(struct u
 				k_poll_signal_raise(&dfu_signal, 0);
 			}
 
-			memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
+			(void) memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
 			k_work_submit(&dfu_work);
 			break;
 		default:
diff -u -p a/subsys/usb/class/netusb/function_rndis.c b/subsys/usb/class/netusb/function_rndis.c
--- a/subsys/usb/class/netusb/function_rndis.c
+++ b/subsys/usb/class/netusb/function_rndis.c
@@ -620,13 +620,13 @@ static int rndis_query_handle(uint8_t *d
 		/* IEEE 802.3 */
 	case RNDIS_OBJECT_ID_802_3_PERMANENT_ADDRESS:
 		LOG_DBG("RNDIS_OBJECT_ID_802_3_PERMANENT_ADDRESS");
-		memcpy(net_buf_add(buf, sizeof(rndis.mac)), rndis.mac,
-		       sizeof(rndis.mac));
+		(void) memcpy(net_buf_add(buf, sizeof(rndis.mac)), rndis.mac,
+				sizeof(rndis.mac));
 		break;
 	case RNDIS_OBJECT_ID_802_3_CURR_ADDRESS:
 		LOG_DBG("RNDIS_OBJECT_ID_802_3_CURR_ADDRESS");
-		memcpy(net_buf_add(buf, sizeof(rndis.mac)), rndis.mac,
-		       sizeof(rndis.mac));
+		(void) memcpy(net_buf_add(buf, sizeof(rndis.mac)), rndis.mac,
+				sizeof(rndis.mac));
 		break;
 	case RNDIS_OBJECT_ID_802_3_MCAST_LIST:
 		LOG_DBG("RNDIS_OBJECT_ID_802_3_MCAST_LIST");
@@ -644,8 +644,9 @@ static int rndis_query_handle(uint8_t *d
 		break;
 	case RNDIS_OBJECT_ID_GEN_VENDOR_DESC:
 		LOG_DBG("RNDIS_OBJECT_ID_GEN_VENDOR_DESC");
-		memcpy(net_buf_add(buf, sizeof(manufacturer) - 1), manufacturer,
-		       sizeof(manufacturer) - 1);
+		(void) memcpy(net_buf_add(buf, sizeof(manufacturer) - 1),
+				manufacturer,
+				sizeof(manufacturer) - 1);
 		break;
 	case RNDIS_OBJECT_ID_GEN_VENDOR_DRV_VER:
 		LOG_DBG("RNDIS_OBJECT_ID_GEN_VENDOR_DRV_VER");
@@ -818,7 +819,7 @@ static int queue_encapsulated_cmd(uint8_
 		return -ENOMEM;
 	}
 
-	memcpy(net_buf_add(buf, len), data, len);
+	(void) memcpy(net_buf_add(buf, len), data, len);
 
 	net_buf_put(&rndis_cmd_queue, buf);
 
@@ -882,7 +883,7 @@ static int handle_encapsulated_rsp(uint8
 		net_hexdump("RSP <", buf->data, buf->len);
 	}
 
-	memcpy(*data, buf->data, buf->len);
+	(void) memcpy(*data, buf->data, buf->len);
 	*len = buf->len;
 
 	net_buf_unref(buf);
diff -u -p a/subsys/bluetooth/mesh/health_cli.c b/subsys/bluetooth/mesh/health_cli.c
--- a/subsys/bluetooth/mesh/health_cli.c
+++ b/subsys/bluetooth/mesh/health_cli.c
@@ -78,7 +78,7 @@ static void health_fault_status(struct b
 		*param->fault_count = buf->len;
 	}
 
-	memcpy(param->faults, buf->data, *param->fault_count);
+	(void) memcpy(param->faults, buf->data, *param->fault_count);
 
 	k_sem_give(&health_cli->op_sync);
 }
diff -u -p a/subsys/bluetooth/mesh/shell.c b/subsys/bluetooth/mesh/shell.c
--- a/subsys/bluetooth/mesh/shell.c
+++ b/subsys/bluetooth/mesh/shell.c
@@ -418,7 +418,7 @@ static int cmd_uuid(const struct shell *
 		return -EINVAL;
 	}
 
-	memcpy(dev_uuid, uuid, len);
+	(void) memcpy(dev_uuid, uuid, len);
 	(void)memset(dev_uuid + len, 0, sizeof(dev_uuid) - len);
 
 	shell_print(shell, "Device UUID set");
@@ -966,7 +966,7 @@ static int cmd_net_key_add(const struct 
 			      key_val, sizeof(key_val));
 		(void)memset(key_val, 0, sizeof(key_val) - len);
 	} else {
-		memcpy(key_val, default_key, sizeof(key_val));
+		(void) memcpy(key_val, default_key, sizeof(key_val));
 	}
 
 	if (IS_ENABLED(CONFIG_BT_MESH_CDB)) {
@@ -981,7 +981,7 @@ static int cmd_net_key_add(const struct 
 				return 0;
 			}
 
-			memcpy(key_val, subnet->keys[0].net_key, 16);
+			(void) memcpy(key_val, subnet->keys[0].net_key, 16);
 		} else {
 			subnet = bt_mesh_cdb_subnet_alloc(key_net_idx);
 			if (!subnet) {
@@ -990,7 +990,7 @@ static int cmd_net_key_add(const struct 
 				return 0;
 			}
 
-			memcpy(subnet->keys[0].net_key, key_val, 16);
+			(void) memcpy(subnet->keys[0].net_key, key_val, 16);
 			bt_mesh_cdb_subnet_store(subnet);
 		}
 	}
@@ -1082,7 +1082,7 @@ static int cmd_app_key_add(const struct 
 			      key_val, sizeof(key_val));
 		(void)memset(key_val, 0, sizeof(key_val) - len);
 	} else {
-		memcpy(key_val, default_key, sizeof(key_val));
+		(void) memcpy(key_val, default_key, sizeof(key_val));
 	}
 
 	if (IS_ENABLED(CONFIG_BT_MESH_CDB)) {
@@ -1098,7 +1098,7 @@ static int cmd_app_key_add(const struct 
 				return 0;
 			}
 
-			memcpy(key_val, app_key->keys[0].app_key, 16);
+			(void) memcpy(key_val, app_key->keys[0].app_key, 16);
 		} else {
 			app_key = bt_mesh_cdb_app_key_alloc(key_net_idx,
 							    key_app_idx);
@@ -1108,7 +1108,7 @@ static int cmd_app_key_add(const struct 
 				return 0;
 			}
 
-			memcpy(app_key->keys[0].app_key, key_val, 16);
+			(void) memcpy(app_key->keys[0].app_key, key_val, 16);
 			bt_mesh_cdb_app_key_store(app_key);
 		}
 	}
@@ -2313,7 +2313,7 @@ static int cmd_cdb_create(const struct s
 	} else {
 		len = hex2bin(argv[1], strlen(argv[1]), net_key,
 			      sizeof(net_key));
-		memset(net_key + len, 0, sizeof(net_key) - len);
+		(void) memset(net_key + len, 0, sizeof(net_key) - len);
 	}
 
 	err = bt_mesh_cdb_create(net_key);
@@ -2441,7 +2441,7 @@ static int cmd_cdb_node_add(const struct
 	size_t len;
 
 	len = hex2bin(argv[1], strlen(argv[1]), uuid, sizeof(uuid));
-	memset(uuid + len, 0, sizeof(uuid) - len);
+	(void) memset(uuid + len, 0, sizeof(uuid) - len);
 
 	addr = strtoul(argv[2], NULL, 0);
 	num_elem = strtoul(argv[3], NULL, 0);
@@ -2452,7 +2452,7 @@ static int cmd_cdb_node_add(const struct
 	} else {
 		len = hex2bin(argv[5], strlen(argv[5]), dev_key,
 			      sizeof(dev_key));
-		memset(dev_key + len, 0, sizeof(dev_key) - len);
+		(void) memset(dev_key + len, 0, sizeof(dev_key) - len);
 	}
 
 	node = bt_mesh_cdb_node_alloc(uuid, addr, num_elem, net_idx);
@@ -2461,7 +2461,7 @@ static int cmd_cdb_node_add(const struct
 		return 0;
 	}
 
-	memcpy(node->dev_key, dev_key, 16);
+	(void) memcpy(node->dev_key, dev_key, 16);
 
 	if (IS_ENABLED(CONFIG_SETTINGS)) {
 		bt_mesh_store_cdb_node(node);
@@ -2508,7 +2508,7 @@ static int cmd_cdb_subnet_add(const stru
 	} else {
 		len = hex2bin(argv[2], strlen(argv[2]), net_key,
 			      sizeof(net_key));
-		memset(net_key + len, 0, sizeof(net_key) - len);
+		(void) memset(net_key + len, 0, sizeof(net_key) - len);
 	}
 
 	sub = bt_mesh_cdb_subnet_alloc(net_idx);
@@ -2517,7 +2517,7 @@ static int cmd_cdb_subnet_add(const stru
 		return 0;
 	}
 
-	memcpy(sub->keys[0].net_key, net_key, 16);
+	(void) memcpy(sub->keys[0].net_key, net_key, 16);
 
 	if (IS_ENABLED(CONFIG_SETTINGS)) {
 		bt_mesh_store_cdb_subnet(sub);
@@ -2565,7 +2565,7 @@ static int cmd_cdb_app_key_add(const str
 	} else {
 		len = hex2bin(argv[3], strlen(argv[3]), app_key,
 			      sizeof(app_key));
-		memset(app_key + len, 0, sizeof(app_key) - len);
+		(void) memset(app_key + len, 0, sizeof(app_key) - len);
 	}
 
 	key = bt_mesh_cdb_app_key_alloc(net_idx, app_idx);
@@ -2574,7 +2574,7 @@ static int cmd_cdb_app_key_add(const str
 		return 0;
 	}
 
-	memcpy(key->keys[0].app_key, app_key, 16);
+	(void) memcpy(key->keys[0].app_key, app_key, 16);
 
 	if (IS_ENABLED(CONFIG_SETTINGS)) {
 		bt_mesh_store_cdb_app_key(key);
diff -u -p a/subsys/bluetooth/mesh/friend.c b/subsys/bluetooth/mesh/friend.c
--- a/subsys/bluetooth/mesh/friend.c
+++ b/subsys/bluetooth/mesh/friend.c
@@ -501,7 +501,7 @@ static struct net_buf *encode_friend_ctl
 	info.ctl = 1U;
 	info.ttl = 0U;
 
-	memset(info.seq, 0, sizeof(info.seq));
+	(void) memset(info.seq, 0, sizeof(info.seq));
 
 	info.iv_index = BT_MESH_NET_IVI_TX;
 
diff -u -p a/subsys/bluetooth/host/monitor.c b/subsys/bluetooth/host/monitor.c
--- a/subsys/bluetooth/host/monitor.c
+++ b/subsys/bluetooth/host/monitor.c
@@ -175,7 +175,7 @@ void bt_monitor_new_index(uint8_t type, 
 
 	pkt.type = type;
 	pkt.bus = bus;
-	memcpy(pkt.bdaddr, addr, 6);
+	(void) memcpy(pkt.bdaddr, addr, 6);
 	strncpy(pkt.name, name, sizeof(pkt.name) - 1);
 	pkt.name[sizeof(pkt.name) - 1] = '\0';
 
diff -u -p a/subsys/bluetooth/host/ssp.c b/subsys/bluetooth/host/ssp.c
--- a/subsys/bluetooth/host/ssp.c
+++ b/subsys/bluetooth/host/ssp.c
@@ -454,7 +454,7 @@ void hci_evt_link_key_notify(struct net_
 					      BT_CONN_BR_LEGACY_SECURE)) {
 			conn->br.link_key->flags |= BT_LINK_KEY_AUTHENTICATED;
 		}
-		memcpy(conn->br.link_key->val, evt->link_key, 16);
+		(void) memcpy(conn->br.link_key->val, evt->link_key, 16);
 		break;
 	case BT_LK_AUTH_COMBINATION_P192:
 		conn->br.link_key->flags |= BT_LINK_KEY_AUTHENTICATED;
@@ -465,7 +465,7 @@ void hci_evt_link_key_notify(struct net_
 			atomic_set_bit(conn->flags, BT_CONN_BR_NOBOND);
 		}
 
-		memcpy(conn->br.link_key->val, evt->link_key, 16);
+		(void) memcpy(conn->br.link_key->val, evt->link_key, 16);
 		break;
 	case BT_LK_AUTH_COMBINATION_P256:
 		conn->br.link_key->flags |= BT_LINK_KEY_AUTHENTICATED;
@@ -478,7 +478,7 @@ void hci_evt_link_key_notify(struct net_
 			atomic_set_bit(conn->flags, BT_CONN_BR_NOBOND);
 		}
 
-		memcpy(conn->br.link_key->val, evt->link_key, 16);
+		(void) memcpy(conn->br.link_key->val, evt->link_key, 16);
 		break;
 	default:
 		BT_WARN("Unsupported Link Key type %u", evt->key_type);
@@ -528,7 +528,7 @@ void link_key_reply(const bt_addr_t *bda
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	bt_addr_copy(&cp->bdaddr, bdaddr);
-	memcpy(cp->link_key, lk, 16);
+	(void) memcpy(cp->link_key, lk, 16);
 	bt_hci_cmd_send_sync(BT_HCI_OP_LINK_KEY_REPLY, buf, NULL);
 }
 
diff -u -p a/subsys/bluetooth/host/aes_ccm.c b/subsys/bluetooth/host/aes_ccm.c
--- a/subsys/bluetooth/host/aes_ccm.c
+++ b/subsys/bluetooth/host/aes_ccm.c
@@ -109,7 +109,7 @@ static int ccm_auth(const uint8_t key[16
 	}
 
 	b[0] = 0x01;
-	memcpy(b + 1, nonce, 13);
+	(void) memcpy(b + 1, nonce, 13);
 
 	/* S[0] = e(AppKey, 0x01 || nonce || 0x0000) */
 	sys_put_be16(0x0000, &b[14]);
@@ -128,7 +128,7 @@ static int ccm_auth(const uint8_t key[16
 				b[i] = Xn[i] ^ cleartext_msg[(j * 16) + i];
 			}
 
-			memcpy(&b[i], &Xn[i], 16 - i);
+			(void) memcpy(&b[i], &Xn[i], 16 - i);
 		} else {
 			xor16(b, Xn, &cleartext_msg[j * 16]);
 		}
@@ -162,7 +162,7 @@ static int ccm_crypt(const uint8_t key[1
 	}
 
 	a_i[0] = 0x01;
-	memcpy(&a_i[1], nonce, 13);
+	(void) memcpy(&a_i[1], nonce, 13);
 
 	for (j = 0; j < blk_cnt; j++) {
 		/* S_1 = e(AppKey, 0x01 || nonce || 0x0001) */
diff -u -p a/subsys/bluetooth/host/audio/iso.c b/subsys/bluetooth/host/audio/iso.c
--- a/subsys/bluetooth/host/audio/iso.c
+++ b/subsys/bluetooth/host/audio/iso.c
@@ -245,7 +245,7 @@ int hci_le_remove_cig(uint8_t cig_id)
 
 	req = net_buf_add(buf, sizeof(*req));
 
-	memset(req, 0, sizeof(*req));
+	(void) memset(req, 0, sizeof(*req));
 
 	req->cig_id = cig_id;
 
@@ -361,7 +361,7 @@ static struct net_buf *hci_le_set_cig_pa
 
 	req = net_buf_add(buf, sizeof(*req));
 
-	memset(req, 0, sizeof(*req));
+	(void) memset(req, 0, sizeof(*req));
 
 	req->cig_id = param->conns[0]->iso.cig_id;
 	sys_put_le24(param->chans[0]->qos->interval, req->m_interval);
@@ -377,7 +377,7 @@ static struct net_buf *hci_le_set_cig_pa
 	for (i = 0; i < param->num_conns; i++) {
 		cis = net_buf_add(buf, sizeof(*cis));
 
-		memset(cis, 0, sizeof(*cis));
+		(void) memset(cis, 0, sizeof(*cis));
 
 		cis->cis_id = param->conns[i]->iso.cis_id;
 
@@ -491,7 +491,7 @@ static int hci_le_create_cis(struct bt_c
 
 	req = net_buf_add(buf, sizeof(*req));
 
-	memset(req, 0, sizeof(*req));
+	(void) memset(req, 0, sizeof(*req));
 
 	req->num_cis = num_conns;
 
@@ -499,7 +499,7 @@ static int hci_le_create_cis(struct bt_c
 	for (i = 0; i < num_conns; i++) {
 		cis = net_buf_add(buf, sizeof(*cis));
 
-		memset(cis, 0, sizeof(*cis));
+		(void) memset(cis, 0, sizeof(*cis));
 
 		cis->cis_handle = sys_cpu_to_le16(conn[i]->handle);
 		cis->acl_handle = sys_cpu_to_le16(conn[i]->iso.acl->handle);
@@ -564,7 +564,7 @@ static int hci_le_setup_iso_data_path(st
 	sys_put_le24(path->path->delay, cp->controller_delay);
 	cp->codec_config_len = path->path->cc_len;
 	cc = net_buf_add(buf, cp->codec_config_len);
-	memcpy(cc, path->path->cc, cp->codec_config_len);
+	(void) memcpy(cc, path->path->cc, cp->codec_config_len);
 
 	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SETUP_ISO_PATH, buf, &rsp);
 	if (err) {
@@ -866,7 +866,7 @@ int bt_iso_chan_bind(struct bt_conn **co
 	__ASSERT_NO_MSG(num_conns);
 	__ASSERT_NO_MSG(chans);
 
-	memset(&param, 0, sizeof(param));
+	(void) memset(&param, 0, sizeof(param));
 
 	param.id = id++;
 	param.num_conns = num_conns;
diff -u -p a/subsys/bluetooth/host/smp.c b/subsys/bluetooth/host/smp.c
--- a/subsys/bluetooth/host/smp.c
+++ b/subsys/bluetooth/host/smp.c
@@ -517,7 +517,7 @@ static int smp_d1(const uint8_t *key, ui
 
 	sys_put_le16(d, &res[0]);
 	sys_put_le16(r, &res[2]);
-	memset(&res[4], 0, 16 - 4);
+	(void) memset(&res[4], 0, 16 - 4);
 
 	err = bt_encrypt_le(key, res, res);
 	if (err) {
@@ -651,11 +651,11 @@ static int smp_f6(const uint8_t *w, cons
 	sys_memcpy_swap(m + 48, iocap, 3);
 
 	m[51] = a1->type;
-	memcpy(m + 52, a1->a.val, 6);
+	(void) memcpy(m + 52, a1->a.val, 6);
 	sys_memcpy_swap(m + 52, a1->a.val, 6);
 
 	m[58] = a2->type;
-	memcpy(m + 59, a2->a.val, 6);
+	(void) memcpy(m + 59, a2->a.val, 6);
 	sys_memcpy_swap(m + 59, a2->a.val, 6);
 
 	sys_memcpy_swap(ws, w, 16);
@@ -696,7 +696,7 @@ static int smp_g2(const uint8_t u[32], c
 	}
 	BT_DBG("res %s", bt_hex(xs, 16));
 
-	memcpy(passkey, xs + 12, 4);
+	(void) memcpy(passkey, xs + 12, 4);
 	*passkey = sys_be32_to_cpu(*passkey) % 1000000;
 
 	BT_DBG("passkey %u", *passkey);
@@ -1201,7 +1201,7 @@ static void smp_br_distribute_keys(struc
 		}
 
 		id_info = net_buf_add(buf, sizeof(*id_info));
-		memcpy(id_info->irk, bt_dev.irk[conn->id], 16);
+		(void) memcpy(id_info->irk, bt_dev.irk[conn->id], 16);
 
 		smp_br_send(smp, buf, NULL);
 
@@ -1239,7 +1239,7 @@ static void smp_br_distribute_keys(struc
 
 		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 			bt_keys_add_type(keys, BT_KEYS_LOCAL_CSRK);
-			memcpy(keys->local_csrk.val, info->csrk, 16);
+			(void) memcpy(keys->local_csrk.val, info->csrk, 16);
 			keys->local_csrk.cnt = 0U;
 		}
 
@@ -1439,7 +1439,7 @@ static uint8_t smp_br_ident_info(struct 
 		return BT_SMP_ERR_UNSPECIFIED;
 	}
 
-	memcpy(keys->irk.val, req->irk, sizeof(keys->irk.val));
+	(void) memcpy(keys->irk.val, req->irk, sizeof(keys->irk.val));
 
 	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_ADDR_INFO);
 
@@ -1509,7 +1509,7 @@ static uint8_t smp_br_signing_info(struc
 		return BT_SMP_ERR_UNSPECIFIED;
 	}
 
-	memcpy(keys->remote_csrk.val, req->csrk, sizeof(keys->remote_csrk.val));
+	(void) memcpy(keys->remote_csrk.val, req->csrk, sizeof(keys->remote_csrk.val));
 
 	smp->remote_dist &= ~BT_SMP_DIST_SIGN;
 
@@ -1901,7 +1901,7 @@ static uint8_t smp_send_pairing_random(s
 	}
 
 	req = net_buf_add(rsp_buf, sizeof(*req));
-	memcpy(req->val, smp->prnd, sizeof(req->val));
+	(void) memcpy(req->val, smp->prnd, sizeof(req->val));
 
 	smp_send(smp, rsp_buf, NULL, NULL);
 
@@ -1936,8 +1936,8 @@ static int smp_c1(const uint8_t k[16], c
 	/* pres, preq, rat and iat are concatenated to generate p1 */
 	p1[0] = ia->type;
 	p1[1] = ra->type;
-	memcpy(p1 + 2, preq, 7);
-	memcpy(p1 + 9, pres, 7);
+	(void) memcpy(p1 + 2, preq, 7);
+	(void) memcpy(p1 + 9, pres, 7);
 
 	BT_DBG("p1 %s", bt_hex(p1, 16));
 
@@ -1952,8 +1952,8 @@ static int smp_c1(const uint8_t k[16], c
 	}
 
 	/* ra is concatenated with ia and padding to generate p2 */
-	memcpy(p2, ra->a.val, 6);
-	memcpy(p2 + 6, ia->a.val, 6);
+	(void) memcpy(p2, ra->a.val, 6);
+	(void) memcpy(p2 + 6, ia->a.val, 6);
 	(void)memset(p2 + 12, 0, 4);
 
 	BT_DBG("p2 %s", bt_hex(p2, 16));
@@ -2044,7 +2044,7 @@ static void legacy_distribute_keys(struc
 		info = net_buf_add(buf, sizeof(*info));
 
 		/* distributed only enc_size bytes of key */
-		memcpy(info->ltk, rand.key, keys->enc_size);
+		(void) memcpy(info->ltk, rand.key, keys->enc_size);
 		if (keys->enc_size < sizeof(info->ltk)) {
 			(void)memset(info->ltk + keys->enc_size, 0,
 				     sizeof(info->ltk) - keys->enc_size);
@@ -2060,20 +2060,20 @@ static void legacy_distribute_keys(struc
 		}
 
 		ident = net_buf_add(buf, sizeof(*ident));
-		memcpy(ident->rand, rand.rand, sizeof(ident->rand));
-		memcpy(ident->ediv, rand.ediv, sizeof(ident->ediv));
+		(void) memcpy(ident->rand, rand.rand, sizeof(ident->rand));
+		(void) memcpy(ident->ediv, rand.ediv, sizeof(ident->ediv));
 
 		smp_send(smp, buf, smp_ident_sent, NULL);
 
 		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 			bt_keys_add_type(keys, BT_KEYS_SLAVE_LTK);
 
-			memcpy(keys->slave_ltk.val, rand.key,
-			       sizeof(keys->slave_ltk.val));
-			memcpy(keys->slave_ltk.rand, rand.rand,
-			       sizeof(keys->slave_ltk.rand));
-			memcpy(keys->slave_ltk.ediv, rand.ediv,
-			       sizeof(keys->slave_ltk.ediv));
+			(void) memcpy(keys->slave_ltk.val, rand.key,
+					sizeof(keys->slave_ltk.val));
+			(void) memcpy(keys->slave_ltk.rand, rand.rand,
+					sizeof(keys->slave_ltk.rand));
+			(void) memcpy(keys->slave_ltk.ediv, rand.ediv,
+					sizeof(keys->slave_ltk.ediv));
 		}
 	}
 }
@@ -2110,7 +2110,7 @@ static uint8_t bt_smp_distribute_keys(st
 		}
 
 		id_info = net_buf_add(buf, sizeof(*id_info));
-		memcpy(id_info->irk, bt_dev.irk[conn->id], 16);
+		(void) memcpy(id_info->irk, bt_dev.irk[conn->id], 16);
 
 		smp_send(smp, buf, NULL, NULL);
 
@@ -2146,7 +2146,7 @@ static uint8_t bt_smp_distribute_keys(st
 
 		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 			bt_keys_add_type(keys, BT_KEYS_LOCAL_CSRK);
-			memcpy(keys->local_csrk.val, info->csrk, 16);
+			(void) memcpy(keys->local_csrk.val, info->csrk, 16);
 			keys->local_csrk.cnt = 0U;
 		}
 
@@ -2169,7 +2169,7 @@ static uint8_t send_pairing_rsp(struct b
 	}
 
 	rsp = net_buf_add(rsp_buf, sizeof(*rsp));
-	memcpy(rsp, smp->prsp + 1, sizeof(*rsp));
+	(void) memcpy(rsp, smp->prsp + 1, sizeof(*rsp));
 
 	smp_send(smp, rsp_buf, NULL, NULL);
 
@@ -2209,8 +2209,8 @@ static int smp_s1(const uint8_t k[16], c
 	 *
 	 *    r' = r1' || r2'
 	 */
-	memcpy(out, r2, 8);
-	memcpy(out + 8, r1, 8);
+	(void) memcpy(out, r2, 8);
+	(void) memcpy(out + 8, r1, 8);
 
 	/* s1(k, r1 , r2) = e(k, r') */
 	return bt_encrypt_le(k, out, out);
@@ -2438,7 +2438,7 @@ static uint8_t legacy_pairing_random(str
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
 
-		memcpy(smp->tk, tmp, sizeof(smp->tk));
+		(void) memcpy(smp->tk, tmp, sizeof(smp->tk));
 		BT_DBG("generated STK %s", bt_hex(smp->tk, 16));
 
 		atomic_set_bit(smp->flags, SMP_FLAG_ENC_PENDING);
@@ -2498,7 +2498,7 @@ static void legacy_user_tk_entry(struct 
 static void legacy_passkey_entry(struct bt_smp *smp, unsigned int passkey)
 {
 	passkey = sys_cpu_to_le32(passkey);
-	memcpy(smp->tk, &passkey, sizeof(passkey));
+	(void) memcpy(smp->tk, &passkey, sizeof(passkey));
 
 	legacy_user_tk_entry(smp);
 }
@@ -2519,7 +2519,7 @@ static uint8_t smp_encrypt_info(struct b
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
 
-		memcpy(keys->ltk.val, req->ltk, 16);
+		(void) memcpy(keys->ltk.val, req->ltk, 16);
 	}
 
 	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_MASTER_IDENT);
@@ -2545,8 +2545,8 @@ static uint8_t smp_master_ident(struct b
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
 
-		memcpy(keys->ltk.ediv, req->ediv, sizeof(keys->ltk.ediv));
-		memcpy(keys->ltk.rand, req->rand, sizeof(req->rand));
+		(void) memcpy(keys->ltk.ediv, req->ediv, sizeof(keys->ltk.ediv));
+		(void) memcpy(keys->ltk.rand, req->rand, sizeof(req->rand));
 
 		smp->remote_dist &= ~BT_SMP_DIST_ENC_KEY;
 	}
@@ -2726,7 +2726,7 @@ bool bt_smp_request_ltk(struct bt_conn *
 		 * We keep both legacy STK and LE SC LTK in TK.
 		 * Also use only enc_size bytes of key for encryption.
 		 */
-		memcpy(ltk, smp->tk, enc_size);
+		(void) memcpy(ltk, smp->tk, enc_size);
 		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
 			(void)memset(ltk + enc_size, 0,
 				     BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
@@ -2749,7 +2749,7 @@ bool bt_smp_request_ltk(struct bt_conn *
 	    conn->le.keys && (conn->le.keys->keys & BT_KEYS_LTK_P256)) {
 		enc_size = conn->le.keys->enc_size;
 
-		memcpy(ltk, conn->le.keys->ltk.val, enc_size);
+		(void) memcpy(ltk, conn->le.keys->ltk.val, enc_size);
 		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
 			(void)memset(ltk + enc_size, 0,
 				     BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
@@ -2764,7 +2764,7 @@ bool bt_smp_request_ltk(struct bt_conn *
 	    !memcmp(conn->le.keys->slave_ltk.ediv, &ediv, 2)) {
 		enc_size = conn->le.keys->enc_size;
 
-		memcpy(ltk, conn->le.keys->slave_ltk.val, enc_size);
+		(void) memcpy(ltk, conn->le.keys->slave_ltk.val, enc_size);
 		if (enc_size < BT_SMP_MAX_ENC_KEY_SIZE) {
 			(void)memset(ltk + enc_size, 0,
 				     BT_SMP_MAX_ENC_KEY_SIZE - enc_size);
@@ -2881,7 +2881,7 @@ static uint8_t smp_pairing_req(struct bt
 
 	/* Store req for later use */
 	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
-	memcpy(smp->preq + 1, req, sizeof(*req));
+	(void) memcpy(smp->preq + 1, req, sizeof(*req));
 
 	/* create rsp, it will be used later on */
 	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
@@ -2996,8 +2996,8 @@ static uint8_t sc_send_public_key(struct
 
 	req = net_buf_add(req_buf, sizeof(*req));
 
-	memcpy(req->x, sc_public_key, sizeof(req->x));
-	memcpy(req->y, &sc_public_key[32], sizeof(req->y));
+	(void) memcpy(req->x, sc_public_key, sizeof(req->x));
+	(void) memcpy(req->y, &sc_public_key[32], sizeof(req->y));
 
 	smp_send(smp, req_buf, NULL, NULL);
 
@@ -3073,7 +3073,7 @@ static int smp_send_pairing_req(struct b
 
 	/* Store req for later use */
 	smp->preq[0] = BT_SMP_CMD_PAIRING_REQ;
-	memcpy(smp->preq + 1, req, sizeof(*req));
+	(void) memcpy(smp->preq + 1, req, sizeof(*req));
 
 	smp_send(smp, req_buf, NULL, NULL);
 
@@ -3102,7 +3102,7 @@ static uint8_t smp_pairing_rsp(struct bt
 
 	/* Store rsp for later use */
 	smp->prsp[0] = BT_SMP_CMD_PAIRING_RSP;
-	memcpy(smp->prsp + 1, rsp, sizeof(*rsp));
+	(void) memcpy(smp->prsp + 1, rsp, sizeof(*rsp));
 
 	if ((rsp->auth_req & BT_SMP_AUTH_SC) &&
 	    (req->auth_req & BT_SMP_AUTH_SC)) {
@@ -3203,7 +3203,7 @@ static uint8_t smp_pairing_confirm(struc
 
 	atomic_clear_bit(smp->flags, SMP_FLAG_DISPLAY);
 
-	memcpy(smp->pcnf, req->val, sizeof(smp->pcnf));
+	(void) memcpy(smp->pcnf, req->val, sizeof(smp->pcnf));
 
 	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
 	    smp->chan.chan.conn->role == BT_HCI_ROLE_MASTER) {
@@ -3253,7 +3253,7 @@ static uint8_t sc_smp_send_dhkey_check(s
 	}
 
 	req = net_buf_add(buf, sizeof(*req));
-	memcpy(req->e, e, sizeof(req->e));
+	(void) memcpy(req->e, e, sizeof(req->e));
 
 	smp_send(smp, buf, NULL, NULL);
 
@@ -3273,11 +3273,11 @@ static uint8_t compute_and_send_master_d
 		break;
 	case PASSKEY_DISPLAY:
 	case PASSKEY_INPUT:
-		memcpy(r, &smp->passkey, sizeof(smp->passkey));
+		(void) memcpy(r, &smp->passkey, sizeof(smp->passkey));
 		break;
 	case LE_SC_OOB:
 		if (smp->oobd_remote) {
-			memcpy(r, smp->oobd_remote->r, sizeof(r));
+			(void) memcpy(r, smp->oobd_remote->r, sizeof(r));
 		}
 		break;
 	default:
@@ -3317,11 +3317,11 @@ static uint8_t compute_and_check_and_sen
 		break;
 	case PASSKEY_DISPLAY:
 	case PASSKEY_INPUT:
-		memcpy(r, &smp->passkey, sizeof(smp->passkey));
+		(void) memcpy(r, &smp->passkey, sizeof(smp->passkey));
 		break;
 	case LE_SC_OOB:
 		if (smp->oobd_remote) {
-			memcpy(r, smp->oobd_remote->r, sizeof(r));
+			(void) memcpy(r, smp->oobd_remote->r, sizeof(r));
 		}
 		break;
 	default:
@@ -3345,9 +3345,9 @@ static uint8_t compute_and_check_and_sen
 
 	if (smp->method == LE_SC_OOB) {
 		if (smp->oobd_local) {
-			memcpy(r, smp->oobd_local->r, sizeof(r));
+			(void) memcpy(r, smp->oobd_local->r, sizeof(r));
 		} else {
-			memset(r, 0, sizeof(r));
+			(void) memset(r, 0, sizeof(r));
 		}
 	}
 
@@ -3398,7 +3398,7 @@ static void bt_smp_dhkey_ready(const uin
 		return;
 	}
 
-	memcpy(smp->dhkey, dhkey, 32);
+	(void) memcpy(smp->dhkey, dhkey, 32);
 
 	/* wait for user passkey confirmation */
 	if (atomic_test_bit(smp->flags, SMP_FLAG_USER)) {
@@ -3530,7 +3530,7 @@ static uint8_t smp_pairing_random(struct
 
 	BT_DBG("");
 
-	memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
+	(void) memcpy(smp->rrnd, req->val, sizeof(smp->rrnd));
 
 #if !defined(CONFIG_BT_SMP_SC_PAIR_ONLY)
 	if (!atomic_test_bit(smp->flags, SMP_FLAG_SC)) {
@@ -3700,7 +3700,7 @@ static uint8_t smp_ident_info(struct bt_
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
 
-		memcpy(keys->irk.val, req->irk, 16);
+		(void) memcpy(keys->irk.val, req->irk, 16);
 	}
 
 	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_IDENT_ADDR_INFO);
@@ -3808,8 +3808,8 @@ static uint8_t smp_signing_info(struct b
 			return BT_SMP_ERR_UNSPECIFIED;
 		}
 
-		memcpy(keys->remote_csrk.val, req->csrk,
-		       sizeof(keys->remote_csrk.val));
+		(void) memcpy(keys->remote_csrk.val, req->csrk,
+				sizeof(keys->remote_csrk.val));
 	}
 
 	smp->remote_dist &= ~BT_SMP_DIST_SIGN;
@@ -4027,8 +4027,8 @@ static uint8_t smp_public_key(struct bt_
 
 	BT_DBG("");
 
-	memcpy(smp->pkey, req->x, 32);
-	memcpy(&smp->pkey[32], req->y, 32);
+	(void) memcpy(smp->pkey, req->x, 32);
+	(void) memcpy(&smp->pkey[32], req->y, 32);
 
 	/* mark key as debug if remote is using it */
 	if (memcmp(smp->pkey, sc_debug_public_key, 64) == 0) {
@@ -4135,11 +4135,11 @@ static uint8_t smp_dhkey_check(struct bt
 			break;
 		case PASSKEY_DISPLAY:
 		case PASSKEY_INPUT:
-			memcpy(r, &smp->passkey, sizeof(smp->passkey));
+			(void) memcpy(r, &smp->passkey, sizeof(smp->passkey));
 			break;
 		case LE_SC_OOB:
 			if (smp->oobd_local) {
-				memcpy(r, smp->oobd_local->r, sizeof(r));
+				(void) memcpy(r, smp->oobd_local->r, sizeof(r));
 			}
 			break;
 		default:
@@ -4185,7 +4185,7 @@ static uint8_t smp_dhkey_check(struct bt
 #if defined(CONFIG_BT_PERIPHERAL)
 	if (smp->chan.chan.conn->role == BT_HCI_ROLE_SLAVE) {
 		atomic_clear_bit(smp->flags, SMP_FLAG_DHCHECK_WAIT);
-		memcpy(smp->e, req->e, sizeof(smp->e));
+		(void) memcpy(smp->e, req->e, sizeof(smp->e));
 
 		/* wait for DHKey being generated */
 		if (atomic_test_bit(smp->flags, SMP_FLAG_DHKEY_PENDING)) {
@@ -4476,12 +4476,12 @@ static int smp_sign_buf(const uint8_t *k
 	}
 
 	sys_mem_swap(tmp, sizeof(tmp));
-	memcpy(tmp + 4, &cnt, sizeof(cnt));
+	(void) memcpy(tmp + 4, &cnt, sizeof(cnt));
 
 	/* Swap original message back */
 	sys_mem_swap(m, len + sizeof(cnt));
 
-	memcpy(sig, tmp + 4, 12);
+	(void) memcpy(sig, tmp + 4, 12);
 
 	BT_DBG("sig %s", bt_hex(sig, 12));
 
@@ -4498,7 +4498,7 @@ int bt_smp_sign_verify(struct bt_conn *c
 	int err;
 
 	/* Store signature incl. count */
-	memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
+	(void) memcpy(sig, net_buf_tail(buf) - sizeof(sig), sizeof(sig));
 
 	keys = bt_keys_find(BT_KEYS_REMOTE_CSRK, conn->id, &conn->le.dst);
 	if (!keys) {
@@ -4509,7 +4509,7 @@ int bt_smp_sign_verify(struct bt_conn *c
 
 	/* Copy signing count */
 	cnt = sys_cpu_to_le32(keys->remote_csrk.cnt);
-	memcpy(net_buf_tail(buf) - sizeof(sig), &cnt, sizeof(cnt));
+	(void) memcpy(net_buf_tail(buf) - sizeof(sig), &cnt, sizeof(cnt));
 
 	BT_DBG("Sign data len %zu key %s count %u", buf->len - sizeof(sig),
 	       bt_hex(keys->remote_csrk.val, 16), keys->remote_csrk.cnt);
@@ -4551,7 +4551,7 @@ int bt_smp_sign(struct bt_conn *conn, st
 
 	/* Copy signing count */
 	cnt = sys_cpu_to_le32(keys->local_csrk.cnt);
-	memcpy(net_buf_tail(buf) - 12, &cnt, sizeof(cnt));
+	(void) memcpy(net_buf_tail(buf) - 12, &cnt, sizeof(cnt));
 
 	BT_DBG("Sign data len %u key %s count %u", buf->len,
 	       bt_hex(keys->local_csrk.val, 16), keys->local_csrk.cnt);
@@ -4683,10 +4683,10 @@ static int sign_test(const char *prefix,
 	BT_DBG("%s: Sign message with len %u", prefix, len);
 
 	(void)memset(msg, 0, sizeof(msg));
-	memcpy(msg, m, len);
+	(void) memcpy(msg, m, len);
 	(void)memset(msg + len, 0, sizeof(uint32_t));
 
-	memcpy(orig, msg, sizeof(msg));
+	(void) memcpy(orig, msg, sizeof(msg));
 
 	err = smp_sign_buf(key, msg, len);
 	if (err) {
@@ -5107,7 +5107,7 @@ int bt_smp_le_oob_set_tk(struct bt_conn 
 		return -EINVAL;
 	}
 
-	memcpy(smp->tk, tk, 16*sizeof(uint8_t));
+	(void) memcpy(smp->tk, tk, 16*sizeof(uint8_t));
 
 	legacy_user_tk_entry(smp);
 
@@ -5133,7 +5133,7 @@ int bt_smp_le_oob_generate_sc_data(struc
 			0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
 		};
 
-		memcpy(le_sc_oob->r, rand_num, sizeof(le_sc_oob->r));
+		(void) memcpy(le_sc_oob->r, rand_num, sizeof(le_sc_oob->r));
 	} else {
 		err = bt_rand(le_sc_oob->r, 16);
 		if (err) {
@@ -5475,8 +5475,8 @@ void bt_smp_update_keys(struct bt_conn *
 
 		if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
 			bt_keys_add_type(conn->le.keys, BT_KEYS_LTK_P256);
-			memcpy(conn->le.keys->ltk.val, smp->tk,
-			       sizeof(conn->le.keys->ltk.val));
+			(void) memcpy(conn->le.keys->ltk.val, smp->tk,
+					sizeof(conn->le.keys->ltk.val));
 			(void)memset(conn->le.keys->ltk.rand, 0,
 				     sizeof(conn->le.keys->ltk.rand));
 			(void)memset(conn->le.keys->ltk.ediv, 0,
diff -u -p a/subsys/bluetooth/shell/hci.c b/subsys/bluetooth/shell/hci.c
--- a/subsys/bluetooth/shell/hci.c
+++ b/subsys/bluetooth/shell/hci.c
@@ -43,7 +43,7 @@ int cmd_mesh_adv(const struct shell *she
 		cp = net_buf_add(buf, sizeof(*cp));
 		cp->adv_slot = 0U;
 		cp->own_addr_type = 0x01;
-		memset(&cp->random_addr, 0, sizeof(bt_addr_t));
+		(void) memset(&cp->random_addr, 0, sizeof(bt_addr_t));
 		cp->ch_map = 0x07;
 		cp->tx_power = 0;
 		cp->min_tx_delay = 0U;
@@ -54,7 +54,7 @@ int cmd_mesh_adv(const struct shell *she
 		cp->scan_duration = sys_cpu_to_le16(0x0064);
 		cp->scan_filter = 0x00;
 		cp->data_len = 0U;
-		memset(cp->data, 0, sizeof(cp->data));
+		(void) memset(cp->data, 0, sizeof(cp->data));
 	} else if (!strcmp(argv[1], "off")) {
 		struct bt_hci_cp_mesh_advertise_cancel *cp;
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_test.c b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_test.c
--- a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_test.c
+++ b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_test.c
@@ -224,35 +224,35 @@ uint32_t ll_test_tx(uint8_t chan, uint8_
 
 	switch (type) {
 	case 0x00:
-		memcpy(payload, prbs9, len);
+		(void) memcpy(payload, prbs9, len);
 		break;
 
 	case 0x01:
-		memset(payload, 0x0f, len);
+		(void) memset(payload, 0x0f, len);
 		break;
 
 	case 0x02:
-		memset(payload, 0x55, len);
+		(void) memset(payload, 0x55, len);
 		break;
 
 	case 0x03:
-		memcpy(payload, prbs15, len);
+		(void) memcpy(payload, prbs15, len);
 		break;
 
 	case 0x04:
-		memset(payload, 0xff, len);
+		(void) memset(payload, 0xff, len);
 		break;
 
 	case 0x05:
-		memset(payload, 0x00, len);
+		(void) memset(payload, 0x00, len);
 		break;
 
 	case 0x06:
-		memset(payload, 0xf0, len);
+		(void) memset(payload, 0xf0, len);
 		break;
 
 	case 0x07:
-		memset(payload, 0xaa, len);
+		(void) memset(payload, 0xaa, len);
 		break;
 	}
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_filter.c b/subsys/bluetooth/controller/ll_sw/ull_filter.c
--- a/subsys/bluetooth/controller/ll_sw/ull_filter.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_filter.c
@@ -234,7 +234,7 @@ void ll_rl_id_addr_get(uint8_t rl_idx, u
 	LL_ASSERT(rl[rl_idx].taken);
 
 	*id_addr_type = rl[rl_idx].id_addr_type;
-	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
+	(void) memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 }
 
 uint8_t ll_rl_size_get(void)
@@ -290,13 +290,13 @@ uint8_t ll_rl_add(bt_addr_le_t *id_addr,
 #endif
 	}
 	if (rl[i].lirk) {
-		memcpy(rl[i].local_irk, lirk, IRK_SIZE);
+		(void) memcpy(rl[i].local_irk, lirk, IRK_SIZE);
 		rl[i].local_rpa = NULL;
 	}
-	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
+	(void) memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
 	rl[i].rpas_ready = 0U;
 #if defined(CONFIG_BT_CTLR_SW_DEFERRED_PRIVACY)
-	memset(rl[i].target_rpa.val, 0x00, sizeof(rl[i].target_rpa));
+	(void) memset(rl[i].target_rpa.val, 0x00, sizeof(rl[i].target_rpa));
 #endif
 	/* Default to Network Privacy */
 	rl[i].dev = 0U;
@@ -331,7 +331,7 @@ uint8_t ll_rl_remove(bt_addr_le_t *id_ad
 			uint8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
 
 			if (pj && pi != pj) {
-				memcpy(peer_irks[pi], peer_irks[pj], IRK_SIZE);
+				(void) memcpy(peer_irks[pi], peer_irks[pj], IRK_SIZE);
 				for (k = 0U;
 				     k < CONFIG_BT_CTLR_RL_SIZE;
 				     k++) {
@@ -369,8 +369,8 @@ void ll_rl_crpa_set(uint8_t id_addr_type
 		}
 
 		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
-			memcpy(rl[rl_idx].curr_rpa.val, crpa,
-			       sizeof(bt_addr_t));
+			(void) memcpy(rl[rl_idx].curr_rpa.val, crpa,
+					sizeof(bt_addr_t));
 		}
 	}
 }
@@ -587,7 +587,7 @@ void ull_filter_adv_pdu_update(struct ll
 	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
 		LL_ASSERT(rl[idx].rpas_ready);
 		pdu->tx_addr = 1;
-		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
+		(void) memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 	} else {
 		pdu->tx_addr = adv->own_addr_type & 0x1;
 #if defined(CONFIG_BT_CTLR_ADV_EXT)
@@ -604,12 +604,12 @@ void ull_filter_adv_pdu_update(struct ll
 	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 		if (idx < ARRAY_SIZE(rl) && rl[idx].pirk) {
 			pdu->rx_addr = 1;
-			memcpy(&pdu->direct_ind.tgt_addr[0],
-			       rl[idx].peer_rpa.val, BDADDR_SIZE);
+			(void) memcpy(&pdu->direct_ind.tgt_addr[0],
+					rl[idx].peer_rpa.val, BDADDR_SIZE);
 		} else {
 			pdu->rx_addr = adv->id_addr_type;
-			memcpy(&pdu->direct_ind.tgt_addr[0],
-			       adv->id_addr, BDADDR_SIZE);
+			(void) memcpy(&pdu->direct_ind.tgt_addr[0],
+					adv->id_addr, BDADDR_SIZE);
 		}
 	}
 }
@@ -824,7 +824,7 @@ uint8_t ull_filter_deferred_resolve(bt_a
 
 	if (!k_work_pending(&(resolve_work.prpa_work))) {
 		/* copy input param to work variable */
-		memcpy(resolve_work.rpa.val, rpa->val, sizeof(bt_addr_t));
+		(void) memcpy(resolve_work.rpa.val, rpa->val, sizeof(bt_addr_t));
 		resolve_work.cb = cb;
 
 		k_work_submit(&(resolve_work.prpa_work));
@@ -842,7 +842,7 @@ uint8_t ull_filter_deferred_targeta_reso
 
 	if (!k_work_pending(&(t_work.target_work))) {
 		/* copy input param to work variable */
-		memcpy(t_work.rpa.val, rpa->val, sizeof(bt_addr_t));
+		(void) memcpy(t_work.rpa.val, rpa->val, sizeof(bt_addr_t));
 		t_work.cb = cb;
 		t_work.idx = rl_idx;
 
@@ -998,8 +998,8 @@ static void rpa_adv_refresh(struct ll_ad
 
 	ull_filter_adv_pdu_update(adv, pdu);
 
-	memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
-	       prev->len - BDADDR_SIZE);
+	(void) memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
+			prev->len - BDADDR_SIZE);
 	pdu->len = prev->len;
 
 	lll_adv_data_enqueue(&adv->lll, idx);
@@ -1096,7 +1096,7 @@ static void filter_insert(struct lll_fil
 {
 	filter->enable_bitmask |= BIT(index);
 	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
-	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
+	(void) memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 }
 
 static void filter_clear(struct lll_filter *filter)
@@ -1124,8 +1124,8 @@ static void target_resolve(struct k_work
 		/* No match - so not in list Need to see if we can resolve */
 		if (bt_rpa_irk_matches(rl[idx].local_irk, search_rpa)) {
 			/* Could resolve, store RPA */
-			memcpy(rl[idx].target_rpa.val, search_rpa->val,
-			       sizeof(bt_addr_t));
+			(void) memcpy(rl[idx].target_rpa.val, search_rpa->val,
+					sizeof(bt_addr_t));
 			j = idx;
 		} else {
 			/* Could not resolve, and not in table */
@@ -1191,8 +1191,8 @@ static void prpa_cache_resolve(struct k_
 			/* Address could be resolved, so update current RPA
 			 * in list
 			 */
-			memcpy(rl[j].curr_rpa.val, search_rpa->val,
-			       sizeof(bt_addr_t));
+			(void) memcpy(rl[j].curr_rpa.val, search_rpa->val,
+					sizeof(bt_addr_t));
 		}
 
 	} else {
@@ -1231,7 +1231,7 @@ static void prpa_cache_add(bt_addr_t *rp
 {
 	newest_prpa = (newest_prpa + 1) % CONFIG_BT_CTLR_RPA_CACHE_SIZE;
 
-	memcpy(prpa_cache[newest_prpa].rpa.val, rpa->val, sizeof(bt_addr_t));
+	(void) memcpy(prpa_cache[newest_prpa].rpa.val, rpa->val, sizeof(bt_addr_t));
 	prpa_cache[newest_prpa].taken = 1U;
 }
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c b/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c
--- a/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c
@@ -70,7 +70,7 @@ uint8_t ll_adv_aux_random_addr_set(uint8
 		return BT_HCI_ERR_CMD_DISALLOWED;
 	}
 
-	memcpy(adv->rnd_addr, addr, BDADDR_SIZE);
+	(void) memcpy(adv->rnd_addr, addr, BDADDR_SIZE);
 
 	return 0;
 }
@@ -79,7 +79,7 @@ uint8_t const *ll_adv_aux_random_addr_ge
 				       uint8_t *const addr)
 {
 	if (addr) {
-		memcpy(addr, adv->rnd_addr, BDADDR_SIZE);
+		(void) memcpy(addr, adv->rnd_addr, BDADDR_SIZE);
 	}
 
 	return adv->rnd_addr;
@@ -238,8 +238,8 @@ uint8_t ll_adv_aux_sr_data_set(uint8_t h
 	sr_dptr++;
 
 	/* AdvA */
-	memcpy(sr_dptr, &sr_prev->adv_ext_ind.ext_hdr_adi_adv_data[1],
-	       BDADDR_SIZE);
+	(void) memcpy(sr_dptr, &sr_prev->adv_ext_ind.ext_hdr_adi_adv_data[1],
+			BDADDR_SIZE);
 	sr_dptr += BDADDR_SIZE;
 
 #if defined(CONFIG_BT_CTRL_ADV_ADI_IN_SCAN_RSP)
@@ -259,7 +259,7 @@ uint8_t ll_adv_aux_sr_data_set(uint8_t h
 	}
 
 	/* Copy data */
-	memcpy(sr_dptr, data, len);
+	(void) memcpy(sr_dptr, data, len);
 	sr_dptr += len;
 
 	/* Finish Common ExtAdv Payload header */
@@ -630,7 +630,7 @@ uint8_t ull_adv_aux_hdr_set_clear(struct
 
 	/* No AdvData in primary channel PDU */
 	/* Fill AdvData in secondary PDU */
-	memcpy(sec_dptr, ad_data, ad_len);
+	(void) memcpy(sec_dptr, ad_data, ad_len);
 
 	/* No ACAD in primary channel PDU */
 	/* TODO: Fill ACAD in secondary channel PDU */
@@ -684,10 +684,10 @@ uint8_t ull_adv_aux_hdr_set_clear(struct
 
 			/* NOTE: memcpy shall handle overlapping buffers
 			 */
-			memcpy(pri_dptr, pri_dptr_prev,
-			       sizeof(struct pdu_adv_adi));
-			memcpy(sec_dptr, sec_dptr_prev,
-			       sizeof(struct pdu_adv_adi));
+			(void) memcpy(pri_dptr, pri_dptr_prev,
+					sizeof(struct pdu_adv_adi));
+			(void) memcpy(sec_dptr, sec_dptr_prev,
+					sizeof(struct pdu_adv_adi));
 
 			pri_adi_prev = (void *)pri_dptr_prev;
 			did = sys_le16_to_cpu(pri_adi_prev->did);
@@ -728,7 +728,7 @@ uint8_t ull_adv_aux_hdr_set_clear(struct
 
 		sec_dptr -= BDADDR_SIZE;
 
-		memcpy(sec_dptr, bdaddr, BDADDR_SIZE);
+		(void) memcpy(sec_dptr, bdaddr, BDADDR_SIZE);
 	}
 
 	lll_adv_aux_data_enqueue(lll_aux, sec_idx);
@@ -955,10 +955,10 @@ static inline void sync_info_fill(struct
 	si->offs = 0U; /* NOTE: Filled by secondary prepare */
 	si->offs_units = 0U; /* TODO: implementation defined */
 	si->interval = sys_cpu_to_le16(sync->interval);
-	memcpy(si->sca_chm, lll_sync->data_chan_map,
-	       sizeof(si->sca_chm));
-	memcpy(&si->aa, lll_sync->access_addr, sizeof(si->aa));
-	memcpy(si->crc_init, lll_sync->crc_init, sizeof(si->crc_init));
+	(void) memcpy(si->sca_chm, lll_sync->data_chan_map,
+			sizeof(si->sca_chm));
+	(void) memcpy(&si->aa, lll_sync->access_addr, sizeof(si->aa));
+	(void) memcpy(si->crc_init, lll_sync->crc_init, sizeof(si->crc_init));
 
 	si->evt_cntr = 0U; /* NOTE: Filled by secondary prepare */
 }
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c
@@ -733,22 +733,23 @@ static inline uint32_t isr_rx_pdu(struct
 		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 		if (lll->rpa_gen && lrpa) {
 			pdu_tx->tx_addr = 1;
-			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
-			       BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->connect_ind.init_addr[0],
+				      lrpa->val,
+				      BDADDR_SIZE);
 		} else {
 #else
 		if (1) {
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 			pdu_tx->tx_addr = lll->init_addr_type;
-			memcpy(&pdu_tx->connect_ind.init_addr[0],
-			       &lll->init_addr[0], BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->connect_ind.init_addr[0],
+					&lll->init_addr[0], BDADDR_SIZE);
 		}
-		memcpy(&pdu_tx->connect_ind.adv_addr[0],
-		       &pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
-		memcpy(&pdu_tx->connect_ind.access_addr[0],
-		       &lll_conn->access_addr[0], 4);
-		memcpy(&pdu_tx->connect_ind.crc_init[0],
-		       &lll_conn->crc_init[0], 3);
+		(void) memcpy(&pdu_tx->connect_ind.adv_addr[0],
+				&pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
+		(void) memcpy(&pdu_tx->connect_ind.access_addr[0],
+				&lll_conn->access_addr[0], 4);
+		(void) memcpy(&pdu_tx->connect_ind.crc_init[0],
+				&lll_conn->crc_init[0], 3);
 		pdu_tx->connect_ind.win_size = 1;
 
 		conn_interval_us = (uint32_t)lll_conn->interval * 1250U;
@@ -776,9 +777,9 @@ static inline uint32_t isr_rx_pdu(struct
 			sys_cpu_to_le16(lll_conn->latency);
 		pdu_tx->connect_ind.timeout =
 			sys_cpu_to_le16(lll->conn_timeout);
-		memcpy(&pdu_tx->connect_ind.chan_map[0],
-		       &lll_conn->data_chan_map[0],
-		       sizeof(pdu_tx->connect_ind.chan_map));
+		(void) memcpy(&pdu_tx->connect_ind.chan_map[0],
+				&lll_conn->data_chan_map[0],
+				sizeof(pdu_tx->connect_ind.chan_map));
 		pdu_tx->connect_ind.hop = lll_conn->data_chan_hop;
 		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
 
@@ -832,8 +833,8 @@ static inline uint32_t isr_rx_pdu(struct
 
 		uint8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
 
-		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
-					  sizeof(struct pdu_adv_connect_ind)));
+		(void) memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
+						sizeof(struct pdu_adv_connect_ind)));
 
 		/*
 		 * Overwrite the sent chan sel with received chan sel, when
@@ -900,18 +901,19 @@ static inline uint32_t isr_rx_pdu(struct
 		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 		if (lll->rpa_gen && lrpa) {
 			pdu_tx->tx_addr = 1;
-			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
-			       BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->scan_req.scan_addr[0],
+				      lrpa->val,
+				      BDADDR_SIZE);
 		} else {
 #else
 		if (1) {
 #endif /* CONFIG_BT_CTLR_PRIVACY */
 			pdu_tx->tx_addr = lll->init_addr_type;
-			memcpy(&pdu_tx->scan_req.scan_addr[0],
-			       &lll->init_addr[0], BDADDR_SIZE);
+			(void) memcpy(&pdu_tx->scan_req.scan_addr[0],
+					&lll->init_addr[0], BDADDR_SIZE);
 		}
-		memcpy(&pdu_tx->scan_req.adv_addr[0],
-		       &pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
+		(void) memcpy(&pdu_tx->scan_req.adv_addr[0],
+				&pdu_adv_rx->adv_ind.addr[0], BDADDR_SIZE);
 
 		radio_pkt_tx_set(pdu_tx);
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c b/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c
@@ -1233,7 +1233,7 @@ void *radio_ccm_rx_pkt_set_ut(struct ccm
 	void *result;
 
 	/* ccm.key[16] is stored in MSO format, as retrieved from e function */
-	memcpy(ccm->key, key_local, sizeof(key_local));
+	(void) memcpy(ccm->key, key_local, sizeof(key_local));
 
 	/* Input std sample data, vol 6, part C, ch 1 */
 	_pkt_scratch[0] = 0x0f;
@@ -1279,7 +1279,7 @@ void *radio_ccm_rx_pkt_set(struct ccm *c
 	ARG_UNUSED(phy);
 
 	/* ccm.key[16] is stored in MSO format, as retrieved from e function */
-	memcpy(key_local, ccm->key, sizeof(key_local));
+	(void) memcpy(key_local, ccm->key, sizeof(key_local));
 	ctx_ccm.auth_mic_valid = 0;
 	ctx_ccm.empty_pdu_rxed = 0;
 	ctx_ccm.rx_pkt_in = (struct pdu_data *)_pkt_scratch;
@@ -1289,7 +1289,7 @@ void *radio_ccm_rx_pkt_set(struct ccm *c
 	 * the master and set to 0 for Data Physical Chan PDUs sent by the slave
 	 */
 	ctx_ccm.nonce.bytes[4] |= ccm->direction << 7;
-	memcpy(&ctx_ccm.nonce.bytes[5], ccm->iv, 8); /* LSO to MSO */
+	(void) memcpy(&ctx_ccm.nonce.bytes[5], ccm->iv, 8); /* LSO to MSO */
 
 	/* Loads the key into CAU3's DMEM and expands the AES key schedule. */
 	status = CAU3_AES_SetKey(CAU3, &handle, key_local, 16);
@@ -1336,8 +1336,8 @@ void *radio_ccm_tx_pkt_set_ut(struct ccm
 	void *result;
 
 	/* ccm.key[16] is stored in MSO format, as retrieved from e function */
-	memcpy(ccm->key, key_local, sizeof(key_local));
-	memcpy(pkt, data_in, sizeof(data_in));
+	(void) memcpy(ccm->key, key_local, sizeof(key_local));
+	(void) memcpy(pkt, data_in, sizeof(data_in));
 	/* IV std sample data, vol 6, part C, ch 1, stored in LL in LSO format
 	 * IV (LSO to MSO)      :0x24:0xAB:0xDC:0xBA:0xBE:0xBA:0xAF:0xDE
 	 */
@@ -1381,13 +1381,13 @@ void *radio_ccm_tx_pkt_set(struct ccm *c
 	}
 
 	/* ccm.key[16] is stored in MSO format, as retrieved from e function */
-	memcpy(key_local, ccm->key, sizeof(key_local));
+	(void) memcpy(key_local, ccm->key, sizeof(key_local));
 	ctx_ccm.nonce.counter = ccm->counter;	/* LSO to MSO, counter is LE */
 	/* The directionBit set to 1 for Data Physical Chan PDUs sent by
 	 * the master and set to 0 for Data Physical Chan PDUs sent by the slave
 	 */
 	ctx_ccm.nonce.bytes[4] |= ccm->direction << 7;
-	memcpy(&ctx_ccm.nonce.bytes[5], ccm->iv, 8); /* LSO to MSO */
+	(void) memcpy(&ctx_ccm.nonce.bytes[5], ccm->iv, 8); /* LSO to MSO */
 
 	/* Loads the key into CAU3's DMEM and expands the AES key schedule. */
 	status = CAU3_AES_SetKey(CAU3, &handle, key_local, 16);
diff -u -p a/subsys/bluetooth/common/rpa.c b/subsys/bluetooth/common/rpa.c
--- a/subsys/bluetooth/common/rpa.c
+++ b/subsys/bluetooth/common/rpa.c
@@ -60,7 +60,7 @@ static int ah(const uint8_t irk[16], con
 	BT_DBG("r %s", bt_hex(r, 3));
 
 	/* r' = padding || r */
-	memcpy(res, r, 3);
+	(void) memcpy(res, r, 3);
 	(void)memset(res + 3, 0, 13);
 
 	err = internal_encrypt_le(irk, res, res);
@@ -74,7 +74,7 @@ static int ah(const uint8_t irk[16], con
 	 * by taking the least significant 24 bits of the output of e as the
 	 * result of ah.
 	 */
-	memcpy(out, res, 3);
+	(void) memcpy(out, res, 3);
 
 	return 0;
 }
diff -u -p a/subsys/bluetooth/services/ots/ots_olcp.c b/subsys/bluetooth/services/ots/ots_olcp.c
--- a/subsys/bluetooth/services/ots/ots_olcp.c
+++ b/subsys/bluetooth/services/ots/ots_olcp.c
@@ -158,7 +158,7 @@ static enum bt_gatt_ots_olcp_res_code ol
 static enum bt_gatt_ots_olcp_res_code olcp_command_decode(
 	const uint8_t *buf, struct bt_gatt_ots_olcp_proc *proc)
 {
-	memset(proc, 0, sizeof(*proc));
+	(void) memset(proc, 0, sizeof(*proc));
 
 	proc->type = *buf++;
 
@@ -226,8 +226,8 @@ static int olcp_ind_send(const struct bt
 	olcp_res[olcp_res_len++] = olcp_status;
 
 	/* Prepare indication parameters */
-	memset(&ots->olcp_ind.params, 0, sizeof(ots->olcp_ind.params));
-	memcpy(&ots->olcp_ind.attr, olcp_attr, sizeof(ots->olcp_ind.attr));
+	(void) memset(&ots->olcp_ind.params, 0, sizeof(ots->olcp_ind.params));
+	(void) memcpy(&ots->olcp_ind.attr, olcp_attr, sizeof(ots->olcp_ind.attr));
 	ots->olcp_ind.params.attr = olcp_attr;
 	ots->olcp_ind.params.func = olcp_ind_cb;
 	ots->olcp_ind.params.data = olcp_res;
diff -u -p a/subsys/disk/disk_access_flash.c b/subsys/disk/disk_access_flash.c
--- a/subsys/disk/disk_access_flash.c
+++ b/subsys/disk/disk_access_flash.c
@@ -129,7 +129,7 @@ static int read_copy_flash_block(off_t s
 	}
 
 	/* overwrite with user data */
-	memcpy(dest_buff + offset, src_buff, size);
+	(void) memcpy(dest_buff + offset, src_buff, size);
 
 	return 0;
 }
diff -u -p a/tests/crypto/rand32/src/main.c b/tests/crypto/rand32/src/main.c
--- a/tests/crypto/rand32/src/main.c
+++ b/tests/crypto/rand32/src/main.c
@@ -69,7 +69,7 @@ void test_rand32(void)
 	}
 
 	printk("Generating bulk fill random numbers\n");
-	memset(buf, 0, sizeof(buf));
+	(void) memset(buf, 0, sizeof(buf));
 	sys_rand_get((uint8_t *)(&buf[0]), sizeof(buf));
 
 	for (rnd_cnt = 0; rnd_cnt < (N_VALUES - 1); rnd_cnt++) {
@@ -89,7 +89,7 @@ void test_rand32(void)
 
 	printk("Generating bulk fill cryptographically secure random numbers\n");
 
-	memset(buf, 0, sizeof(buf));
+	(void) memset(buf, 0, sizeof(buf));
 	sys_csrand_get(buf, sizeof(buf));
 
 	for (rnd_cnt = 0; rnd_cnt < (N_VALUES - 1); rnd_cnt++) {
diff -u -p a/tests/net/ieee802154/fragment/src/main.c b/tests/net/ieee802154/fragment/src/main.c
--- a/tests/net/ieee802154/fragment/src/main.c
+++ b/tests/net/ieee802154/fragment/src/main.c
@@ -250,7 +250,7 @@ static struct net_pkt *create_pkt(struct
 		return NULL;
 	}
 
-	memcpy(buf->data, (uint8_t *) data, NET_IPV6UDPH_LEN);
+	(void) memcpy(buf->data, (uint8_t *) data, NET_IPV6UDPH_LEN);
 	net_buf_add(buf, NET_IPV6UDPH_LEN);
 
 	pos = 0U;
@@ -271,7 +271,7 @@ static struct net_pkt *create_pkt(struct
 		uint8_t copy;
 		bytes = net_buf_tailroom(buf);
 		copy = remaining > bytes ? bytes : remaining;
-		memcpy(net_buf_add(buf, copy), &user_data[pos], copy);
+		(void) memcpy(net_buf_add(buf, copy), &user_data[pos], copy);
 
 		pos += bytes;
 		remaining -= bytes;
@@ -293,9 +293,9 @@ static struct net_pkt *create_pkt(struct
 	net_pkt_lladdr_dst(pkt)->len = sizeof(dummy_short_addr);
 	net_pkt_lladdr_dst(pkt)->type = NET_LINK_IEEE802154;
 
-	memcpy(net_pkt_lladdr_src(pkt),
-	       net_if_get_link_addr(net_if_get_default()),
-	       sizeof(struct net_linkaddr));
+	(void) memcpy(net_pkt_lladdr_src(pkt),
+			net_if_get_link_addr(net_if_get_default()),
+			sizeof(struct net_linkaddr));
 
 	return pkt;
 }
@@ -497,7 +497,7 @@ static bool test_fragment(struct net_fra
 			goto end;
 		}
 
-		memcpy(dfrag->data, frame_buf.data, frame_buf.len);
+		(void) memcpy(dfrag->data, frame_buf.data, frame_buf.len);
 		dfrag->len = frame_buf.len;
 
 		net_pkt_frag_add(f_pkt, dfrag);
@@ -528,7 +528,7 @@ reassemble:
 			goto end;
 		}
 
-		memcpy(dfrag->data, buf->data, buf->len);
+		(void) memcpy(dfrag->data, buf->data, buf->len);
 		dfrag->len = buf->len;
 
 		net_pkt_frag_add(rxpkt, dfrag);
diff -u -p a/tests/net/route/src/main.c b/tests/net/route/src/main.c
--- a/tests/net/route/src/main.c
+++ b/tests/net/route/src/main.c
@@ -277,8 +277,8 @@ static void test_init(void)
 
 	/* Some test addresses are generated */
 	for (i = 0; i < max_routes; i++) {
-		memcpy(&dest_addresses[i], &generic_addr,
-		       sizeof(struct in6_addr));
+		(void) memcpy(&dest_addresses[i], &generic_addr,
+				sizeof(struct in6_addr));
 
 		dest_addresses[i].s6_addr[14] = i + 1;
 		dest_addresses[i].s6_addr[15] = sys_rand32_get();
diff -u -p a/tests/net/vlan/src/main.c b/tests/net/vlan/src/main.c
--- a/tests/net/vlan/src/main.c
+++ b/tests/net/vlan/src/main.c
@@ -734,8 +734,8 @@ static void test_vlan_send_data(void)
 			      &udp_v6_ctx);
 	zassert_equal(ret, 0, "Create IPv6 UDP context failed");
 
-	memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = net_context_bind(udp_v6_ctx, (struct sockaddr *)&src_addr6,
 			       sizeof(struct sockaddr_in6));
diff -u -p a/tests/net/checksum_offload/src/main.c b/tests/net/checksum_offload/src/main.c
--- a/tests/net/checksum_offload/src/main.c
+++ b/tests/net/checksum_offload/src/main.c
@@ -183,14 +183,14 @@ static int eth_tx_offloading_disabled(co
 		udp_hdr->src_port = udp_hdr->dst_port;
 		udp_hdr->dst_port = port;
 
-		memcpy(lladdr,
-		       ((struct net_eth_hdr *)net_pkt_data(pkt))->src.addr,
-		       sizeof(lladdr));
-		memcpy(((struct net_eth_hdr *)net_pkt_data(pkt))->src.addr,
-		       ((struct net_eth_hdr *)net_pkt_data(pkt))->dst.addr,
-		       sizeof(lladdr));
-		memcpy(((struct net_eth_hdr *)net_pkt_data(pkt))->dst.addr,
-		       lladdr, sizeof(lladdr));
+		(void) memcpy(lladdr,
+				((struct net_eth_hdr *)net_pkt_data(pkt))->src.addr,
+				sizeof(lladdr));
+		(void) memcpy(((struct net_eth_hdr *)net_pkt_data(pkt))->src.addr,
+				((struct net_eth_hdr *)net_pkt_data(pkt))->dst.addr,
+				sizeof(lladdr));
+		(void) memcpy(((struct net_eth_hdr *)net_pkt_data(pkt))->dst.addr,
+				lladdr, sizeof(lladdr));
 
 		if (net_recv_data(net_pkt_iface(pkt),
 				  net_pkt_clone(pkt, K_NO_WAIT)) < 0) {
@@ -479,8 +479,8 @@ static void test_tx_chksum_offload_disab
 			      &udp_v6_ctx_1);
 	zassert_equal(ret, 0, "Create IPv6 UDP context failed");
 
-	memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = net_context_bind(udp_v6_ctx_1, (struct sockaddr *)&src_addr6,
 			       sizeof(struct sockaddr_in6));
@@ -530,8 +530,8 @@ static void test_tx_chksum_offload_disab
 			      &udp_v4_ctx_1);
 	zassert_equal(ret, 0, "Create IPv4 UDP context failed");
 
-	memcpy(&src_addr4.sin_addr, &in4addr_my, sizeof(struct in_addr));
-	memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
+	(void) memcpy(&src_addr4.sin_addr, &in4addr_my, sizeof(struct in_addr));
+	(void) memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
 
 	ret = net_context_bind(udp_v4_ctx_1, (struct sockaddr *)&src_addr4,
 			       sizeof(struct sockaddr_in));
@@ -581,8 +581,8 @@ static void test_tx_chksum_offload_enabl
 			      &udp_v6_ctx_2);
 	zassert_equal(ret, 0, "Create IPv6 UDP context failed");
 
-	memcpy(&src_addr6.sin6_addr, &my_addr2, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr2, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = net_context_bind(udp_v6_ctx_2, (struct sockaddr *)&src_addr6,
 			       sizeof(struct sockaddr_in6));
@@ -632,8 +632,8 @@ static void test_tx_chksum_offload_enabl
 			      &udp_v4_ctx_2);
 	zassert_equal(ret, 0, "Create IPv4 UDP context failed");
 
-	memcpy(&src_addr4.sin_addr, &in4addr_my2, sizeof(struct in_addr));
-	memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
+	(void) memcpy(&src_addr4.sin_addr, &in4addr_my2, sizeof(struct in_addr));
+	(void) memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
 
 	ret = net_context_bind(udp_v4_ctx_2, (struct sockaddr *)&src_addr4,
 			       sizeof(struct sockaddr_in));
@@ -726,8 +726,8 @@ static void test_rx_chksum_offload_disab
 			      &udp_v6_ctx_1);
 	zassert_equal(ret, 0, "Create IPv6 UDP context failed");
 
-	memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr1, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = net_context_bind(udp_v6_ctx_1, (struct sockaddr *)&src_addr6,
 			       sizeof(struct sockaddr_in6));
@@ -782,8 +782,8 @@ static void test_rx_chksum_offload_disab
 			      &udp_v4_ctx_1);
 	zassert_equal(ret, 0, "Create IPv4 UDP context failed");
 
-	memcpy(&src_addr4.sin_addr, &in4addr_my, sizeof(struct in_addr));
-	memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
+	(void) memcpy(&src_addr4.sin_addr, &in4addr_my, sizeof(struct in_addr));
+	(void) memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
 
 	ret = net_context_bind(udp_v4_ctx_1, (struct sockaddr *)&src_addr4,
 			       sizeof(struct sockaddr_in));
@@ -838,8 +838,8 @@ static void test_rx_chksum_offload_enabl
 			      &udp_v6_ctx_2);
 	zassert_equal(ret, 0, "Create IPv6 UDP context failed");
 
-	memcpy(&src_addr6.sin6_addr, &my_addr2, sizeof(struct in6_addr));
-	memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
+	(void) memcpy(&src_addr6.sin6_addr, &my_addr2, sizeof(struct in6_addr));
+	(void) memcpy(&dst_addr6.sin6_addr, &dst_addr, sizeof(struct in6_addr));
 
 	ret = net_context_bind(udp_v6_ctx_2, (struct sockaddr *)&src_addr6,
 			       sizeof(struct sockaddr_in6));
@@ -892,8 +892,8 @@ static void test_rx_chksum_offload_enabl
 			      &udp_v4_ctx_2);
 	zassert_equal(ret, 0, "Create IPv4 UDP context failed");
 
-	memcpy(&src_addr4.sin_addr, &in4addr_my2, sizeof(struct in_addr));
-	memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
+	(void) memcpy(&src_addr4.sin_addr, &in4addr_my2, sizeof(struct in_addr));
+	(void) memcpy(&dst_addr4.sin_addr, &in4addr_dst, sizeof(struct in_addr));
 
 	ret = net_context_bind(udp_v4_ctx_2, (struct sockaddr *)&src_addr4,
 			       sizeof(struct sockaddr_in));
diff -u -p a/tests/net/ipv6/src/main.c b/tests/net/ipv6/src/main.c
--- a/tests/net/ipv6/src/main.c
+++ b/tests/net/ipv6/src/main.c
@@ -185,9 +185,9 @@ static void prepare_ra_message(struct ne
 	net_pkt_cursor_init(pkt);
 
 	hdr.type = htons(NET_ETH_PTYPE_IPV6);
-	memset(&hdr.src, 0, sizeof(struct net_eth_addr));
-	memcpy(&hdr.dst, net_pkt_iface(pkt)->if_dev->link_addr.addr,
-	       sizeof(struct net_eth_addr));
+	(void) memset(&hdr.src, 0, sizeof(struct net_eth_addr));
+	(void) memcpy(&hdr.dst, net_pkt_iface(pkt)->if_dev->link_addr.addr,
+			sizeof(struct net_eth_addr));
 
 	net_pkt_set_overwrite(pkt, false);
 
diff -u -p a/tests/net/socket/getaddrinfo/src/main.c b/tests/net/socket/getaddrinfo/src/main.c
--- a/tests/net/socket/getaddrinfo/src/main.c
+++ b/tests/net/socket/getaddrinfo/src/main.c
@@ -116,7 +116,7 @@ static int process_dns(void)
 		ntohs(addr_v6.sin6_port));
 
 	while (true) {
-		memset(pollfds, 0, sizeof(pollfds));
+		(void) memset(pollfds, 0, sizeof(pollfds));
 		pollfds[0].fd = sock_v4;
 		pollfds[0].events = POLLIN;
 		pollfds[1].fd = sock_v6;
@@ -179,9 +179,9 @@ void test_getaddrinfo_setup(void)
 	zassert_true(ret, "Cannot parse IP address %s", CONFIG_DNS_SERVER1);
 
 	if (addr.sa_family == AF_INET) {
-		memcpy(&addr_v4, net_sin(&addr), sizeof(struct sockaddr_in));
+		(void) memcpy(&addr_v4, net_sin(&addr), sizeof(struct sockaddr_in));
 	} else if (addr.sa_family == AF_INET6) {
-		memcpy(&addr_v6, net_sin6(&addr), sizeof(struct sockaddr_in6));
+		(void) memcpy(&addr_v6, net_sin6(&addr), sizeof(struct sockaddr_in6));
 	}
 
 	ret = net_ipaddr_parse(CONFIG_DNS_SERVER2,
@@ -190,9 +190,9 @@ void test_getaddrinfo_setup(void)
 	zassert_true(ret, "Cannot parse IP address %s", CONFIG_DNS_SERVER2);
 
 	if (addr.sa_family == AF_INET) {
-		memcpy(&addr_v4, net_sin(&addr), sizeof(struct sockaddr_in));
+		(void) memcpy(&addr_v4, net_sin(&addr), sizeof(struct sockaddr_in));
 	} else if (addr.sa_family == AF_INET6) {
-		memcpy(&addr_v6, net_sin6(&addr), sizeof(struct sockaddr_in6));
+		(void) memcpy(&addr_v6, net_sin6(&addr), sizeof(struct sockaddr_in6));
 	}
 
 	addr_str = inet_ntop(AF_INET, &addr_v4.sin_addr, str, sizeof(str));
diff -u -p a/tests/net/socket/socketpair/src/test_socketpair_block.c b/tests/net/socket/socketpair/src/test_socketpair_block.c
--- a/tests/net/socket/socketpair/src/test_socketpair_block.c
+++ b/tests/net/socket/socketpair/src/test_socketpair_block.c
@@ -87,7 +87,7 @@ void test_socketpair_write_block(void)
 		LOG_DBG("data direction %d -> %d", sv[i], sv[(!i) & 1]);
 
 		LOG_DBG("setting up context");
-		memset(&ctx, 0, sizeof(ctx));
+		(void) memset(&ctx, 0, sizeof(ctx));
 		ctx.write = true;
 		ctx.fd = sv[(!i) & 1];
 
@@ -140,7 +140,7 @@ void test_socketpair_read_block(void)
 		LOG_DBG("data direction %d <- %d", sv[i], sv[(!i) & 1]);
 
 		LOG_DBG("setting up context");
-		memset(&ctx, 0, sizeof(ctx));
+		(void) memset(&ctx, 0, sizeof(ctx));
 		ctx.write = false;
 		ctx.fd = sv[(!i) & 1];
 
diff -u -p a/tests/net/socket/af_packet/src/main.c b/tests/net/socket/af_packet/src/main.c
--- a/tests/net/socket/af_packet/src/main.c
+++ b/tests/net/socket/af_packet/src/main.c
@@ -105,7 +105,7 @@ static int bind_socket(int sock, struct 
 {
 	struct sockaddr_ll addr;
 
-	memset(&addr, 0, sizeof(addr));
+	(void) memset(&addr, 0, sizeof(addr));
 
 	addr.sll_ifindex = net_if_get_by_iface(iface);
 	addr.sll_family = AF_PACKET;
@@ -207,7 +207,7 @@ static void test_packet_sockets_dgram(vo
 	ret = bind_socket(sock2, ud.second);
 	zassert_equal(ret, 0, "Cannot bind 2nd socket (%d)", -errno);
 
-	memset(&dst, 0, sizeof(dst));
+	(void) memset(&dst, 0, sizeof(dst));
 	dst.sll_ifindex = net_if_get_by_iface(ud.first);
 	dst.sll_family = AF_PACKET;
 
@@ -218,7 +218,7 @@ static void test_packet_sockets_dgram(vo
 
 	k_msleep(10); /* Let the packet enter the system */
 	setblocking(sock2, false);
-	memset(&src, 0, sizeof(src));
+	(void) memset(&src, 0, sizeof(src));
 
 	errno = 0;
 
@@ -242,14 +242,14 @@ static void test_packet_sockets_dgram(vo
 
 	k_msleep(10);
 	setblocking(sock1, false);
-	memset(&src, 0, sizeof(src));
+	(void) memset(&src, 0, sizeof(src));
 
 	ret = recvfrom(sock1, data_to_receive, sizeof(data_to_receive), 0,
 		       (struct sockaddr *)&src, &addrlen);
 	zassert_equal(ret, -1, "Received something (%d)", ret);
 	zassert_equal(errno, EAGAIN, "Wrong errno (%d)", errno);
 
-	memset(&src, 0, sizeof(src));
+	(void) memset(&src, 0, sizeof(src));
 
 	errno = 0;
 
diff -u -p a/tests/drivers/i2c/i2c_slave_api/src/eeprom_slave.c b/tests/drivers/i2c/i2c_slave_api/src/eeprom_slave.c
--- a/tests/drivers/i2c/i2c_slave_api/src/eeprom_slave.c
+++ b/tests/drivers/i2c/i2c_slave_api/src/eeprom_slave.c
@@ -49,7 +49,7 @@ int eeprom_slave_program(const struct de
 		return -EINVAL;
 	}
 
-	memcpy(data->buffer, eeprom_data, length);
+	(void) memcpy(data->buffer, eeprom_data, length);
 
 	return 0;
 }
diff -u -p a/tests/drivers/uart/uart_async_api/src/test_uart_async.c b/tests/drivers/uart/uart_async_api/src/test_uart_async.c
--- a/tests/drivers/uart/uart_async_api/src/test_uart_async.c
+++ b/tests/drivers/uart/uart_async_api/src/test_uart_async.c
@@ -274,8 +274,8 @@ void test_read_abort(void)
 	uint8_t rx_buf[100];
 	uint8_t tx_buf[100];
 
-	memset(rx_buf, 0, sizeof(rx_buf));
-	memset(tx_buf, 1, sizeof(tx_buf));
+	(void) memset(rx_buf, 0, sizeof(rx_buf));
+	(void) memset(tx_buf, 1, sizeof(tx_buf));
 
 	uart_rx_enable(uart_dev, rx_buf, sizeof(rx_buf), 50);
 
@@ -340,8 +340,8 @@ void test_write_abort(void)
 	uint8_t rx_buf[100];
 	uint8_t tx_buf[100];
 
-	memset(rx_buf, 0, sizeof(rx_buf));
-	memset(tx_buf, 1, sizeof(tx_buf));
+	(void) memset(rx_buf, 0, sizeof(rx_buf));
+	(void) memset(tx_buf, 1, sizeof(tx_buf));
 
 	uart_rx_enable(uart_dev, rx_buf, sizeof(rx_buf), 50);
 
@@ -406,8 +406,8 @@ void test_forever_timeout(void)
 	uint8_t rx_buf[100];
 	uint8_t tx_buf[100];
 
-	memset(rx_buf, 0, sizeof(rx_buf));
-	memset(tx_buf, 1, sizeof(tx_buf));
+	(void) memset(rx_buf, 0, sizeof(rx_buf));
+	(void) memset(tx_buf, 1, sizeof(tx_buf));
 
 	uart_rx_enable(uart_dev, rx_buf, sizeof(rx_buf), SYS_FOREVER_MS);
 
@@ -481,7 +481,7 @@ void test_chained_write(void)
 {
 	uint8_t rx_buf[20];
 
-	memset(rx_buf, 0, sizeof(rx_buf));
+	(void) memset(rx_buf, 0, sizeof(rx_buf));
 
 	uart_rx_enable(uart_dev, rx_buf, sizeof(rx_buf), 50);
 
@@ -554,8 +554,8 @@ void test_long_buffers_setup(void)
 
 void test_long_buffers(void)
 {
-	memset(long_rx_buf, 0, sizeof(long_rx_buf));
-	memset(long_tx_buf, 1, sizeof(long_tx_buf));
+	(void) memset(long_rx_buf, 0, sizeof(long_rx_buf));
+	(void) memset(long_tx_buf, 1, sizeof(long_tx_buf));
 
 	uart_rx_enable(uart_dev, long_rx_buf, sizeof(long_rx_buf), 10);
 
diff -u -p a/tests/subsys/settings/fcb/src/settings_test_fcb.c b/tests/subsys/settings/fcb/src/settings_test_fcb.c
--- a/tests/subsys/settings/fcb/src/settings_test_fcb.c
+++ b/tests/subsys/settings/fcb/src/settings_test_fcb.c
@@ -77,13 +77,13 @@ int c1_handle_get(const char *name, char
 
 	if (settings_name_steq(name, "mybar", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val8));
-		memcpy(val, &val8, MIN(val_len_max, sizeof(val8)));
+		(void) memcpy(val, &val8, MIN(val_len_max, sizeof(val8)));
 		return val_len_max;
 	}
 
 	if (settings_name_steq(name, "mybar64", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val64));
-		memcpy(val, &val64, MIN(val_len_max, sizeof(val64)));
+		(void) memcpy(val, &val64, MIN(val_len_max, sizeof(val64)));
 		return val_len_max;
 	}
 
@@ -250,7 +250,7 @@ int c2_handle_get(const char *name, char
 		}
 
 		len = MIN(strlen(valptr), len);
-		memcpy(val, valptr, len);
+		(void) memcpy(val, valptr, len);
 		return len;
 	}
 
@@ -307,7 +307,7 @@ int c3_handle_get(const char *name, char
 
 	if (settings_name_steq(name, "v", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val32));
-		memcpy(val, &val32, MIN(val_len_max, sizeof(val32)));
+		(void) memcpy(val, &val32, MIN(val_len_max, sizeof(val32)));
 		return val_len_max;
 	}
 	return -EINVAL;
diff -u -p a/tests/subsys/settings/functional/src/settings_basic_test.c b/tests/subsys/settings/functional/src/settings_basic_test.c
--- a/tests/subsys/settings/functional/src/settings_basic_test.c
+++ b/tests/subsys/settings/functional/src/settings_basic_test.c
@@ -237,7 +237,7 @@ static void test_register_and_loading(vo
 
 	settings_save_one("ps/ss/ss/val2", &val, sizeof(uint8_t));
 
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 
 	rc = settings_register(&val1_settings);
 	zassert_true(rc == 0, "register of val1 settings failed");
@@ -259,7 +259,7 @@ static void test_register_and_loading(vo
 	rc = settings_register(&val2_settings);
 	zassert_true(rc == -EEXIST, "double register of val2 settings allowed");
 
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 	/* when we load settings now data.val2 should receive the value*/
 	rc = settings_load();
 	zassert_true(rc == 0, "settings_load failed");
@@ -270,7 +270,7 @@ static void test_register_and_loading(vo
 	zassert_true(err, "wrong data enable found");
 
 	settings_save_one("ps/ss/val3", &val, sizeof(uint8_t));
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 	/* when we load settings now data.val2 and data.val1 should receive a
 	 * value
 	 */
@@ -287,7 +287,7 @@ static void test_register_and_loading(vo
 	 */
 	rc = settings_register(&val3_settings);
 	zassert_true(rc == 0, "register of val3 settings failed");
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 	/* when we load settings now data.val2 and data.val3 should receive a
 	 * value
 	 */
@@ -301,7 +301,7 @@ static void test_register_and_loading(vo
 	zassert_true(err, "wrong data enable found");
 
 	settings_save_one("ps/val1", &val, sizeof(uint8_t));
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 	/* when we load settings all data should receive a value loaded */
 	rc = settings_load();
 	zassert_true(rc == 0, "settings_load failed");
@@ -311,7 +311,7 @@ static void test_register_and_loading(vo
 	err = (data.en1) && (data.en2) && (data.en3);
 	zassert_true(err, "wrong data enable found");
 
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 	/* test subtree loading: subtree "ps/ss" data.val2 and data.val3 should
 	 * receive a value
 	 */
@@ -323,7 +323,7 @@ static void test_register_and_loading(vo
 	err = (!data.en1) && (data.en2) && (data.en3);
 	zassert_true(err, "wrong data enable found");
 
-	memset(&data, 0, sizeof(struct stored_data));
+	(void) memset(&data, 0, sizeof(struct stored_data));
 	/* test subtree loading: subtree "ps/ss/ss" only data.val2 should
 	 * receive a value
 	 */
@@ -426,7 +426,7 @@ static void test_direct_loading(void)
 
 	rc = settings_register(&val123_settings);
 	zassert_true(rc == 0, NULL);
-	memset(&data, 0, sizeof(data));
+	(void) memset(&data, 0, sizeof(data));
 
 	rc = settings_load();
 	zassert_true(rc == 0, NULL);
@@ -436,7 +436,7 @@ static void test_direct_loading(void)
 	zassert_equal(35, data.val3, NULL);
 
 	/* Load subtree */
-	memset(&data, 0, sizeof(data));
+	(void) memset(&data, 0, sizeof(data));
 
 	rc = settings_load_subtree("val/2");
 	zassert_true(rc == 0, NULL);
@@ -446,7 +446,7 @@ static void test_direct_loading(void)
 	zassert_equal(0,  data.val3, NULL);
 
 	/* Direct loading now */
-	memset(&data, 0, sizeof(data));
+	(void) memset(&data, 0, sizeof(data));
 	val_directly_loaded = 0;
 	direct_load_cnt = 0;
 	rc = settings_load_subtree_direct(
@@ -577,7 +577,7 @@ static void test_direct_loading_filter(v
 	}
 
 
-	memset(data_final_called, 0, sizeof(data_final_called));
+	(void) memset(data_final_called, 0, sizeof(data_final_called));
 
 	rc = settings_load_subtree_direct(
 		prefix,
diff -u -p a/tests/subsys/canbus/frame/src/main.c b/tests/subsys/canbus/frame/src/main.c
--- a/tests/subsys/canbus/frame/src/main.c
+++ b/tests/subsys/canbus/frame/src/main.c
@@ -26,7 +26,7 @@ static void test_can_frame_to_zcan_frame
 
 	frame.can_id = BIT(31) | BIT(30) | 1234;
 	frame.can_dlc = sizeof(data);
-	memcpy(frame.data, data, sizeof(frame.data));
+	(void) memcpy(frame.data, data, sizeof(frame.data));
 
 	expected.rtr = 1U;
 	expected.id_type = 1U;
@@ -55,13 +55,13 @@ static void test_zcan_frame_to_can_frame
 
 	expected.can_id = BIT(31) | BIT(30) | 1234;
 	expected.can_dlc = sizeof(data);
-	memcpy(expected.data, data, sizeof(expected.data));
+	(void) memcpy(expected.data, data, sizeof(expected.data));
 
 	msg.rtr = 1U;
 	msg.id_type = 1U;
 	msg.std_id = 1234U;
 	msg.dlc = sizeof(data);
-	memcpy(msg.data, data, sizeof(data));
+	(void) memcpy(msg.data, data, sizeof(data));
 
 	can_copy_zframe_to_frame(&msg, &frame);
 
@@ -87,12 +87,12 @@ static void test_invalid_zcan_frame_to_c
 
 	expected.can_id = 0x678;
 	expected.can_dlc = sizeof(data);
-	memcpy(expected.data, data, sizeof(expected.data));
+	(void) memcpy(expected.data, data, sizeof(expected.data));
 
 	msg.id_type = CAN_STANDARD_IDENTIFIER;
 	msg.ext_id = 0x12345678U;
 	msg.dlc = sizeof(data);
-	memcpy(msg.data, data, sizeof(data));
+	(void) memcpy(msg.data, data, sizeof(data));
 
 	can_copy_zframe_to_frame(&msg, &frame);
 
diff -u -p a/tests/subsys/fs/littlefs/src/testfs_util.c b/tests/subsys/fs/littlefs/src/testfs_util.c
--- a/tests/subsys/fs/littlefs/src/testfs_util.c
+++ b/tests/subsys/fs/littlefs/src/testfs_util.c
@@ -32,7 +32,7 @@ static const char *path_vextend(struct t
 		} else if ((1 + len + 1) < rem) { /* /, ep, EOS */
 			*eos = '/';
 			++eos;
-			memcpy(eos, ep, len);
+			(void) memcpy(eos, ep, len);
 			eos += len;
 		} else {
 			break;
@@ -91,7 +91,7 @@ int testfs_write_constant(struct fs_file
 	uint8_t buffer[TESTFS_BUFFER_SIZE];
 	unsigned int rem = len;
 
-	memset(buffer, value, sizeof(buffer));
+	(void) memset(buffer, value, sizeof(buffer));
 
 	while (rem > 0) {
 		unsigned int count = sizeof(buffer);
diff -u -p a/tests/subsys/fs/fs_api/src/test_fs.c b/tests/subsys/fs/fs_api/src/test_fs.c
--- a/tests/subsys/fs/fs_api/src/test_fs.c
+++ b/tests/subsys/fs/fs_api/src/test_fs.c
@@ -96,7 +96,7 @@ static ssize_t temp_read(struct fs_file_
 	if (read_pos - buffer + br > file_length) {
 		br = file_length - (read_pos - buffer);
 	}
-	memcpy(ptr, read_pos, br);
+	(void) memcpy(ptr, read_pos, br);
 	read_pos += br;
 	cur = read_pos;
 
@@ -121,7 +121,7 @@ static ssize_t temp_write(struct fs_file
 		nospace = true;
 	}
 
-	memcpy(buffer + file_length, ptr, bw);
+	(void) memcpy(buffer + file_length, ptr, bw);
 	file_length += bw;
 	cur = buffer + file_length;
 
@@ -287,7 +287,7 @@ static int temp_statvfs(struct fs_mount_
 		return -EINVAL;
 	}
 
-	memset(stat, 0, sizeof(struct fs_statvfs));
+	(void) memset(stat, 0, sizeof(struct fs_statvfs));
 	stat->f_bsize = 512;
 	return 0;
 }
diff -u -p a/tests/subsys/logging/log_core_additional/src/log_test.c b/tests/subsys/logging/log_core_additional/src/log_test.c
--- a/tests/subsys/logging/log_core_additional/src/log_test.c
+++ b/tests/subsys/logging/log_core_additional/src/log_test.c
@@ -114,12 +114,12 @@ static void log_setup(bool backend2_enab
 
 	log_init();
 
-	memset(&backend1_cb, 0, sizeof(backend1_cb));
+	(void) memset(&backend1_cb, 0, sizeof(backend1_cb));
 
 	log_backend_enable(&backend1, &backend1_cb, LOG_LEVEL_DBG);
 
 	if (backend2_enable) {
-		memset(&backend2_cb, 0, sizeof(backend2_cb));
+		(void) memset(&backend2_cb, 0, sizeof(backend2_cb));
 
 		log_backend_enable(&backend2, &backend2_cb, LOG_LEVEL_DBG);
 	} else {
@@ -220,7 +220,7 @@ static void test_log_early_logging(void)
 		LOG_ERR("log error before backend active");
 
 		TC_PRINT("Activate backend with context");
-		memset(&backend1_cb, 0, sizeof(backend1_cb));
+		(void) memset(&backend1_cb, 0, sizeof(backend1_cb));
 		log_backend_enable(&backend1, &backend1_cb, LOG_LEVEL_DBG);
 
 		while (log_test_process(false)) {
@@ -286,7 +286,7 @@ static void test_log_timestamping(void)
 	zassert_equal(0, log_set_timestamp_func(timestamp_get, 0),
 		      "Expects successful timestamp function setting.");
 
-	memset(&backend1_cb, 0, sizeof(backend1_cb));
+	(void) memset(&backend1_cb, 0, sizeof(backend1_cb));
 	log_backend_enable(&backend1, &backend1_cb, LOG_LEVEL_DBG);
 
 	backend1_cb.check_timestamp = true;
diff -u -p a/tests/bluetooth/tester/src/gatt.c b/tests/bluetooth/tester/src/gatt.c
--- a/tests/bluetooth/tester/src/gatt.c
+++ b/tests/bluetooth/tester/src/gatt.c
@@ -85,7 +85,7 @@ static void *gatt_buf_add(const void *da
 	}
 
 	if (data) {
-		memcpy(ptr, data, len);
+		(void) memcpy(ptr, data, len);
 	} else {
 		(void)memset(ptr, 0, len);
 	}
@@ -131,16 +131,16 @@ static struct bt_gatt_attr *gatt_db_add(
 		return NULL;
 	}
 
-	memcpy(attr, pattern, sizeof(*attr));
+	(void) memcpy(attr, pattern, sizeof(*attr));
 
 	/* Store the UUID. */
 	attr->uuid = server_buf_push(uuid_size);
-	memcpy((void *) attr->uuid, &u->uuid, uuid_size);
+	(void) memcpy((void *) attr->uuid, &u->uuid, uuid_size);
 
 	/* Copy user_data to the buffer. */
 	if (user_data_len) {
 		attr->user_data = server_buf_push(user_data_len);
-		memcpy(attr->user_data, pattern->user_data, user_data_len);
+		(void) memcpy(attr->user_data, pattern->user_data, user_data_len);
 	}
 
 	LOG_DBG("handle 0x%04x", attr->handle);
@@ -160,12 +160,12 @@ static uint8_t btp2bt_uuid(const uint8_t
 	switch (len) {
 	case 0x02: /* UUID 16 */
 		bt_uuid->type = BT_UUID_TYPE_16;
-		memcpy(&le16, uuid, sizeof(le16));
+		(void) memcpy(&le16, uuid, sizeof(le16));
 		BT_UUID_16(bt_uuid)->val = sys_le16_to_cpu(le16);
 		break;
 	case 0x10: /* UUID 128*/
 		bt_uuid->type = BT_UUID_TYPE_128;
-		memcpy(BT_UUID_128(bt_uuid)->val, uuid, 16);
+		(void) memcpy(BT_UUID_128(bt_uuid)->val, uuid, 16);
 		break;
 	default:
 		return BTP_STATUS_FAILED;
@@ -320,7 +320,7 @@ static void attr_value_changed_ev(uint16
 
 	ev->handle = sys_cpu_to_le16(handle);
 	ev->data_length = sys_cpu_to_le16(len);
-	memcpy(ev->data, value, len);
+	(void) memcpy(ev->data, value, len);
 
 	tester_send(BTP_SERVICE_ID_GATT, GATT_EV_ATTR_VALUE_CHANGED,
 		    CONTROLLER_INDEX, buf, sizeof(buf));
@@ -354,7 +354,7 @@ static ssize_t write_value(struct bt_con
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 	}
 
-	memcpy(value->data + offset, buf, len);
+	(void) memcpy(value->data + offset, buf, len);
 
 	/* Maximum attribute value size is 512 bytes */
 	assert(value->len < 512);
@@ -721,7 +721,7 @@ static uint8_t set_cep_value(struct bt_g
 		return BTP_STATUS_FAILED;
 	}
 
-	memcpy(&properties, value, len);
+	(void) memcpy(&properties, value, len);
 	cep_value->properties = sys_le16_to_cpu(properties);
 
 	return BTP_STATUS_SUCCESS;
@@ -771,7 +771,7 @@ static uint8_t alloc_value(struct bt_gat
 		return BTP_STATUS_FAILED;
 	}
 
-	memcpy(value->data, data->value, value->len);
+	(void) memcpy(value->data, data->value, value->len);
 
 	if (tester_test_bit(value->flags, GATT_VALUE_CCC_FLAG) && ccc_value) {
 		if (ccc_value == BT_GATT_CCC_NOTIFY) {
@@ -963,10 +963,10 @@ static uint8_t disc_prim_cb(struct bt_co
 	if (data->uuid->type == BT_UUID_TYPE_16) {
 		uint16_t u16 = sys_cpu_to_le16(BT_UUID_16(data->uuid)->val);
 
-		memcpy(service->uuid, &u16, uuid_length);
+		(void) memcpy(service->uuid, &u16, uuid_length);
 	} else {
-		memcpy(service->uuid, BT_UUID_128(data->uuid)->val,
-		       uuid_length);
+		(void) memcpy(service->uuid, BT_UUID_128(data->uuid)->val,
+				uuid_length);
 	}
 
 	rp->services_count++;
@@ -1091,10 +1091,11 @@ static uint8_t find_included_cb(struct b
 	if (data->uuid->type == BT_UUID_TYPE_16) {
 		uint16_t u16 = sys_cpu_to_le16(BT_UUID_16(data->uuid)->val);
 
-		memcpy(included->service.uuid, &u16, uuid_length);
+		(void) memcpy(included->service.uuid, &u16, uuid_length);
 	} else {
-		memcpy(included->service.uuid, BT_UUID_128(data->uuid)->val,
-		       uuid_length);
+		(void) memcpy(included->service.uuid,
+				BT_UUID_128(data->uuid)->val,
+				uuid_length);
 	}
 
 	rp->services_count++;
@@ -1174,9 +1175,9 @@ static uint8_t disc_chrc_cb(struct bt_co
 	if (data->uuid->type == BT_UUID_TYPE_16) {
 		uint16_t u16 = sys_cpu_to_le16(BT_UUID_16(data->uuid)->val);
 
-		memcpy(chrc->uuid, &u16, uuid_length);
+		(void) memcpy(chrc->uuid, &u16, uuid_length);
 	} else {
-		memcpy(chrc->uuid, BT_UUID_128(data->uuid)->val, uuid_length);
+		(void) memcpy(chrc->uuid, BT_UUID_128(data->uuid)->val, uuid_length);
 	}
 
 	rp->characteristics_count++;
@@ -1298,10 +1299,10 @@ static uint8_t disc_all_desc_cb(struct b
 	if (attr->uuid->type == BT_UUID_TYPE_16) {
 		uint16_t u16 = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
 
-		memcpy(descriptor->uuid, &u16, uuid_length);
+		(void) memcpy(descriptor->uuid, &u16, uuid_length);
 	} else {
-		memcpy(descriptor->uuid, BT_UUID_128(attr->uuid)->val,
-		       uuid_length);
+		(void) memcpy(descriptor->uuid, BT_UUID_128(attr->uuid)->val,
+				uuid_length);
 	}
 
 	rp->descriptors_count++;
@@ -1668,8 +1669,8 @@ static uint8_t notify_func(struct bt_con
 	ev->type = (uint8_t) subscribe_params.value;
 	ev->handle = sys_cpu_to_le16(subscribe_params.value_handle);
 	ev->data_length = sys_cpu_to_le16(length);
-	memcpy(ev->data, data, length);
-	memcpy(ev->address, addr->a.val, sizeof(ev->address));
+	(void) memcpy(ev->data, data, length);
+	(void) memcpy(ev->address, addr->a.val, sizeof(ev->address));
 	ev->address_type = addr->type;
 
 	tester_send(BTP_SERVICE_ID_GATT, GATT_EV_NOTIFICATION,
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_1_2.c
@@ -74,7 +74,7 @@ static ssize_t write_value_v4(struct bt_
 	if (offset + len > sizeof(value_v4_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_1.c
@@ -98,7 +98,7 @@ static ssize_t write_value_v9__128_bit_u
 	if (offset + len > sizeof(value_v9__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -152,7 +152,7 @@ static ssize_t write_des_v9d2__128_bit_u
 	if (offset + len > sizeof(des_v9d2__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -183,7 +183,7 @@ static ssize_t write_des_v9d3__128_bit_u
 	if (offset + len > sizeof(des_v9d3__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_3.c
@@ -116,7 +116,7 @@ static ssize_t write_value_v2(struct bt_
 	if (offset + len > sizeof(value_v2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -145,7 +145,7 @@ static ssize_t write_value_v3(struct bt_
 	if (offset + len > sizeof(value_v3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_5_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_5_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_5_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_5_1.c
@@ -93,7 +93,7 @@ static ssize_t write_value_v8(struct bt_
 	if (offset + len > sizeof(value_v8_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -144,7 +144,7 @@ static ssize_t write_des_v8d1(struct bt_
 	if (offset + len > sizeof(des_v8d1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -200,7 +200,7 @@ static ssize_t write_des_v8d2(struct bt_
 	if (!bAuthorized)
 		return BT_GATT_ERR(BT_ATT_ERR_AUTHORIZATION);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -251,7 +251,7 @@ static ssize_t write_des_v8d3(struct bt_
 	if (offset + len > sizeof(des_v8d3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_3.c
@@ -96,7 +96,7 @@ static ssize_t write_value_v9__128_bit_u
 	if (offset + len > sizeof(value_v9__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -150,7 +150,7 @@ static ssize_t write_des_v9d2__128_bit_u
 	if (offset + len > sizeof(des_v9d2__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -181,7 +181,7 @@ static ssize_t write_des_v9d3__128_bit_u
 	if (offset + len > sizeof(des_v9d3__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_3.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_3.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_3.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_3_3.c
@@ -77,7 +77,7 @@ static ssize_t write_value_v6(struct bt_
 	if (offset + len > sizeof(value_v6_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/hci_prop_evt/src/main.c b/tests/bluetooth/hci_prop_evt/src/main.c
--- a/tests/bluetooth/hci_prop_evt/src/main.c
+++ b/tests/bluetooth/hci_prop_evt/src/main.c
@@ -303,7 +303,7 @@ static bool prop_cb(struct net_buf_simpl
 		zassert_not_null(prop_cb_data, "Cannot allocate memory");
 
 		/* Copy data so it can be verified later */
-		memcpy(prop_cb_data, data, data_len);
+		(void) memcpy(prop_cb_data, data, data_len);
 		prop_cb_data_len = data_len;
 
 		/* Give control back to test */
@@ -322,8 +322,8 @@ static void *prop_evt(struct net_buf *bu
 
 	evt_create(buf, BT_HCI_EVT_VENDOR, sizeof(*pe) + pelen);
 	pe = net_buf_add(buf, sizeof(*pe));
-	memcpy(&pe->prefix[0], &hci_prop_evt_prefix[0],
-	       ARRAY_SIZE(hci_prop_evt_prefix));
+	(void) memcpy(&pe->prefix[0], &hci_prop_evt_prefix[0],
+			ARRAY_SIZE(hci_prop_evt_prefix));
 
 	return net_buf_add(buf, pelen);
 }
@@ -337,7 +337,7 @@ static void send_prop_report(uint8_t *da
 	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 	per = prop_evt(buf, sizeof(*per) + data_len);
 	per->data_len = data_len;
-	memcpy(&per->data[0], data, data_len);
+	(void) memcpy(&per->data[0], data, data_len);
 
 	/* Submit job */
 	bt_recv_job_submit(buf);
diff -u -p a/tests/arch/arm/arm_thread_swap/src/arm_thread_arch.c b/tests/arch/arm/arm_thread_swap/src/arm_thread_arch.c
--- a/tests/arch/arm/arm_thread_swap/src/arm_thread_arch.c
+++ b/tests/arch/arm/arm_thread_swap/src/arm_thread_arch.c
@@ -236,8 +236,8 @@ static void alt_thread_entry(void)
 	/* Zero the container of the callee-saved registers, to validate,
 	 * later, that it is populated properly.
 	 */
-	memset(&ztest_thread_callee_saved_regs_container,
-		0, sizeof(_callee_saved_t));
+	(void) memset(&ztest_thread_callee_saved_regs_container,
+			0, sizeof(_callee_saved_t));
 
 #if defined(CONFIG_FPU) && defined(CONFIG_FPU_SHARING)
 
@@ -265,8 +265,8 @@ static void alt_thread_entry(void)
 	/* Zero the container of the FP callee-saved registers, to validate,
 	 * later, that it is populated properly.
 	 */
-	memset(&ztest_thread_fp_callee_saved_regs,
-		0, sizeof(ztest_thread_fp_callee_saved_regs));
+	(void) memset(&ztest_thread_fp_callee_saved_regs,
+			0, sizeof(ztest_thread_fp_callee_saved_regs));
 
 #endif /* CONFIG_FPU && CONFIG_FPU_SHARING */
 
@@ -406,8 +406,8 @@ void test_arm_thread_swap(void)
 	/* Clear the thread's floating-point callee-saved registers' container.
 	 * The container will, later, be populated by the swap mechanism.
 	 */
-	memcpy(&_current->arch.preempt_float, 0,
-		sizeof(struct _preempt_float));
+	(void) memcpy(&_current->arch.preempt_float, 0,
+			sizeof(struct _preempt_float));
 
 	/* Randomize the FP callee-saved registers at test initialization */
 	load_fp_callee_saved_regs(&ztest_thread_fp_callee_saved_regs);
@@ -452,7 +452,7 @@ void test_arm_thread_swap(void)
 	 * The container will, later, be populated by the swap
 	 * mechanism.
 	 */
-	memset(&_current->callee_saved, 0, sizeof(_callee_saved_t));
+	(void) memset(&_current->callee_saved, 0, sizeof(_callee_saved_t));
 
 	/* Verify context-switch has not occurred yet. */
 	test_flag = switch_flag;
diff -u -p a/tests/lib/cmsis_dsp/transform/src/rf64.c b/tests/lib/cmsis_dsp/transform/src/rf64.c
--- a/tests/lib/cmsis_dsp/transform/src/rf64.c
+++ b/tests/lib/cmsis_dsp/transform/src/rf64.c
@@ -33,7 +33,7 @@ static void test_arm_rfft_f64_real_backe
 	zassert_not_null(scratch, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(scratch, input, length * sizeof(float64_t));
+	(void) memcpy(scratch, input, length * sizeof(float64_t));
 
 	/* Run test function */
 	arm_rfft_fast_f64(&inst, scratch, output, inverse);
diff -u -p a/tests/lib/cmsis_dsp/transform/src/cf32.c b/tests/lib/cmsis_dsp/transform/src/cf32.c
--- a/tests/lib/cmsis_dsp/transform/src/cf32.c
+++ b/tests/lib/cmsis_dsp/transform/src/cf32.c
@@ -27,7 +27,7 @@ static void test_arm_cfft_f32_cmplx_back
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(output, input, length * sizeof(float32_t));
+	(void) memcpy(output, input, length * sizeof(float32_t));
 
 	/* Run test function */
 	arm_cfft_f32(inst, output, inverse, true);
diff -u -p a/tests/lib/cmsis_dsp/transform/src/cq15.c b/tests/lib/cmsis_dsp/transform/src/cq15.c
--- a/tests/lib/cmsis_dsp/transform/src/cq15.c
+++ b/tests/lib/cmsis_dsp/transform/src/cq15.c
@@ -28,7 +28,7 @@ static void test_arm_cfft_q15(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(output, input, length * sizeof(q15_t));
+	(void) memcpy(output, input, length * sizeof(q15_t));
 
 	/* Run test function */
 	arm_cfft_q15(inst, output, false, true);
@@ -111,7 +111,7 @@ static void test_arm_cifft_q15(
 	zassert_not_null(scaled_ref, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(output, input, length * sizeof(q15_t));
+	(void) memcpy(output, input, length * sizeof(q15_t));
 
 	/* Run test function */
 	arm_cfft_q15(inst, output, true, true);
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/binary_q31.c b/tests/lib/cmsis_dsp/matrix/src/binary_q31.c
--- a/tests/lib/cmsis_dsp/matrix/src/binary_q31.c
+++ b/tests/lib/cmsis_dsp/matrix/src/binary_q31.c
@@ -67,11 +67,11 @@ static void test_op2(int op, const q31_t
 		mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input1,
-		       rows * internal * sizeof(q31_t));
+		(void) memcpy(mat_in1.pData, input1,
+				rows * internal * sizeof(q31_t));
 
-		memcpy(mat_in2.pData, input2,
-		       internal * columns * sizeof(q31_t));
+		(void) memcpy(mat_in2.pData, input2,
+				internal * columns * sizeof(q31_t));
 
 		/* Run test function */
 		switch (op) {
@@ -150,11 +150,11 @@ static void test_op2c(int op, const q31_
 		mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input1,
-		       2 * rows * internal * sizeof(q31_t));
+		(void) memcpy(mat_in1.pData, input1,
+				2 * rows * internal * sizeof(q31_t));
 
-		memcpy(mat_in2.pData, input2,
-		       2 * internal * columns * sizeof(q31_t));
+		(void) memcpy(mat_in2.pData, input2,
+				2 * internal * columns * sizeof(q31_t));
 
 		/* Run test function */
 		switch (op) {
diff -u -p a/tests/lib/mem_alloc/src/main.c b/tests/lib/mem_alloc/src/main.c
--- a/tests/lib/mem_alloc/src/main.c
+++ b/tests/lib/mem_alloc/src/main.c
@@ -35,7 +35,7 @@ void test_malloc(void)
 
 	iptr = malloc(BUF_LEN * sizeof(int));
 	zassert_not_null((iptr), "malloc failed, errno: %d", errno);
-	memset(iptr, 'p', BUF_LEN * sizeof(int));
+	(void) memset(iptr, 'p', BUF_LEN * sizeof(int));
 	free(iptr);
 	iptr = NULL;
 }
@@ -70,7 +70,7 @@ void test_calloc(void)
 	zassert_not_null((cptr), "calloc failed, errno: %d", errno);
 	zassert_true(((memcmp(cptr, zerobuf, CALLOC_BUFLEN)) == 0),
 			"calloc failed to set zero value, errno: %d", errno);
-	memset(cptr, 'p', CALLOC_BUFLEN);
+	(void) memset(cptr, 'p', CALLOC_BUFLEN);
 	free(cptr);
 	cptr = NULL;
 }
diff -u -p a/tests/kernel/mem_protect/mem_map/src/main.c b/tests/kernel/mem_protect/mem_map/src/main.c
--- a/tests/kernel/mem_protect/mem_map/src/main.c
+++ b/tests/kernel/mem_protect/mem_map/src/main.c
@@ -100,7 +100,7 @@ void test_z_mem_map_exec(void)
 	z_mem_map(&mapped_rw, (uintptr_t)test_page,
 		  sizeof(test_page), BASE_FLAGS | K_MEM_PERM_RW);
 
-	memcpy(mapped_rw, &transplanted_function, CONFIG_MMU_PAGE_SIZE);
+	(void) memcpy(mapped_rw, &transplanted_function, CONFIG_MMU_PAGE_SIZE);
 
 	/* Now map with execution enabled and try to run the copied fn */
 	z_mem_map(&mapped_exec, (uintptr_t)test_page,
diff -u -p a/samples/net/sockets/http_client/src/main.c b/samples/net/sockets/http_client/src/main.c
--- a/samples/net/sockets/http_client/src/main.c
+++ b/samples/net/sockets/http_client/src/main.c
@@ -40,7 +40,7 @@ static int setup_socket(sa_family_t fami
 	const char *family_str = family == AF_INET ? "IPv4" : "IPv6";
 	int ret = 0;
 
-	memset(addr, 0, addr_len);
+	(void) memset(addr, 0, addr_len);
 
 	if (family == AF_INET) {
 		net_sin(addr)->sin_family = AF_INET;
@@ -190,7 +190,7 @@ void main(void)
 	if (sock4 >= 0 && IS_ENABLED(CONFIG_NET_IPV4)) {
 		struct http_request req;
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.method = HTTP_GET;
 		req.url = "/";
@@ -208,7 +208,7 @@ void main(void)
 	if (sock6 >= 0 && IS_ENABLED(CONFIG_NET_IPV6)) {
 		struct http_request req;
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.method = HTTP_GET;
 		req.url = "/";
@@ -246,7 +246,7 @@ void main(void)
 	if (sock4 >= 0 && IS_ENABLED(CONFIG_NET_IPV4)) {
 		struct http_request req;
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.method = HTTP_POST;
 		req.url = "/foobar";
@@ -266,7 +266,7 @@ void main(void)
 	if (sock6 >= 0 && IS_ENABLED(CONFIG_NET_IPV6)) {
 		struct http_request req;
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.method = HTTP_POST;
 		req.url = "/";
@@ -312,7 +312,7 @@ void main(void)
 			NULL
 		};
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.method = HTTP_POST;
 		req.url = "/chunked-test";
@@ -336,7 +336,7 @@ void main(void)
 			NULL
 		};
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.method = HTTP_POST;
 		req.url = "/chunked-test";
diff -u -p a/samples/net/sockets/websocket_client/src/main.c b/samples/net/sockets/websocket_client/src/main.c
--- a/samples/net/sockets/websocket_client/src/main.c
+++ b/samples/net/sockets/websocket_client/src/main.c
@@ -76,7 +76,7 @@ static int setup_socket(sa_family_t fami
 	const char *family_str = family == AF_INET ? "IPv4" : "IPv6";
 	int ret = 0;
 
-	memset(addr, 0, addr_len);
+	(void) memset(addr, 0, addr_len);
 
 	if (family == AF_INET) {
 		net_sin(addr)->sin_family = AF_INET;
@@ -280,7 +280,7 @@ static bool send_and_wait_msg(int sock, 
 	 *      websocketd --port=9001 cat
 	 * command in server side.
 	 */
-	memcpy(buf, lorem_ipsum, amount);
+	(void) memcpy(buf, lorem_ipsum, amount);
 	buf[amount] = '\n';
 
 	/* Send every 2nd message using dedicated websocket API and generic
@@ -365,7 +365,7 @@ void main(void)
 	if (sock4 >= 0 && IS_ENABLED(CONFIG_NET_IPV4)) {
 		struct websocket_request req;
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.host = SERVER_ADDR4;
 		req.url = "/";
@@ -385,7 +385,7 @@ void main(void)
 	if (sock6 >= 0 && IS_ENABLED(CONFIG_NET_IPV6)) {
 		struct websocket_request req;
 
-		memset(&req, 0, sizeof(req));
+		(void) memset(&req, 0, sizeof(req));
 
 		req.host = SERVER_ADDR6;
 		req.url = "/";
diff -u -p a/samples/net/sockets/echo_server/src/vlan.c b/samples/net/sockets/echo_server/src/vlan.c
--- a/samples/net/sockets/echo_server/src/vlan.c
+++ b/samples/net/sockets/echo_server/src/vlan.c
@@ -95,7 +95,7 @@ int init_vlan(void)
 	struct ud ud;
 	int ret;
 
-	memset(&ud, 0, sizeof(ud));
+	(void) memset(&ud, 0, sizeof(ud));
 
 	net_if_foreach(iface_cb, &ud);
 
diff -u -p a/samples/net/gptp/src/main.c b/samples/net/gptp/src/main.c
--- a/samples/net/gptp/src/main.c
+++ b/samples/net/gptp/src/main.c
@@ -132,7 +132,7 @@ static void gptp_phase_dis_cb(uint8_t *g
 	static uint8_t id[8];
 
 	if (memcmp(id, gm_identity, sizeof(id))) {
-		memcpy(id, gm_identity, sizeof(id));
+		(void) memcpy(id, gm_identity, sizeof(id));
 
 		LOG_DBG("GM %s last phase %d.%" PRId64 "",
 			log_strdup(gptp_sprint_clock_id(gm_identity, output,
diff -u -p a/samples/drivers/led_lpd8806/src/main.c b/samples/drivers/led_lpd8806/src/main.c
--- a/samples/drivers/led_lpd8806/src/main.c
+++ b/samples/drivers/led_lpd8806/src/main.c
@@ -72,8 +72,8 @@ void main(void)
 	time = 0;
 	while (1) {
 		for (i = 0; i < STRIP_NUM_LEDS; i++) {
-			memcpy(&strip_colors[i], color_at(time, i),
-			       sizeof(strip_colors[i]));
+			(void) memcpy(&strip_colors[i], color_at(time, i),
+					sizeof(strip_colors[i]));
 		}
 		led_strip_update_rgb(strip, strip_colors, STRIP_NUM_LEDS);
 		k_sleep(DELAY_TIME);
diff -u -p a/samples/drivers/spi_flash/src/main.c b/samples/drivers/spi_flash/src/main.c
--- a/samples/drivers/spi_flash/src/main.c
+++ b/samples/drivers/spi_flash/src/main.c
@@ -80,7 +80,7 @@ void main(void)
 		return;
 	}
 
-	memset(buf, 0, len);
+	(void) memset(buf, 0, len);
 	rc = flash_read(flash_dev, FLASH_TEST_REGION_OFFSET, buf, len);
 	if (rc != 0) {
 		printf("Flash read failed! %d\n", rc);
diff -u -p a/samples/subsys/canbus/canopen/src/main.c b/samples/subsys/canbus/canopen/src/main.c
--- a/samples/subsys/canbus/canopen/src/main.c
+++ b/samples/subsys/canbus/canopen/src/main.c
@@ -127,7 +127,7 @@ static CO_SDO_abortCode_t odf_2102(CO_OD
 
 	if (value != 0) {
 		/* Preserve old value */
-		memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
+		(void) memcpy(odf_arg->data, odf_arg->ODdataStorage, sizeof(uint32_t));
 		return CO_SDO_AB_DATA_TRANSF;
 	}
 
diff -u -p a/samples/tfm_integration/psa_level_1/src/util_app_cfg.c b/samples/tfm_integration/psa_level_1/src/util_app_cfg.c
--- a/samples/tfm_integration/psa_level_1/src/util_app_cfg.c
+++ b/samples/tfm_integration/psa_level_1/src/util_app_cfg.c
@@ -57,7 +57,7 @@ psa_status_t cfg_load_data(struct cfg_da
 	psa_status_t status;
 	struct psa_storage_info_t p_info;
 
-	memset(&p_info, 0, sizeof(p_info));
+	(void) memset(&p_info, 0, sizeof(p_info));
 
 	/* Check if the config record exists, if not create it. */
 	status = psa_ps_get_info(cfg_data_uid, &p_info);
@@ -65,7 +65,7 @@ psa_status_t cfg_load_data(struct cfg_da
 		/* Create a new config file. */
 		status = cfg_create_data();
 		/* Copy default values to the cfg_data placeholder. */
-		memcpy(p_cfg_data, &cfg_data_dflt, sizeof(cfg_data_dflt));
+		(void) memcpy(p_cfg_data, &cfg_data_dflt, sizeof(cfg_data_dflt));
 	}
 	if (status) {
 		goto err;
diff -u -p a/samples/bluetooth/peripheral_hids/src/hog.c b/samples/bluetooth/peripheral_hids/src/hog.c
--- a/samples/bluetooth/peripheral_hids/src/hog.c
+++ b/samples/bluetooth/peripheral_hids/src/hog.c
@@ -134,7 +134,7 @@ static ssize_t write_ctrl_point(struct b
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/samples/bluetooth/mesh_provisioner/src/main.c b/samples/bluetooth/mesh_provisioner/src/main.c
--- a/samples/bluetooth/mesh_provisioner/src/main.c
+++ b/samples/bluetooth/mesh_provisioner/src/main.c
@@ -190,7 +190,7 @@ static void unprovisioned_beacon(uint8_t
 				 bt_mesh_prov_oob_info_t oob_info,
 				 uint32_t *uri_hash)
 {
-	memcpy(node_uuid, uuid, 16);
+	(void) memcpy(node_uuid, uuid, 16);
 	k_sem_give(&sem_unprov_beacon);
 }
 
diff -u -p a/samples/boards/reel_board/mesh_badge/src/mesh.c b/samples/boards/reel_board/mesh_badge/src/mesh.c
--- a/samples/boards/reel_board/mesh_badge/src/mesh.c
+++ b/samples/boards/reel_board/mesh_badge/src/mesh.c
@@ -328,7 +328,7 @@ static void vnd_hello(struct bt_mesh_mod
 	}
 
 	len = MIN(buf->len, HELLO_MAX);
-	memcpy(str, buf->data, len);
+	(void) memcpy(str, buf->data, len);
 	str[len] = '\0';
 
 	board_add_hello(ctx->addr, str);
@@ -354,7 +354,7 @@ static void vnd_baduser(struct bt_mesh_m
 	}
 
 	len = MIN(buf->len, HELLO_MAX);
-	memcpy(str, buf->data, len);
+	(void) memcpy(str, buf->data, len);
 	str[len] = '\0';
 
 	strcat(str, " is misbehaving!");
diff -u -p a/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c b/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c
--- a/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c
+++ b/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c
@@ -226,7 +226,7 @@ static void i2s_prepare_audio(const stru
 				buffer, frame_counter);
 
 		/* fill the buffer with zeros (silence) */
-		memset(buffer, 0, AUDIO_FRAME_BUF_BYTES);
+		(void) memset(buffer, 0, AUDIO_FRAME_BUF_BYTES);
 
 		ret = i2s_write(dev, buffer, AUDIO_FRAME_BUF_BYTES);
 		if (ret) {
@@ -259,7 +259,7 @@ static void i2s_play_audio(void)
 			return;
 		}
 
-		memcpy(copy_buf, in_buf, AUDIO_FRAME_BUF_BYTES);
+		(void) memcpy(copy_buf, in_buf, AUDIO_FRAME_BUF_BYTES);
 
 		/* loop the audio back to the host */
 		ret = i2s_write(host_i2s_dev, copy_buf, AUDIO_FRAME_BUF_BYTES);
diff -u -p a/arch/x86/core/x86_mmu.c b/arch/x86/core/x86_mmu.c
--- a/arch/x86/core/x86_mmu.c
+++ b/arch/x86/core/x86_mmu.c
@@ -523,7 +523,7 @@ static void *page_pool_get(void *context
 	k_spin_unlock(&pool_lock, key);
 
 	if (ret != NULL) {
-		memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
+		(void) memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
 	}
 
 	return ret;
@@ -804,7 +804,7 @@ static void *thread_page_pool_get(void *
 		ret = NULL;
 	} else {
 		thread->arch.mmu_pos += CONFIG_MMU_PAGE_SIZE;
-		memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
+		(void) memset(ret, 0, CONFIG_MMU_PAGE_SIZE);
 	}
 	k_spin_unlock(&pool_lock, key);
 
diff -u -p a/boards/posix/native_posix/cmdline.c b/boards/posix/native_posix/cmdline.c
--- a/boards/posix/native_posix/cmdline.c
+++ b/boards/posix/native_posix/cmdline.c
@@ -67,8 +67,8 @@ void native_add_command_line_opts(struct
 		/* LCOV_EXCL_STOP */
 	}
 
-	memcpy(&args_struct[used_args], args,
-		count*sizeof(struct args_struct_t));
+	(void) memcpy(&args_struct[used_args], args,
+			count*sizeof(struct args_struct_t));
 
 	used_args += count - 1;
 	/*
diff -u -p a/lib/libc/minimal/source/stdlib/malloc.c b/lib/libc/minimal/source/stdlib/malloc.c
--- a/lib/libc/minimal/source/stdlib/malloc.c
+++ b/lib/libc/minimal/source/stdlib/malloc.c
@@ -89,7 +89,7 @@ void *realloc(void *ptr, size_t requeste
 		return NULL;
 	}
 
-	memcpy(new_ptr, ptr, copy_size);
+	(void) memcpy(new_ptr, ptr, copy_size);
 	free(ptr);
 
 	return new_ptr;
diff -u -p a/kernel/thread.c b/kernel/thread.c
--- a/kernel/thread.c
+++ b/kernel/thread.c
@@ -477,7 +477,7 @@ static char *setup_thread_stack(struct k
 		stack_buf_size, stack_ptr);
 
 #ifdef CONFIG_INIT_STACKS
-	memset(stack_buf_start, 0xaa, stack_buf_size);
+	(void) memset(stack_buf_start, 0xaa, stack_buf_size);
 #endif
 #ifdef CONFIG_STACK_SENTINEL
 	/* Put the stack sentinel at the lowest 4 bytes of the stack area.
@@ -810,8 +810,8 @@ FUNC_NORETURN void k_thread_user_mode_en
 #ifdef CONFIG_USERSPACE
 	__ASSERT(z_stack_is_user_capable(_current->stack_obj),
 		 "dropping to user mode with kernel-only stack object");
-	memset(_current->userspace_local_data, 0,
-	       sizeof(struct _thread_userspace_local_data));
+	(void) memset(_current->userspace_local_data, 0,
+			sizeof(struct _thread_userspace_local_data));
 	arch_user_mode_enter(entry, p1, p2, p3);
 #else
 	/* XXX In this case we do not reset the stack */
diff -u -p a/drivers/wifi/simplelink/simplelink_support.c b/drivers/wifi/simplelink/simplelink_support.c
--- a/drivers/wifi/simplelink/simplelink_support.c
+++ b/drivers/wifi/simplelink/simplelink_support.c
@@ -80,7 +80,7 @@ static int32_t configure_simplelink(void
 	struct in_addr addr4;
 	SlNetCfgIpV4Args_t ipV4;
 
-	memset(&ipV4, 0, sizeof(ipV4));
+	(void) memset(&ipV4, 0, sizeof(ipV4));
 #endif
 
 	/* Turn on NWP */
@@ -265,10 +265,10 @@ void SimpleLinkWlanEventHandler(SlWlanEv
 		SET_STATUS_BIT(nwp.status, STATUS_BIT_CONNECTION);
 
 		/* Store new connection SSID and BSSID: */
-		memcpy(sl_conn.ssid, wlan_event->Data.Connect.SsidName,
-		       wlan_event->Data.Connect.SsidLen);
-		memcpy(sl_conn.bssid, wlan_event->Data.Connect.Bssid,
-		       BSSID_LEN_MAX);
+		(void) memcpy(sl_conn.ssid, wlan_event->Data.Connect.SsidName,
+				wlan_event->Data.Connect.SsidLen);
+		(void) memcpy(sl_conn.bssid, wlan_event->Data.Connect.Bssid,
+				BSSID_LEN_MAX);
 
 		LOG_INF("[WLAN EVENT] STA Connected to the AP: %s, "
 			"BSSID: %x:%x:%x:%x:%x:%x",
@@ -324,8 +324,8 @@ void SimpleLinkWlanEventHandler(SlWlanEv
 		break;
 
 	case SL_WLAN_EVENT_STA_ADDED:
-		memcpy(&(sl_conn.bssid), wlan_event->Data.STAAdded.Mac,
-		       SL_WLAN_BSSID_LENGTH);
+		(void) memcpy(&(sl_conn.bssid), wlan_event->Data.STAAdded.Mac,
+				SL_WLAN_BSSID_LENGTH);
 		LOG_INF("[WLAN EVENT] STA was added to AP: "
 			"BSSID: %x:%x:%x:%x:%x:%x",
 			sl_conn.bssid[0], sl_conn.bssid[1],
@@ -333,8 +333,8 @@ void SimpleLinkWlanEventHandler(SlWlanEv
 			sl_conn.bssid[4], sl_conn.bssid[5]);
 		break;
 	case SL_WLAN_EVENT_STA_REMOVED:
-		memcpy(&(sl_conn.bssid), wlan_event->Data.STAAdded.Mac,
-		       SL_WLAN_BSSID_LENGTH);
+		(void) memcpy(&(sl_conn.bssid), wlan_event->Data.STAAdded.Mac,
+				SL_WLAN_BSSID_LENGTH);
 		LOG_INF("[WLAN EVENT] STA was removed from AP: "
 			"BSSID: %x:%x:%x:%x:%x:%x",
 			sl_conn.bssid[0], sl_conn.bssid[1],
@@ -557,7 +557,7 @@ void z_simplelink_get_scan_result(int in
 	(void)memset(scan_result, 0x0, sizeof(struct wifi_scan_result));
 
 	__ASSERT_NO_MSG(net_entry->SsidLen <= WIFI_SSID_MAX_LEN);
-	memcpy(scan_result->ssid, net_entry->Ssid, net_entry->SsidLen);
+	(void) memcpy(scan_result->ssid, net_entry->Ssid, net_entry->SsidLen);
 	scan_result->ssid_length = net_entry->SsidLen;
 	scan_result->channel = net_entry->Channel;
 
diff -u -p a/drivers/wifi/eswifi/eswifi_bus_spi.c b/drivers/wifi/eswifi/eswifi_bus_spi.c
--- a/drivers/wifi/eswifi/eswifi_bus_spi.c
+++ b/drivers/wifi/eswifi/eswifi_bus_spi.c
@@ -157,7 +157,7 @@ data:
 
 	while (eswifi_spi_cmddata_ready(spi) && to_read) {
 		to_read = MIN(rlen - offset, to_read);
-		memset(rsp + offset, 0, to_read);
+		(void) memset(rsp + offset, 0, to_read);
 		eswifi_spi_read(eswifi, rsp + offset, to_read);
 		offset += to_read;
 		k_yield();
diff -u -p a/drivers/wifi/eswifi/eswifi_shell.c b/drivers/wifi/eswifi/eswifi_shell.c
--- a/drivers/wifi/eswifi/eswifi_shell.c
+++ b/drivers/wifi/eswifi/eswifi_shell.c
@@ -38,7 +38,7 @@ static int eswifi_shell_atcmd(const stru
 
 	eswifi_lock(eswifi);
 
-	memset(eswifi->buf, 0, sizeof(eswifi->buf));
+	(void) memset(eswifi->buf, 0, sizeof(eswifi->buf));
 	for (i = 1; i < argc; i++) {
 		strcat(eswifi->buf, argv[i]);
 	}
diff -u -p a/drivers/ieee802154/ieee802154_uart_pipe.c b/drivers/ieee802154/ieee802154_uart_pipe.c
--- a/drivers/ieee802154/ieee802154_uart_pipe.c
+++ b/drivers/ieee802154/ieee802154_uart_pipe.c
@@ -142,7 +142,7 @@ static uint8_t *upipe_rx(uint8_t *buf, s
 
 		net_pkt_frag_insert(pkt, frag);
 
-		memcpy(frag->data, upipe->rx_buf, upipe->rx_len);
+		(void) memcpy(frag->data, upipe->rx_buf, upipe->rx_len);
 		net_buf_add(frag, upipe->rx_len);
 
 #if defined(CONFIG_IEEE802154_UPIPE_HW_FILTER)
@@ -210,7 +210,7 @@ static int upipe_set_pan_id(const struct
 	ARG_UNUSED(dev);
 
 	sys_put_le16(pan_id, pan_id_le);
-	memcpy(dev_pan_id, pan_id_le, PAN_ID_SIZE);
+	(void) memcpy(dev_pan_id, pan_id_le, PAN_ID_SIZE);
 
 	return 0;
 }
@@ -222,7 +222,7 @@ static int upipe_set_short_addr(const st
 	ARG_UNUSED(dev);
 
 	sys_put_le16(short_addr, short_addr_le);
-	memcpy(dev_short_addr, short_addr_le, SHORT_ADDRESS_SIZE);
+	(void) memcpy(dev_short_addr, short_addr_le, SHORT_ADDRESS_SIZE);
 
 	return 0;
 }
@@ -232,7 +232,7 @@ static int upipe_set_ieee_addr(const str
 {
 	ARG_UNUSED(dev);
 
-	memcpy(dev_ext_addr, ieee_addr, EXTENDED_ADDRESS_SIZE);
+	(void) memcpy(dev_ext_addr, ieee_addr, EXTENDED_ADDRESS_SIZE);
 
 	return 0;
 }
diff -u -p a/drivers/crypto/crypto_tc_shim.c b/drivers/crypto/crypto_tc_shim.c
--- a/drivers/crypto/crypto_tc_shim.c
+++ b/drivers/crypto/crypto_tc_shim.c
@@ -83,7 +83,7 @@ static int do_ctr_op(struct cipher_ctx *
 	/* Tinycrypt takes the last 4 bytes of the counter parameter as the
 	 * true counter start. IV forms the first 12 bytes of the split counter.
 	 */
-	memcpy(ctr, iv, ivlen);
+	(void) memcpy(ctr, iv, ivlen);
 
 	if (tc_ctr_mode(op->out_buf, op->out_buf_max, op->in_buf,
 			op->in_len, ctr,
@@ -126,7 +126,7 @@ static int do_ccm_encrypt_mac(struct cip
 	 * both encrypted output and hash
 	 */
 	if (aead_op->tag) {
-		memcpy(aead_op->tag, op->out_buf + op->in_len, ccm.mlen);
+		(void) memcpy(aead_op->tag, op->out_buf + op->in_len, ccm.mlen);
 	}
 
 	/* Before returning TC_CRYPTO_SUCCESS, tc_ccm_generation_encryption()
diff -u -p a/drivers/crypto/crypto_stm32.c b/drivers/crypto/crypto_stm32.c
--- a/drivers/crypto/crypto_stm32.c
+++ b/drivers/crypto/crypto_stm32.c
@@ -37,7 +37,7 @@ static void copy_reverse_words(uint8_t *
 	__ASSERT_NO_MSG(dst_len >= src_len);
 	__ASSERT_NO_MSG((dst_len % 4) == 0);
 
-	memcpy(dst_buf, src_buf, src_len);
+	(void) memcpy(dst_buf, src_buf, src_len);
 	for (i = 0; i < dst_len; i += sizeof(uint32_t)) {
 		sys_mem_swap(&dst_buf[i], sizeof(uint32_t));
 	}
@@ -159,7 +159,7 @@ static int crypto_stm32_cbc_encrypt(stru
 
 	if ((ctx->flags & CAP_NO_IV_PREFIX) == 0U) {
 		/* Prefix IV to ciphertext unless CAP_NO_IV_PREFIX is set. */
-		memcpy(pkt->out_buf, iv, 16);
+		(void) memcpy(pkt->out_buf, iv, 16);
 		out_offset = 16;
 	}
 
@@ -311,7 +311,7 @@ static int crypto_stm32_session_setup(co
 		return -ENOSPC;
 	}
 	session = &crypto_stm32_sessions[ctx_idx];
-	memset(&session->config, 0, sizeof(session->config));
+	(void) memset(&session->config, 0, sizeof(session->config));
 
 	if (data->hcryp.State == HAL_CRYP_STATE_RESET) {
 		if (HAL_CRYP_Init(&data->hcryp) != HAL_OK) {
diff -u -p a/drivers/hwinfo/hwinfo_esp32.c b/drivers/hwinfo/hwinfo_esp32.c
--- a/drivers/hwinfo/hwinfo_esp32.c
+++ b/drivers/hwinfo/hwinfo_esp32.c
@@ -32,7 +32,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 	if (length > sizeof(id)) {
 		length = sizeof(id);
 	}
-	memcpy(buffer, id, length);
+	(void) memcpy(buffer, id, length);
 
 	return length;
 }
diff -u -p a/drivers/hwinfo/hwinfo_mcux_sim.c b/drivers/hwinfo/hwinfo_mcux_sim.c
--- a/drivers/hwinfo/hwinfo_mcux_sim.c
+++ b/drivers/hwinfo/hwinfo_mcux_sim.c
@@ -46,7 +46,7 @@ ssize_t z_impl_hwinfo_get_device_id(uint
 		length = sizeof(id);
 	}
 
-	memcpy(buffer, id, length);
+	(void) memcpy(buffer, id, length);
 
 	return length;
 }
diff -u -p a/drivers/i2c/i2c_handlers.c b/drivers/i2c/i2c_handlers.c
--- a/drivers/i2c/i2c_handlers.c
+++ b/drivers/i2c/i2c_handlers.c
@@ -25,7 +25,7 @@ static uint32_t copy_msgs_and_transfer(c
 	uint8_t i;
 
 	/* Use a local copy to avoid switcheroo attacks. */
-	memcpy(copy, msgs, num_msgs * sizeof(*msgs));
+	(void) memcpy(copy, msgs, num_msgs * sizeof(*msgs));
 
 	/* Validate the buffers in each message struct. Read options require
 	 * that the target buffer be writable
diff -u -p a/drivers/entropy/entropy_esp32.c b/drivers/entropy/entropy_esp32.c
--- a/drivers/entropy/entropy_esp32.c
+++ b/drivers/entropy/entropy_esp32.c
@@ -35,12 +35,12 @@ static int entropy_esp32_get_entropy(con
 		uint32_t v = entropy_esp32_get_u32();
 
 		if (len >= sizeof(v)) {
-			memcpy(buf, &v, sizeof(v));
+			(void) memcpy(buf, &v, sizeof(v));
 
 			buf += sizeof(v);
 			len -= sizeof(v);
 		} else {
-			memcpy(buf, &v, len);
+			(void) memcpy(buf, &v, len);
 			break;
 		}
 	}
diff -u -p a/drivers/ethernet/eth_mcux.c b/drivers/ethernet/eth_mcux.c
--- a/drivers/ethernet/eth_mcux.c
+++ b/drivers/ethernet/eth_mcux.c
@@ -683,8 +683,8 @@ static bool eth_get_ptp_data(struct net_
 		}
 
 		ptpTsData->version = hdr->ptp_version;
-		memcpy(ptpTsData->sourcePortId, &hdr->port_id,
-		       kENET_PtpSrcPortIdLen);
+		(void) memcpy(ptpTsData->sourcePortId, &hdr->port_id,
+				kENET_PtpSrcPortIdLen);
 		ptpTsData->messageType = hdr->message_type;
 		ptpTsData->sequenceId = ntohs(hdr->sequence_id);
 
diff -u -p a/drivers/usb/device/usb_dc_nrfx.c b/drivers/usb/device/usb_dc_nrfx.c
--- a/drivers/usb/device/usb_dc_nrfx.c
+++ b/drivers/usb/device/usb_dc_nrfx.c
@@ -708,28 +708,28 @@ static void eps_ctx_uninit(void)
 		ep_ctx = in_endpoint_ctx(i);
 		__ASSERT_NO_MSG(ep_ctx);
 		k_mem_pool_free(&ep_ctx->buf.block);
-		memset(ep_ctx, 0, sizeof(*ep_ctx));
+		(void) memset(ep_ctx, 0, sizeof(*ep_ctx));
 	}
 
 	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
 		ep_ctx = out_endpoint_ctx(i);
 		__ASSERT_NO_MSG(ep_ctx);
 		k_mem_pool_free(&ep_ctx->buf.block);
-		memset(ep_ctx, 0, sizeof(*ep_ctx));
+		(void) memset(ep_ctx, 0, sizeof(*ep_ctx));
 	}
 
 	if (CFG_EP_ISOIN_CNT) {
 		ep_ctx = in_endpoint_ctx(NRF_USBD_EPIN(8));
 		__ASSERT_NO_MSG(ep_ctx);
 		k_mem_pool_free(&ep_ctx->buf.block);
-		memset(ep_ctx, 0, sizeof(*ep_ctx));
+		(void) memset(ep_ctx, 0, sizeof(*ep_ctx));
 	}
 
 	if (CFG_EP_ISOOUT_CNT) {
 		ep_ctx = out_endpoint_ctx(NRF_USBD_EPOUT(8));
 		__ASSERT_NO_MSG(ep_ctx);
 		k_mem_pool_free(&ep_ctx->buf.block);
-		memset(ep_ctx, 0, sizeof(*ep_ctx));
+		(void) memset(ep_ctx, 0, sizeof(*ep_ctx));
 	}
 }
 
@@ -812,7 +812,7 @@ static inline void usbd_work_process_set
 	 * SETUP packet must be reassembled.
 	 */
 	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
-	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
+	(void) memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
 	usbd_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
 	usbd_setup->bRequest = nrf_usbd_setup_brequest_get(NRF_USBD);
 	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
@@ -1727,7 +1727,7 @@ int usb_dc_ep_write(const uint8_t ep, co
 		bytes_to_copy = data_len;
 		ep_ctx->write_fragmented = false;
 	}
-	memcpy(ep_ctx->buf.data, data, bytes_to_copy);
+	(void) memcpy(ep_ctx->buf.data, data, bytes_to_copy);
 	ep_ctx->buf.len = bytes_to_copy;
 
 	if (ret_bytes) {
@@ -1800,7 +1800,7 @@ int usb_dc_ep_read_wait(uint8_t ep, uint
 		return 0;
 	}
 
-	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
+	(void) memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
 
 	ep_ctx->buf.curr += bytes_to_copy;
 	ep_ctx->buf.len -= bytes_to_copy;
diff -u -p a/drivers/flash/flash_sam0.c b/drivers/flash/flash_sam0.c
--- a/drivers/flash/flash_sam0.c
+++ b/drivers/flash/flash_sam0.c
@@ -244,7 +244,7 @@ static int flash_sam0_write(const struct
 		if (base != ctx->offset) {
 			/* Started a new row.  Flush any pending ones. */
 			flash_sam0_commit(dev);
-			memcpy(ctx->buf, (void *)base, sizeof(ctx->buf));
+			(void) memcpy(ctx->buf, (void *)base, sizeof(ctx->buf));
 			ctx->offset = base;
 		}
 
@@ -308,7 +308,7 @@ static int flash_sam0_read(const struct 
 		return err;
 	}
 
-	memcpy(data, (uint8_t *)CONFIG_FLASH_BASE_ADDRESS + offset, len);
+	(void) memcpy(data, (uint8_t *)CONFIG_FLASH_BASE_ADDRESS + offset, len);
 
 	return 0;
 }
diff -u -p a/drivers/flash/flash_gecko.c b/drivers/flash/flash_gecko.c
--- a/drivers/flash/flash_gecko.c
+++ b/drivers/flash/flash_gecko.c
@@ -50,7 +50,7 @@ static int flash_gecko_read(const struct
 		return 0;
 	}
 
-	memcpy(data, (uint8_t *)CONFIG_FLASH_BASE_ADDRESS + offset, size);
+	(void) memcpy(data, (uint8_t *)CONFIG_FLASH_BASE_ADDRESS + offset, size);
 
 	return 0;
 }
diff -u -p a/drivers/flash/flash_stm32.c b/drivers/flash/flash_stm32.c
--- a/drivers/flash/flash_stm32.c
+++ b/drivers/flash/flash_stm32.c
@@ -198,7 +198,7 @@ static int flash_stm32_read(const struct
 
 	LOG_DBG("Read offset: %ld, len: %zu", (long int) offset, len);
 
-	memcpy(data, (uint8_t *) CONFIG_FLASH_BASE_ADDRESS + offset, len);
+	(void) memcpy(data, (uint8_t *) CONFIG_FLASH_BASE_ADDRESS + offset, len);
 
 	return 0;
 }
diff -u -p a/drivers/spi/spi_ll_stm32.c b/drivers/spi/spi_ll_stm32.c
--- a/drivers/spi/spi_ll_stm32.c
+++ b/drivers/spi/spi_ll_stm32.c
@@ -100,7 +100,7 @@ static int spi_stm32_dma_tx_load(const s
 	blk_cfg = &stream->dma_blk_cfg;
 
 	/* prepare the block for this TX DMA channel */
-	memset(blk_cfg, 0, sizeof(struct dma_block_config));
+	(void) memset(blk_cfg, 0, sizeof(struct dma_block_config));
 	blk_cfg->block_size = len;
 
 	/* tx direction has memory as source and periph as dest. */
@@ -159,7 +159,7 @@ static int spi_stm32_dma_rx_load(const s
 	blk_cfg = &stream->dma_blk_cfg;
 
 	/* prepare the block for this RX DMA channel */
-	memset(blk_cfg, 0, sizeof(struct dma_block_config));
+	(void) memset(blk_cfg, 0, sizeof(struct dma_block_config));
 	blk_cfg->block_size = len;
 
 
diff -u -p a/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c b/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c
--- a/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c
+++ b/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c
@@ -58,7 +58,7 @@ static int temp_kinetis_sample_fetch(con
 	}
 
 #ifdef CONFIG_TEMP_KINETIS_FILTER
-	memcpy(previous, data->buffer, sizeof(previous));
+	(void) memcpy(previous, data->buffer, sizeof(previous));
 #endif /* CONFIG_TEMP_KINETIS_FILTER */
 
 	err = adc_read(data->adc, &config->adc_seq);
@@ -160,7 +160,7 @@ static int temp_kinetis_init(const struc
 		},
 	};
 
-	memset(&data->buffer, 0, ARRAY_SIZE(data->buffer));
+	(void) memset(&data->buffer, 0, ARRAY_SIZE(data->buffer));
 
 	data->adc = device_get_binding(config->adc_dev_name);
 	if (!data->adc) {
diff -u -p a/drivers/bluetooth/hci/spi.c b/drivers/bluetooth/hci/spi.c
--- a/drivers/bluetooth/hci/spi.c
+++ b/drivers/bluetooth/hci/spi.c
@@ -377,7 +377,7 @@ static void bt_spi_rx_thread(void)
 				break;
 			case HCI_ACL:
 				buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
-				memcpy(&acl_hdr, &rxmsg[1], sizeof(acl_hdr));
+				(void) memcpy(&acl_hdr, &rxmsg[1], sizeof(acl_hdr));
 				net_buf_add_mem(buf, &acl_hdr, sizeof(acl_hdr));
 				net_buf_add_mem(buf, &rxmsg[5],
 						sys_le16_to_cpu(acl_hdr.len));
diff -u -p a/drivers/modem/hl7800.c b/drivers/modem/hl7800.c
--- a/drivers/modem/hl7800.c
+++ b/drivers/modem/hl7800.c
@@ -1025,8 +1025,8 @@ int32_t mdm_hl7800_get_local_time(struct
 	ret = send_at_cmd(NULL, "AT+CCLK?", MDM_CMD_SEND_TIMEOUT, 0, false);
 	allow_sleep(true);
 	if (ictx.local_time_valid) {
-		memcpy(tm, &ictx.local_time, sizeof(struct tm));
-		memcpy(offset, &ictx.local_time_offset, sizeof(*offset));
+		(void) memcpy(tm, &ictx.local_time, sizeof(struct tm));
+		(void) memcpy(offset, &ictx.local_time_offset, sizeof(*offset));
 	} else {
 		ret = -EIO;
 	}
@@ -1774,20 +1774,21 @@ static bool on_cmd_radio_band_configurat
 		return true;
 	}
 
-	memcpy(ictx.mdm_bands_string, &value[MDM_TOP_BAND_START_POSITION],
-	       MDM_HL7800_LTE_BAND_STRLEN);
+	(void) memcpy(ictx.mdm_bands_string,
+			&value[MDM_TOP_BAND_START_POSITION],
+			MDM_HL7800_LTE_BAND_STRLEN);
 
-	memcpy(n_tmp, &value[MDM_TOP_BAND_START_POSITION], MDM_TOP_BAND_SIZE);
+	(void) memcpy(n_tmp, &value[MDM_TOP_BAND_START_POSITION], MDM_TOP_BAND_SIZE);
 	n_tmp[MDM_TOP_BAND_SIZE] = 0;
 	ictx.mdm_bands_top = strtoul(n_tmp, NULL, 16);
 
-	memcpy(n_tmp, &value[MDM_MIDDLE_BAND_START_POSITION],
-	       MDM_MIDDLE_BAND_SIZE);
+	(void) memcpy(n_tmp, &value[MDM_MIDDLE_BAND_START_POSITION],
+			MDM_MIDDLE_BAND_SIZE);
 	n_tmp[MDM_MIDDLE_BAND_SIZE] = 0;
 	ictx.mdm_bands_middle = strtoul(n_tmp, NULL, 16);
 
-	memcpy(n_tmp, &value[MDM_BOTTOM_BAND_START_POSITION],
-	       MDM_BOTTOM_BAND_SIZE);
+	(void) memcpy(n_tmp, &value[MDM_BOTTOM_BAND_START_POSITION],
+			MDM_BOTTOM_BAND_SIZE);
 	n_tmp[MDM_BOTTOM_BAND_SIZE] = 0;
 	ictx.mdm_bands_bottom = strtoul(n_tmp, NULL, 16);
 
@@ -1812,8 +1813,8 @@ static bool on_cmd_radio_active_bands(st
 		return true;
 	}
 
-	memcpy(ictx.mdm_active_bands_string,
-	       &value[MDM_TOP_BAND_START_POSITION], MDM_HL7800_LTE_BAND_STRLEN);
+	(void) memcpy(ictx.mdm_active_bands_string,
+			&value[MDM_TOP_BAND_START_POSITION], MDM_HL7800_LTE_BAND_STRLEN);
 	event_handler(HL7800_EVENT_ACTIVE_BANDS, ictx.mdm_active_bands_string);
 
 	return true;
@@ -1933,7 +1934,7 @@ static bool on_cmd_startup_report(struct
 	size_t out_len;
 	char value[MDM_MAX_RESP_SIZE];
 
-	memset(value, 0, sizeof(value));
+	(void) memset(value, 0, sizeof(value));
 	out_len = net_buf_linearize(value, sizeof(value), *buf, 0, len);
 	if (out_len > 0) {
 		set_startup_state(strtol(value, NULL, 10));
@@ -1982,7 +1983,7 @@ static bool profile_handler(struct net_b
 	/* Parse configuration data to determine if echo is on/off. */
 	line_length = net_buf_findcrlf(*buf, &frag);
 	if (line_length) {
-		memset(line, 0, sizeof(line));
+		(void) memset(line, 0, sizeof(line));
 		output_length = net_buf_linearize(line, SIZE_WITHOUT_NUL(line),
 						  *buf, 0, line_length);
 		LOG_DBG("length: %u: %s", line_length, log_strdup(line));
@@ -2043,15 +2044,15 @@ static bool on_cmd_atcmdinfo_pdp_authent
 
 	line_length = net_buf_findcrlf(*buf, &frag);
 	if (line_length) {
-		memset(line, 0, sizeof(line));
+		(void) memset(line, 0, sizeof(line));
 		output_length = net_buf_linearize(line, SIZE_WITHOUT_NUL(line),
 						  *buf, 0, line_length);
 		LOG_DBG("length: %u: %s", line_length, log_strdup(line));
 		if (output_length > 0) {
-			memset(ictx.mdm_apn.username, 0,
-			       sizeof(ictx.mdm_apn.username));
-			memset(ictx.mdm_apn.password, 0,
-			       sizeof(ictx.mdm_apn.password));
+			(void) memset(ictx.mdm_apn.username, 0,
+					sizeof(ictx.mdm_apn.username));
+			(void) memset(ictx.mdm_apn.password, 0,
+					sizeof(ictx.mdm_apn.password));
 
 			i = 0;
 			p = strchr(line, '"');
@@ -2105,13 +2106,13 @@ static bool on_cmd_atcmdinfo_pdp_context
 
 	line_length = net_buf_findcrlf(*buf, &frag);
 	if (line_length) {
-		memset(line, 0, sizeof(line));
+		(void) memset(line, 0, sizeof(line));
 		output_length = net_buf_linearize(line, SIZE_WITHOUT_NUL(line),
 						  *buf, 0, line_length);
 		LOG_DBG("length: %u: %s", line_length, log_strdup(line));
 		if (output_length > 0) {
-			memset(ictx.mdm_apn.value, 0,
-			       sizeof(ictx.mdm_apn.value));
+			(void) memset(ictx.mdm_apn.value, 0,
+					sizeof(ictx.mdm_apn.value));
 
 			/* The name is after the 3rd " */
 			p = strchr(line, '"');
@@ -2341,7 +2342,7 @@ static bool on_cmd_rtc_query(struct net_
 	size_t str_len = sizeof(TIME_STRING_FORMAT) - 1;
 	char rtc_string[sizeof(TIME_STRING_FORMAT)];
 
-	memset(rtc_string, 0, sizeof(rtc_string));
+	(void) memset(rtc_string, 0, sizeof(rtc_string));
 	ictx.local_time_valid = false;
 
 	wait_for_modem_data_and_newline(buf, net_buf_frags_len(*buf),
@@ -2394,8 +2395,8 @@ int get_next_time_string_digit(int *fail
 	char digits[TIME_STRING_DIGIT_STRLEN + SIZE_OF_NUL];
 	int result;
 
-	memset(digits, 0, sizeof(digits));
-	memcpy(digits, *pp, TIME_STRING_DIGIT_STRLEN);
+	(void) memset(digits, 0, sizeof(digits));
+	(void) memcpy(digits, *pp, TIME_STRING_DIGIT_STRLEN);
 	*pp += TIME_STRING_DIGIT_STRLEN + TIME_STRING_SEPARATOR_STRLEN;
 	result = strtol(digits, NULL, 10);
 	if (result > max) {
@@ -2578,7 +2579,7 @@ static bool on_cmd_sockerror(struct net_
 	char string[MDM_MAX_RESP_SIZE];
 
 	if (len > 0) {
-		memset(string, 0, sizeof(string));
+		(void) memset(string, 0, sizeof(string));
 		net_buf_linearize(string, sizeof(string), *buf, 0, len);
 		LOG_ERR("'%s'", string);
 	}
@@ -3084,7 +3085,7 @@ static bool on_cmd_device_service_ind(st
 	char value[MDM_MAX_RESP_SIZE];
 	size_t out_len;
 
-	memset(value, 0, sizeof(value));
+	(void) memset(value, 0, sizeof(value));
 	out_len = net_buf_linearize(value, sizeof(value), *buf, 0, len);
 	if (out_len > 0) {
 		ictx.device_services_ind = strtol(value, NULL, 10);
@@ -3998,7 +3999,7 @@ static int write_apn(char *access_point_
 	char cmd_string[MDM_HL7800_APN_CMD_MAX_SIZE];
 
 	/* PDP Context */
-	memset(cmd_string, 0, MDM_HL7800_APN_CMD_MAX_SIZE);
+	(void) memset(cmd_string, 0, MDM_HL7800_APN_CMD_MAX_SIZE);
 	strncat(cmd_string, "AT+CGDCONT=1,\"IP\",\"",
 		MDM_HL7800_APN_CMD_MAX_STRLEN);
 	strncat(cmd_string, access_point_name, MDM_HL7800_APN_CMD_MAX_STRLEN);
diff -u -p a/drivers/ipm/ipm_mcux.c b/drivers/ipm/ipm_mcux.c
--- a/drivers/ipm/ipm_mcux.c
+++ b/drivers/ipm/ipm_mcux.c
@@ -88,7 +88,7 @@ static int mcux_mailbox_ipm_send(const s
 	flags = irq_lock();
 
 	/* Actual message is passing using 32 bits registers */
-	memcpy(data32, data, size);
+	(void) memcpy(data32, data, size);
 
 	for (i = 0; i < ARRAY_SIZE(data32); ++i) {
 		MAILBOX_SetValueBits(base, MAILBOX_ID_OTHER_CPU, data32[i]);
diff -u -p a/drivers/display/ssd16xx.c b/drivers/display/ssd16xx.c
--- a/drivers/display/ssd16xx.c
+++ b/drivers/display/ssd16xx.c
@@ -353,7 +353,7 @@ static int ssd16xx_set_contrast(const st
 static void ssd16xx_get_capabilities(const struct device *dev,
 				     struct display_capabilities *caps)
 {
-	memset(caps, 0, sizeof(struct display_capabilities));
+	(void) memset(caps, 0, sizeof(struct display_capabilities));
 	caps->x_resolution = EPD_PANEL_WIDTH;
 	caps->y_resolution = EPD_PANEL_HEIGHT -
 			     EPD_PANEL_HEIGHT % EPD_PANEL_NUMOF_ROWS_PER_PAGE;
@@ -418,7 +418,7 @@ static int ssd16xx_clear_cntlr_mem(const
 	}
 
 
-	memset(clear_page, 0xff, sizeof(clear_page));
+	(void) memset(clear_page, 0xff, sizeof(clear_page));
 	for (int i = 0; i < panel_h; i++) {
 		if (ssd16xx_write_cmd(driver, ram_cmd, clear_page,
 				      sizeof(clear_page))) {
diff -u -p a/drivers/display/display_mcux_elcdif.c b/drivers/display/display_mcux_elcdif.c
--- a/drivers/display/display_mcux_elcdif.c
+++ b/drivers/display/display_mcux_elcdif.c
@@ -61,15 +61,15 @@ static int mcux_elcdif_write(const struc
 
 	k_sem_take(&data->sem, K_FOREVER);
 
-	memcpy(data->fb[write_idx].data, data->fb[read_idx].data,
-	       data->fb_bytes);
+	(void) memcpy(data->fb[write_idx].data, data->fb[read_idx].data,
+			data->fb_bytes);
 
 	src = buf;
 	dst = data->fb[data->write_idx].data;
 	dst += data->pixel_bytes * (y * config->rgb_mode.panelWidth + x);
 
 	for (h_idx = 0; h_idx < desc->height; h_idx++) {
-		memcpy(dst, src, data->pixel_bytes * desc->width);
+		(void) memcpy(dst, src, data->pixel_bytes * desc->width);
 		src += data->pixel_bytes * desc->pitch;
 		dst += data->pixel_bytes * config->rgb_mode.panelWidth;
 	}
@@ -156,7 +156,7 @@ static void mcux_elcdif_get_capabilities
 {
 	const struct mcux_elcdif_config *config = dev->config;
 
-	memset(capabilities, 0, sizeof(struct display_capabilities));
+	(void) memset(capabilities, 0, sizeof(struct display_capabilities));
 	capabilities->x_resolution = config->rgb_mode.panelWidth;
 	capabilities->y_resolution = config->rgb_mode.panelHeight;
 	capabilities->supported_pixel_formats = config->pixel_format;
@@ -195,7 +195,7 @@ static int mcux_elcdif_init(const struct
 			LOG_ERR("Could not allocate frame buffer %d", i);
 			return -ENOMEM;
 		}
-		memset(data->fb[i].data, 0, data->fb_bytes);
+		(void) memset(data->fb[i].data, 0, data->fb_bytes);
 	}
 	rgb_mode.bufferAddr = (uint32_t) data->fb[0].data;
 
diff -u -p a/drivers/lora/sx12xx_common.c b/drivers/lora/sx12xx_common.c
--- a/drivers/lora/sx12xx_common.c
+++ b/drivers/lora/sx12xx_common.c
@@ -98,7 +98,7 @@ int sx12xx_lora_recv(const struct device
 	 * overwritten inbetween when a new packet comes in. Use some
 	 * wise method to fix this!
 	 */
-	memcpy(data, dev_data.rx_buf, dev_data.rx_len);
+	(void) memcpy(data, dev_data.rx_buf, dev_data.rx_len);
 
 	if (rssi != NULL) {
 		*rssi = dev_data.rssi;
diff -u -p a/drivers/i2s/i2s_cavs.c b/drivers/i2s/i2s_cavs.c
--- a/drivers/i2s/i2s_cavs.c
+++ b/drivers/i2s/i2s_cavs.c
@@ -363,7 +363,7 @@ static int i2s_cavs_configure(const stru
 		return -ENOTSUP;
 	}
 
-	memcpy(&dev_data->cfg, i2s_cfg, sizeof(struct i2s_config));
+	(void) memcpy(&dev_data->cfg, i2s_cfg, sizeof(struct i2s_config));
 
 	/* reset SSP settings */
 	/* sscr0 dynamic settings are DSS, EDSS, SCR, FRDC, ECS */
diff -u -p a/drivers/pcie/endpoint/pcie_ep_common.c b/drivers/pcie/endpoint/pcie_ep_common.c
--- a/drivers/pcie/endpoint/pcie_ep_common.c
+++ b/drivers/pcie/endpoint/pcie_ep_common.c
@@ -22,11 +22,11 @@ static int pcie_ep_mapped_copy(uint64_t 
 	}
 
 	if (dir == DEVICE_TO_HOST) {
-		memcpy(UINT_TO_POINTER(mapped_addr),
-		       UINT_TO_POINTER(local_addr), size);
+		(void) memcpy(UINT_TO_POINTER(mapped_addr),
+				UINT_TO_POINTER(local_addr), size);
 	} else {
-		memcpy(UINT_TO_POINTER(local_addr),
-		       UINT_TO_POINTER(mapped_addr), size);
+		(void) memcpy(UINT_TO_POINTER(local_addr),
+				UINT_TO_POINTER(mapped_addr), size);
 	}
 
 	return 0;
diff -u -p a/drivers/console/ipm_console.c b/drivers/console/ipm_console.c
--- a/drivers/console/ipm_console.c
+++ b/drivers/console/ipm_console.c
@@ -30,7 +30,7 @@ static int console_out(int c)
 		LOG_ERR("Error sending character %c over IPM, ret %d", c, ret);
 	}
 
-	memset(buf, 0, sizeof(buf));
+	(void) memset(buf, 0, sizeof(buf));
 	len = 0;
 
 	/* After buffer is full start a new one */
diff -u -p a/soc/arm/nxp_lpc/lpc54xxx/soc.c b/soc/arm/nxp_lpc/lpc54xxx/soc.c
--- a/soc/arm/nxp_lpc/lpc54xxx/soc.c
+++ b/soc/arm/nxp_lpc/lpc54xxx/soc.c
@@ -155,7 +155,7 @@ int _slave_init(const struct device *arg
 	SYSCON->AHBCLKCTRLSET[0] = SYSCON_AHBCLKCTRL_SRAM2_MASK;
 
 	/* Copy second core image to SRAM */
-	memcpy(CORE_M0_BOOT_ADDRESS, (void *)core_m0, sizeof(core_m0));
+	(void) memcpy(CORE_M0_BOOT_ADDRESS, (void *)core_m0, sizeof(core_m0));
 
 	/* Setup the reset handler pointer (PC) and stack pointer value.
 	 * This is used once the second core runs its startup code.
diff -u -p a/subsys/settings/src/settings_runtime.c b/subsys/settings/src/settings_runtime.c
--- a/subsys/settings/src/settings_runtime.c
+++ b/subsys/settings/src/settings_runtime.c
@@ -19,7 +19,7 @@ static ssize_t settings_runtime_read_cb(
 {
 	struct read_cb_arg *arg = (struct read_cb_arg *)cb_arg;
 
-	memcpy(data, arg->data, MIN(arg->len, len));
+	(void) memcpy(data, arg->data, MIN(arg->len, len));
 	return MIN(arg->len, len);
 }
 
diff -u -p a/subsys/mgmt/hawkbit/hawkbit_device.c b/subsys/mgmt/hawkbit/hawkbit_device.c
--- a/subsys/mgmt/hawkbit/hawkbit_device.c
+++ b/subsys/mgmt/hawkbit/hawkbit_device.c
@@ -16,7 +16,7 @@ bool hawkbit_get_device_identity(char *i
 		return false;
 	}
 
-	memset(id, 0, id_max_len);
+	(void) memset(id, 0, id_max_len);
 	length = bin2hex(hwinfo_id, length, id, id_max_len - 1);
 
 	return length > 0;
diff -u -p a/subsys/mgmt/mcumgr/smp.c b/subsys/mgmt/mcumgr/smp.c
--- a/subsys/mgmt/mcumgr/smp.c
+++ b/subsys/mgmt/mcumgr/smp.c
@@ -49,9 +49,9 @@ zephyr_smp_alloc_rsp(const void *req, vo
 		zst->zst_ud_copy(rsp_nb, req_nb);
 	} else {
 		pool = net_buf_pool_get(req_nb->pool_id);
-		memcpy(net_buf_user_data(rsp_nb),
-		       net_buf_user_data((void *)req_nb),
-		       sizeof(req_nb->user_data));
+		(void) memcpy(net_buf_user_data(rsp_nb),
+				net_buf_user_data((void *)req_nb),
+				sizeof(req_nb->user_data));
 	}
 
 	return rsp_nb;
@@ -152,7 +152,7 @@ zephyr_smp_write_at(struct cbor_encoder_
 		return MGMT_ERR_EINVAL;
 	}
 
-	memcpy(nb->data + offset, data, len);
+	(void) memcpy(nb->data + offset, data, len);
 	if (nb->len < offset + len) {
 		nb->len = offset + len;
 		writer->bytes_written = nb->len;
diff -u -p a/subsys/mgmt/ec_host_cmd/ec_host_cmd_handler.c b/subsys/mgmt/ec_host_cmd/ec_host_cmd_handler.c
--- a/subsys/mgmt/ec_host_cmd/ec_host_cmd_handler.c
+++ b/subsys/mgmt/ec_host_cmd/ec_host_cmd_handler.c
@@ -130,9 +130,9 @@ static void handle_host_cmds_entry(void 
 		 * command to ensure subsequent host command handlers cannot
 		 * read data from previous host command runs.
 		 */
-		memset(&rx.buf[rx_valid_data_size], 0,
-		       *rx.len - rx_valid_data_size);
-		memset(tx_buffer, 0, sizeof(tx_buffer));
+		(void) memset(&rx.buf[rx_valid_data_size], 0,
+				*rx.len - rx_valid_data_size);
+		(void) memset(tx_buffer, 0, sizeof(tx_buffer));
 
 		struct ec_host_cmd_handler_args args = {
 			.input_buf = rx.buf + RX_HEADER_SIZE,
diff -u -p a/subsys/net/hostname.c b/subsys/net/hostname.c
--- a/subsys/net/hostname.c
+++ b/subsys/net/hostname.c
@@ -64,7 +64,7 @@ int net_hostname_set_postfix(const uint8
 
 void net_hostname_init(void)
 {
-	memcpy(hostname, CONFIG_NET_HOSTNAME, sizeof(CONFIG_NET_HOSTNAME) - 1);
+	(void) memcpy(hostname, CONFIG_NET_HOSTNAME, sizeof(CONFIG_NET_HOSTNAME) - 1);
 
 	NET_DBG("Hostname set to %s", hostname);
 }
diff -u -p a/subsys/net/l2/ieee802154/ieee802154_frame.c b/subsys/net/l2/ieee802154/ieee802154_frame.c
--- a/subsys/net/l2/ieee802154/ieee802154_frame.c
+++ b/subsys/net/l2/ieee802154/ieee802154_frame.c
@@ -666,8 +666,8 @@ uint8_t *generate_addressing_fields(stru
 		src_addr->short_addr = sys_cpu_to_le16(params->short_addr);
 		p_buf += IEEE802154_SHORT_ADDR_LENGTH;
 	} else {
-		memcpy(src_addr->ext_addr, ctx->ext_addr,
-		       IEEE802154_EXT_ADDR_LENGTH);
+		(void) memcpy(src_addr->ext_addr, ctx->ext_addr,
+				IEEE802154_EXT_ADDR_LENGTH);
 		p_buf += IEEE802154_EXT_ADDR_LENGTH;
 	}
 
diff -u -p a/subsys/net/l2/ppp/lcp.c b/subsys/net/l2/ppp/lcp.c
--- a/subsys/net/l2/ppp/lcp.c
+++ b/subsys/net/l2/ppp/lcp.c
@@ -169,8 +169,8 @@ static void lcp_down(struct ppp_fsm *fsm
 	struct ppp_context *ctx = CONTAINER_OF(fsm, struct ppp_context,
 					       lcp.fsm);
 
-	memset(&ctx->lcp.peer_options.auth_proto, 0,
-	       sizeof(ctx->lcp.peer_options.auth_proto));
+	(void) memset(&ctx->lcp.peer_options.auth_proto, 0,
+			sizeof(ctx->lcp.peer_options.auth_proto));
 
 	ppp_link_down(ctx);
 
@@ -208,7 +208,7 @@ static void lcp_init(struct ppp_context 
 	NET_DBG("proto %s (0x%04x) fsm %p", ppp_proto2str(PPP_LCP), PPP_LCP,
 		&ctx->lcp.fsm);
 
-	memset(&ctx->lcp.fsm, 0, sizeof(ctx->lcp.fsm));
+	(void) memset(&ctx->lcp.fsm, 0, sizeof(ctx->lcp.fsm));
 
 	ppp_fsm_init(&ctx->lcp.fsm, PPP_LCP);
 
diff -u -p a/subsys/net/l2/ppp/ipcp.c b/subsys/net/l2/ppp/ipcp.c
--- a/subsys/net/l2/ppp/ipcp.c
+++ b/subsys/net/l2/ppp/ipcp.c
@@ -213,7 +213,7 @@ static int ipcp_config_info_req(struct p
 	 *   - check that the IP address can be accepted
 	 */
 
-	memcpy(&ctx->ipcp.peer_options.address, &data.addr, sizeof(data.addr));
+	(void) memcpy(&ctx->ipcp.peer_options.address, &data.addr, sizeof(data.addr));
 
 	return PPP_CONFIGURE_ACK;
 }
@@ -353,12 +353,12 @@ static void ipcp_down(struct ppp_fsm *fs
 		net_if_ipv4_addr_rm(ctx->iface, &ctx->ipcp.my_options.address);
 	}
 
-	memset(&ctx->ipcp.my_options.address, 0,
-	       sizeof(ctx->ipcp.my_options.address));
-	memset(&ctx->ipcp.my_options.dns1_address, 0,
-	       sizeof(ctx->ipcp.my_options.dns1_address));
-	memset(&ctx->ipcp.my_options.dns2_address, 0,
-	       sizeof(ctx->ipcp.my_options.dns2_address));
+	(void) memset(&ctx->ipcp.my_options.address, 0,
+			sizeof(ctx->ipcp.my_options.address));
+	(void) memset(&ctx->ipcp.my_options.dns1_address, 0,
+			sizeof(ctx->ipcp.my_options.dns1_address));
+	(void) memset(&ctx->ipcp.my_options.dns2_address, 0,
+			sizeof(ctx->ipcp.my_options.dns2_address));
 
 	if (!ctx->is_ipcp_up) {
 		return;
@@ -393,7 +393,7 @@ static void ipcp_init(struct ppp_context
 	NET_DBG("proto %s (0x%04x) fsm %p", ppp_proto2str(PPP_IPCP), PPP_IPCP,
 		&ctx->ipcp.fsm);
 
-	memset(&ctx->ipcp.fsm, 0, sizeof(ctx->ipcp.fsm));
+	(void) memset(&ctx->ipcp.fsm, 0, sizeof(ctx->ipcp.fsm));
 
 	ppp_fsm_init(&ctx->ipcp.fsm, PPP_IPCP);
 
diff -u -p a/subsys/net/l2/ethernet/gptp/gptp_messages.c b/subsys/net/l2/ethernet/gptp/gptp_messages.c
--- a/subsys/net/l2/ethernet/gptp/gptp_messages.c
+++ b/subsys/net/l2/ethernet/gptp/gptp_messages.c
@@ -332,8 +332,8 @@ struct net_pkt *gptp_prepare_pdelay_req(
 	hdr->reserved1 = 0U;
 	hdr->reserved2 = 0U;
 
-	memcpy(hdr->port_id.clk_id,
-	       port_ds->port_id.clk_id, GPTP_CLOCK_ID_LEN);
+	(void) memcpy(hdr->port_id.clk_id,
+			port_ds->port_id.clk_id, GPTP_CLOCK_ID_LEN);
 
 	/* PTP configuration. */
 	(void)memset(&req->reserved1, 0, sizeof(req->reserved1));
@@ -392,16 +392,16 @@ struct net_pkt *gptp_prepare_pdelay_resp
 	hdr->reserved1 = 0U;
 	hdr->reserved2 = 0U;
 
-	memcpy(hdr->port_id.clk_id, port_ds->port_id.clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(hdr->port_id.clk_id, port_ds->port_id.clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	/* PTP configuration. */
 	pdelay_resp->req_receipt_ts_secs_high = 0U;
 	pdelay_resp->req_receipt_ts_secs_low = 0U;
 	pdelay_resp->req_receipt_ts_nsecs = 0U;
 
-	memcpy(&pdelay_resp->requesting_port_id,
-	       &query->port_id, sizeof(struct gptp_port_identity));
+	(void) memcpy(&pdelay_resp->requesting_port_id,
+			&query->port_id, sizeof(struct gptp_port_identity));
 
 	return pkt;
 }
@@ -454,17 +454,17 @@ struct net_pkt *gptp_prepare_pdelay_foll
 	hdr->reserved1 = 0U;
 	hdr->reserved2 = 0U;
 
-	memcpy(hdr->port_id.clk_id, port_ds->port_id.clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(hdr->port_id.clk_id, port_ds->port_id.clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	/* PTP configuration. */
 	follow_up->resp_orig_ts_secs_high = 0U;
 	follow_up->resp_orig_ts_secs_low = 0U;
 	follow_up->resp_orig_ts_nsecs = 0U;
 
-	memcpy(&follow_up->requesting_port_id,
-	       &pdelay_resp->requesting_port_id,
-	       sizeof(struct gptp_port_identity));
+	(void) memcpy(&follow_up->requesting_port_id,
+			&pdelay_resp->requesting_port_id,
+			sizeof(struct gptp_port_identity));
 
 	return pkt;
 }
@@ -512,8 +512,8 @@ struct net_pkt *gptp_prepare_announce(in
 	hdr->flags.octets[1] =
 		global_ds->global_flags.octets[1] | GPTP_FLAG_PTP_TIMESCALE;
 
-	memcpy(hdr->port_id.clk_id, GPTP_DEFAULT_DS()->clk_id,
-	       GPTP_CLOCK_ID_LEN);
+	(void) memcpy(hdr->port_id.clk_id, GPTP_DEFAULT_DS()->clk_id,
+			GPTP_CLOCK_ID_LEN);
 
 	hdr->port_id.port_number = htons(port);
 	hdr->control = GPTP_OTHER_CONTROL_VALUE;
@@ -532,19 +532,19 @@ struct net_pkt *gptp_prepare_announce(in
 		ann->root_system_id.grand_master_prio1 = default_ds->priority1;
 		ann->root_system_id.grand_master_prio2 = default_ds->priority2;
 
-		memcpy(&ann->root_system_id.clk_quality,
-		       &default_ds->clk_quality,
-		       sizeof(struct gptp_clock_quality));
-
-		memcpy(&ann->root_system_id.grand_master_id,
-		       default_ds->clk_id,
-		       GPTP_CLOCK_ID_LEN);
+		(void) memcpy(&ann->root_system_id.clk_quality,
+				&default_ds->clk_quality,
+				sizeof(struct gptp_clock_quality));
+
+		(void) memcpy(&ann->root_system_id.grand_master_id,
+				default_ds->clk_id,
+				GPTP_CLOCK_ID_LEN);
 		break;
 	case GPTP_INFO_IS_RECEIVED:
-		memcpy(&ann->root_system_id,
-		       &GPTP_PORT_BMCA_DATA(port)->
+		(void) memcpy(&ann->root_system_id,
+				&GPTP_PORT_BMCA_DATA(port)->
 				master_priority.root_system_id,
-		       sizeof(struct gptp_root_system_identity));
+				sizeof(struct gptp_root_system_identity));
 		break;
 	default:
 		goto fail;
diff -u -p a/subsys/net/l2/ethernet/ethernet_stats.c b/subsys/net/l2/ethernet/ethernet_stats.c
--- a/subsys/net/l2/ethernet/ethernet_stats.c
+++ b/subsys/net/l2/ethernet/ethernet_stats.c
@@ -44,7 +44,7 @@ static int eth_stats_get(uint32_t mgmt_r
 		return -EINVAL;
 	}
 
-	memcpy(data, src, len);
+	(void) memcpy(data, src, len);
 
 	return 0;
 }
diff -u -p a/subsys/net/l2/bluetooth/bluetooth.c b/subsys/net/l2/bluetooth/bluetooth.c
--- a/subsys/net/l2/bluetooth/bluetooth.c
+++ b/subsys/net/l2/bluetooth/bluetooth.c
@@ -414,7 +414,7 @@ static bool eir_found(uint8_t type, cons
 		struct bt_uuid *uuid;
 		uint16_t u16;
 
-		memcpy(&u16, &data[i], sizeof(u16));
+		(void) memcpy(&u16, &data[i], sizeof(u16));
 		uuid = BT_UUID_DECLARE_16(sys_le16_to_cpu(u16));
 		if (bt_uuid_cmp(uuid, BT_UUID_IPSS)) {
 			continue;
diff -u -p a/subsys/net/lib/sockets/sockets_net_mgmt.c b/subsys/net/lib/sockets/sockets_net_mgmt.c
--- a/subsys/net/lib/sockets/sockets_net_mgmt.c
+++ b/subsys/net/lib/sockets/sockets_net_mgmt.c
@@ -206,7 +206,7 @@ again:
 	if (info) {
 		ret = info_len + sizeof(hdr);
 		ret = MIN(max_len, ret);
-		memcpy(&copy_to[sizeof(hdr)], info, ret);
+		(void) memcpy(&copy_to[sizeof(hdr)], info, ret);
 	} else {
 		ret = 0;
 	}
@@ -214,7 +214,7 @@ again:
 	hdr.nm_msg_version = NET_MGMT_SOCKET_VERSION_1;
 	hdr.nm_msg_len = ret;
 
-	memcpy(copy_to, &hdr, sizeof(hdr));
+	(void) memcpy(copy_to, &hdr, sizeof(hdr));
 
 	return ret;
 }
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_util.c b/subsys/net/lib/lwm2m/lwm2m_util.c
--- a/subsys/net/lib/lwm2m/lwm2m_util.c
+++ b/subsys/net/lib/lwm2m/lwm2m_util.c
@@ -23,7 +23,7 @@ int lwm2m_f32_to_b32(float32_value_t *f3
 
 	/* handle zero value special case */
 	if (f32->val1 == 0 && f32->val2 == 0) {
-		memset(b32, 0, len);
+		(void) memset(b32, 0, len);
 		return 0;
 	}
 
@@ -68,7 +68,7 @@ int lwm2m_f32_to_b32(float32_value_t *f3
 	/* adjust exponent for bias */
 	e += 127;
 
-	memset(b32, 0, len);
+	(void) memset(b32, 0, len);
 
 	/* sign: bit 31 */
 	if (f32->val1 == 0) {
@@ -103,7 +103,7 @@ int lwm2m_f64_to_b64(float64_value_t *f6
 
 	/* handle zero value special case */
 	if (f64->val1 == 0LL && f64->val2 == 0LL) {
-		memset(b64, 0, len);
+		(void) memset(b64, 0, len);
 		return 0;
 	}
 
@@ -148,7 +148,7 @@ int lwm2m_f64_to_b64(float64_value_t *f6
 	/* adjust exponent for bias */
 	e += 1023;
 
-	memset(b64, 0, len);
+	(void) memset(b64, 0, len);
 
 	/* sign: bit 63 */
 	if (f64->val1 == 0) {
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_rd_client.c b/subsys/net/lib/lwm2m/lwm2m_rd_client.c
--- a/subsys/net/lib/lwm2m/lwm2m_rd_client.c
+++ b/subsys/net/lib/lwm2m/lwm2m_rd_client.c
@@ -295,8 +295,8 @@ static int do_registration_reply_cb(cons
 			return -EINVAL;
 		}
 
-		memcpy(client.server_ep, options[1].value,
-		       options[1].len);
+		(void) memcpy(client.server_ep, options[1].value,
+				options[1].len);
 		client.server_ep[options[1].len] = '\0';
 		set_sm_state(ENGINE_REGISTRATION_DONE);
 		LOG_INF("Registration Done (EP='%s')",
diff -u -p a/subsys/net/lib/mqtt/mqtt.c b/subsys/net/lib/mqtt/mqtt.c
--- a/subsys/net/lib/mqtt/mqtt.c
+++ b/subsys/net/lib/mqtt/mqtt.c
@@ -30,7 +30,7 @@ static void client_reset(struct mqtt_cli
 /** @brief Initialize tx buffer. */
 static void tx_buf_init(struct mqtt_client *client, struct buf_ctx *buf)
 {
-	memset(client->tx_buf, 0, client->tx_buf_size);
+	(void) memset(client->tx_buf, 0, client->tx_buf_size);
 	buf->cur = client->tx_buf;
 	buf->end = client->tx_buf + client->tx_buf_size;
 }
@@ -171,7 +171,7 @@ void mqtt_client_init(struct mqtt_client
 {
 	NULL_PARAM_CHECK_VOID(client);
 
-	memset(client, 0, sizeof(*client));
+	(void) memset(client, 0, sizeof(*client));
 
 	MQTT_STATE_INIT(client);
 	mqtt_mutex_init(client);
@@ -192,7 +192,7 @@ int mqtt_client_set_proxy(struct mqtt_cl
 		}
 
 		client->transport.proxy.addrlen = addrlen;
-		memcpy(&client->transport.proxy.addr, proxy_addr, addrlen);
+		(void) memcpy(&client->transport.proxy.addr, proxy_addr, addrlen);
 
 		return 0;
 	}
@@ -271,7 +271,7 @@ int mqtt_publish(struct mqtt_client *cli
 	io_vector[1].iov_base = param->message.payload.data;
 	io_vector[1].iov_len = param->message.payload.len;
 
-	memset(&msg, 0, sizeof(msg));
+	(void) memset(&msg, 0, sizeof(msg));
 
 	msg.msg_iov = io_vector;
 	msg.msg_iovlen = ARRAY_SIZE(io_vector);
diff -u -p a/subsys/net/lib/dns/llmnr_responder.c b/subsys/net/lib/dns/llmnr_responder.c
--- a/subsys/net/lib/dns/llmnr_responder.c
+++ b/subsys/net/lib/dns/llmnr_responder.c
@@ -202,7 +202,7 @@ static int add_answer(struct net_buf *qu
 	const uint16_t q_len = query->len + 1 + DNS_QTYPE_LEN + DNS_QCLASS_LEN;
 	uint16_t offset = DNS_MSG_HEADER_SIZE + q_len;
 
-	memcpy(query->data + offset, query->data + DNS_MSG_HEADER_SIZE, q_len);
+	(void) memcpy(query->data + offset, query->data + DNS_MSG_HEADER_SIZE, q_len);
 	offset += q_len;
 
 	UNALIGNED_PUT(htonl(ttl), query->data + offset);
@@ -211,7 +211,7 @@ static int add_answer(struct net_buf *qu
 	UNALIGNED_PUT(htons(addr_len), query->data + offset);
 	offset += DNS_RDLENGTH_LEN;
 
-	memcpy(query->data + offset, addr, addr_len);
+	(void) memcpy(query->data + offset, addr, addr_len);
 
 	return offset + addr_len;
 }
diff -u -p a/subsys/net/lib/coap/coap_link_format.c b/subsys/net/lib/coap/coap_link_format.c
--- a/subsys/net/lib/coap/coap_link_format.c
+++ b/subsys/net/lib/coap/coap_link_format.c
@@ -62,7 +62,7 @@ static inline bool append(struct coap_pa
 		return false;
 	}
 
-	memcpy(cpkt->data + cpkt->offset, data, len);
+	(void) memcpy(cpkt->data + cpkt->offset, data, len);
 	cpkt->offset += len;
 
 	return true;
diff -u -p a/subsys/net/ip/tp.c b/subsys/net/ip/tp.c
--- a/subsys/net/ip/tp.c
+++ b/subsys/net/ip/tp.c
@@ -118,7 +118,7 @@ void tp_free(void *ptr, const char *file
 				file, line, func, ptr);
 	}
 
-	memset(mem, 0, sizeof(tp_mem) + mem->size + sizeof(*mem->footer));
+	(void) memset(mem, 0, sizeof(tp_mem) + mem->size + sizeof(*mem->footer));
 	k_free(mem);
 }
 
@@ -128,7 +128,7 @@ void *tp_calloc(size_t nmemb, size_t siz
 	size_t bytes = size * nmemb;
 	void *ptr = tp_malloc(bytes, file, line, func);
 
-	memset(ptr, 0, bytes);
+	(void) memset(ptr, 0, bytes);
 
 	return ptr;
 }
@@ -463,7 +463,7 @@ struct tp *json_to_tp(void *data, size_t
 {
 	static struct tp tp;
 
-	memset(&tp, 0, sizeof(tp));
+	(void) memset(&tp, 0, sizeof(tp));
 
 	if (json_obj_parse(data, data_len, tp_descr, ARRAY_SIZE(tp_descr),
 			&tp) < 0) {
@@ -517,7 +517,7 @@ enum tp_type json_decode_msg(void *data,
 	int decoded;
 	struct tp_msg tp;
 
-	memset(&tp, 0, sizeof(tp));
+	(void) memset(&tp, 0, sizeof(tp));
 
 	decoded = json_obj_parse(data, data_len, tp_msg_dsc,
 					ARRAY_SIZE(tp_msg_dsc), &tp);
@@ -536,7 +536,7 @@ struct tp_new *json_to_tp_new(void *data
 	static struct tp_new tp;
 	int i;
 
-	memset(&tp, 0, sizeof(tp));
+	(void) memset(&tp, 0, sizeof(tp));
 
 	if (json_obj_parse(data, data_len, tp_new_dsc, ARRAY_SIZE(tp_new_dsc),
 				&tp) < 0) {
diff -u -p a/subsys/net/ip/tcp.c b/subsys/net/ip/tcp.c
--- a/subsys/net/ip/tcp.c
+++ b/subsys/net/ip/tcp.c
@@ -524,7 +524,7 @@ static int prepare_segment(struct net_tc
 		}
 	}
 
-	memset(tcp_hdr, 0, NET_TCPH_LEN);
+	(void) memset(tcp_hdr, 0, NET_TCPH_LEN);
 
 	tcp_hdr->src_port = src_port;
 	tcp_hdr->dst_port = dst_port;
@@ -1749,8 +1749,8 @@ static int tcp_backlog_ack(struct net_pk
 		return -EINVAL;
 	}
 
-	memcpy(&context->remote, &tcp_backlog[r].remote,
-		sizeof(struct sockaddr));
+	(void) memcpy(&context->remote, &tcp_backlog[r].remote,
+			sizeof(struct sockaddr));
 	context->tcp->send_seq = tcp_backlog[r].send_seq + 1;
 	context->tcp->send_ack = tcp_backlog[r].send_ack;
 	context->tcp->send_mss = tcp_backlog[r].send_mss;
@@ -2558,8 +2558,8 @@ NET_CONN_CB(tcp_syn_rcvd)
 
 		new_context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
 
-		memcpy(&new_context->remote, &remote_addr,
-		       sizeof(remote_addr));
+		(void) memcpy(&new_context->remote, &remote_addr,
+				sizeof(remote_addr));
 
 		ret = net_tcp_register(net_pkt_family(pkt),
 			       &new_context->remote,
diff -u -p a/subsys/net/ip/ipv6_nbr.c b/subsys/net/ip/ipv6_nbr.c
--- a/subsys/net/ip/ipv6_nbr.c
+++ b/subsys/net/ip/ipv6_nbr.c
@@ -1080,7 +1080,7 @@ int net_ipv6_send_na(struct net_if *ifac
 	}
 
 	/* Let's make sure reserved part is full of 0 */
-	memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
+	(void) memset(na_hdr, 0, sizeof(struct net_icmpv6_na_hdr));
 
 	na_hdr->flags = flags;
 	net_ipaddr_copy(&na_hdr->tgt, tgt);
@@ -2156,7 +2156,7 @@ static inline void handle_prefix_autonom
 	 */
 	net_ipv6_addr_create_iid(&addr,
 				 net_if_get_link_addr(net_pkt_iface(pkt)));
-	memcpy(&addr, &prefix_info->prefix, sizeof(struct in6_addr) / 2);
+	(void) memcpy(&addr, &prefix_info->prefix, sizeof(struct in6_addr) / 2);
 
 	ifaddr = net_if_ipv6_addr_lookup(&addr, NULL);
 	if (ifaddr && ifaddr->addr_type == NET_ADDR_AUTOCONF) {
diff -u -p a/subsys/net/ip/net_mgmt.c b/subsys/net/ip/net_mgmt.c
--- a/subsys/net/ip/net_mgmt.c
+++ b/subsys/net/ip/net_mgmt.c
@@ -64,7 +64,7 @@ static inline void mgmt_push_event(uint3
 #ifdef CONFIG_NET_MGMT_EVENT_INFO
 	if (info && length) {
 		if (length <= NET_EVENT_INFO_MAX_SIZE) {
-			memcpy(events[i_idx].info, info, length);
+			(void) memcpy(events[i_idx].info, info, length);
 			events[i_idx].info_length = length;
 		} else {
 			NET_ERR("Event info length %zu > max size %zu",
diff -u -p a/subsys/shell/shell_dummy.c b/subsys/shell/shell_dummy.c
--- a/subsys/shell/shell_dummy.c
+++ b/subsys/shell/shell_dummy.c
@@ -68,7 +68,7 @@ static int write(const struct shell_tran
 	if (sh_dummy->len + store_cnt >= sizeof(sh_dummy->buf)) {
 		store_cnt = sizeof(sh_dummy->buf) - sh_dummy->len - 1;
 	}
-	memcpy(sh_dummy->buf + sh_dummy->len, data, store_cnt);
+	(void) memcpy(sh_dummy->buf + sh_dummy->len, data, store_cnt);
 	sh_dummy->len += store_cnt;
 
 	*cnt = length;
diff -u -p a/subsys/shell/shell_ops.c b/subsys/shell/shell_ops.c
--- a/subsys/shell/shell_ops.c
+++ b/subsys/shell/shell_ops.c
@@ -246,7 +246,7 @@ static void data_insert(const struct she
 	}
 
 	memmove(curr_pos + len, curr_pos, after);
-	memcpy(curr_pos, data, len);
+	(void) memcpy(curr_pos, data, len);
 	shell->ctx->cmd_buff_len += len;
 	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
 
diff -u -p a/subsys/storage/stream/stream_flash.c b/subsys/storage/stream/stream_flash.c
--- a/subsys/storage/stream/stream_flash.c
+++ b/subsys/storage/stream/stream_flash.c
@@ -125,8 +125,8 @@ int stream_flash_buffered_write(struct s
 
 	while ((len - processed) >=
 	       (buf_empty_bytes = ctx->buf_len - ctx->buf_bytes)) {
-		memcpy(ctx->buf + ctx->buf_bytes, data + processed,
-		       buf_empty_bytes);
+		(void) memcpy(ctx->buf + ctx->buf_bytes, data + processed,
+				buf_empty_bytes);
 
 		ctx->buf_bytes = ctx->buf_len;
 		rc = flash_sync(ctx);
@@ -140,8 +140,8 @@ int stream_flash_buffered_write(struct s
 
 	/* place rest of the data into ctx->buf */
 	if (processed < len) {
-		memcpy(ctx->buf + ctx->buf_bytes,
-		       data + processed, len - processed);
+		(void) memcpy(ctx->buf + ctx->buf_bytes,
+				data + processed, len - processed);
 		ctx->buf_bytes += len - processed;
 	}
 
@@ -163,7 +163,7 @@ int stream_flash_buffered_write(struct s
 				return rc;
 			}
 
-			memset(ctx->buf + ctx->buf_bytes, filler, fill_length);
+			(void) memset(ctx->buf + ctx->buf_bytes, filler, fill_length);
 			ctx->buf_bytes += fill_length;
 		} else {
 			fill_length = 0;
diff -u -p a/subsys/usb/class/mass_storage.c b/subsys/usb/class/mass_storage.c
--- a/subsys/usb/class/mass_storage.c
+++ b/subsys/usb/class/mass_storage.c
@@ -510,7 +510,7 @@ static void CBWDecode(uint8_t *buf, uint
 		return;
 	}
 
-	memcpy((uint8_t *)&cbw, buf, size);
+	(void) memcpy((uint8_t *)&cbw, buf, size);
 	if (cbw.Signature != CBW_Signature) {
 		LOG_ERR("CBW Signature Mismatch");
 		return;
diff -u -p a/subsys/canbus/isotp/isotp.c b/subsys/canbus/isotp/isotp.c
--- a/subsys/canbus/isotp/isotp.c
+++ b/subsys/canbus/isotp/isotp.c
@@ -851,7 +851,7 @@ static inline int send_sf(struct isotp_s
 	frame.data[index++] = ISOTP_PCI_TYPE_SF | len;
 
 	__ASSERT_NO_MSG(len <= ISOTP_CAN_DL - index);
-	memcpy(&frame.data[index], data, len);
+	(void) memcpy(&frame.data[index], data, len);
 
 	frame.dlc = len + index;
 
@@ -896,7 +896,7 @@ static inline int send_ff(struct isotp_s
 	ctx->sn = 1;
 	data = get_data_ctx(ctx);
 	pull_data_ctx(ctx, ISOTP_CAN_DL - index);
-	memcpy(&frame.data[index], data, ISOTP_CAN_DL - index);
+	(void) memcpy(&frame.data[index], data, ISOTP_CAN_DL - index);
 
 	ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A),
 		       send_can_tx_isr, ctx);
@@ -928,7 +928,7 @@ static inline int send_cf(struct isotp_s
 	rem_len -= len;
 	frame.dlc = len + index;
 	data = get_data_ctx(ctx);
-	memcpy(&frame.data[index], data, len);
+	(void) memcpy(&frame.data[index], data, len);
 
 	ret = can_send(ctx->can_dev, &frame, K_MSEC(ISOTP_A),
 		       send_can_tx_isr, ctx);
diff -u -p a/subsys/bluetooth/mesh/transport.c b/subsys/bluetooth/mesh/transport.c
--- a/subsys/bluetooth/mesh/transport.c
+++ b/subsys/bluetooth/mesh/transport.c
@@ -528,7 +528,7 @@ static int send_seg(struct bt_mesh_net_t
 		}
 
 		len = MIN(sdu->len, seg_len(!!ctl_op));
-		memcpy(buf, net_buf_simple_pull_mem(sdu, len), len);
+		(void) memcpy(buf, net_buf_simple_pull_mem(sdu, len), len);
 
 		BT_DBG("seg %u: %s", seg_o, bt_hex(buf, len));
 
@@ -1685,7 +1685,7 @@ found_rx:
 		return -ENOBUFS;
 	}
 
-	memcpy(rx->seg[seg_o], buf->data, buf->len);
+	(void) memcpy(rx->seg[seg_o], buf->data, buf->len);
 
 	BT_DBG("Received %u/%u", seg_o, seg_n);
 
diff -u -p a/subsys/bluetooth/mesh/main.c b/subsys/bluetooth/mesh/main.c
--- a/subsys/bluetooth/mesh/main.c
+++ b/subsys/bluetooth/mesh/main.c
@@ -99,7 +99,7 @@ int bt_mesh_provision(const uint8_t net_
 
 		addr = node->addr;
 		iv_index = bt_mesh_cdb.iv_index;
-		memcpy(node->dev_key, dev_key, 16);
+		(void) memcpy(node->dev_key, dev_key, 16);
 
 		if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 			bt_mesh_store_cdb_node(node);
@@ -121,7 +121,7 @@ int bt_mesh_provision(const uint8_t net_
 
 	bt_mesh_comp_provision(addr);
 
-	memcpy(bt_mesh.dev_key, dev_key, 16);
+	(void) memcpy(bt_mesh.dev_key, dev_key, 16);
 
 	if (IS_ENABLED(CONFIG_BT_MESH_LOW_POWER) &&
 	    IS_ENABLED(CONFIG_BT_MESH_LPN_SUB_ALL_NODES_ADDR)) {
@@ -169,7 +169,7 @@ void bt_mesh_reset(void)
 	bt_mesh.iv_index = 0U;
 	bt_mesh.seq = 0U;
 
-	memset(bt_mesh.flags, 0, sizeof(bt_mesh.flags));
+	(void) memset(bt_mesh.flags, 0, sizeof(bt_mesh.flags));
 
 	k_delayed_work_cancel(&bt_mesh.ivu_timer);
 
diff -u -p a/subsys/bluetooth/mesh/net.c b/subsys/bluetooth/mesh/net.c
--- a/subsys/bluetooth/mesh/net.c
+++ b/subsys/bluetooth/mesh/net.c
@@ -170,7 +170,7 @@ int bt_mesh_net_keys_create(struct bt_me
 		return err;
 	}
 
-	memcpy(keys->net, key, 16);
+	(void) memcpy(keys->net, key, 16);
 
 	keys->nid = nid;
 
@@ -258,8 +258,8 @@ void friend_cred_refresh(uint16_t net_id
 
 		if (cred->addr != BT_MESH_ADDR_UNASSIGNED &&
 		    cred->net_idx == net_idx) {
-			memcpy(&cred->cred[0], &cred->cred[1],
-			       sizeof(cred->cred[0]));
+			(void) memcpy(&cred->cred[0], &cred->cred[1],
+					sizeof(cred->cred[0]));
 		}
 	}
 }
@@ -486,7 +486,7 @@ void bt_mesh_net_revoke_keys(struct bt_m
 
 	BT_DBG("idx 0x%04x", sub->net_idx);
 
-	memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
+	(void) memcpy(&sub->keys[0], &sub->keys[1], sizeof(sub->keys[0]));
 	if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 		BT_DBG("Storing Updated NetKey persistently");
 		bt_mesh_store_subnet(sub);
@@ -499,7 +499,7 @@ void bt_mesh_net_revoke_keys(struct bt_m
 			continue;
 		}
 
-		memcpy(&key->keys[0], &key->keys[1], sizeof(key->keys[0]));
+		(void) memcpy(&key->keys[0], &key->keys[1], sizeof(key->keys[0]));
 		key->updated = false;
 		if (IS_ENABLED(CONFIG_BT_SETTINGS)) {
 			BT_DBG("Storing Updated AppKey persistently");
@@ -1033,7 +1033,7 @@ static int net_decrypt(struct bt_mesh_su
 	rx->old_iv = (IVI(data) != (bt_mesh.iv_index & 0x01));
 
 	net_buf_simple_reset(buf);
-	memcpy(net_buf_simple_add(buf, data_len), data, data_len);
+	(void) memcpy(net_buf_simple_add(buf, data_len), data, data_len);
 
 	if (bt_mesh_net_obfuscate(buf->data, BT_MESH_NET_IVI_RX(rx), priv)) {
 		return -ENOENT;
diff -u -p a/subsys/bluetooth/mesh/prov.c b/subsys/bluetooth/mesh/prov.c
--- a/subsys/bluetooth/mesh/prov.c
+++ b/subsys/bluetooth/mesh/prov.c
@@ -148,7 +148,7 @@ static int reset_state(void)
 		bt_mesh_cdb_node_del(link.provisioner->node, false);
 	}
 
-	memset(&link, 0, sizeof(link));
+	(void) memset(&link, 0, sizeof(link));
 
 	err = bt_pub_key_gen(&pub_key_cb);
 	if (err) {
@@ -247,7 +247,7 @@ static void prov_invite(const uint8_t *d
 	/* Input OOB Action */
 	net_buf_simple_add_be16(&buf, prov->input_actions);
 
-	memcpy(&link.conf_inputs[1], &buf.data[1], 11);
+	(void) memcpy(&link.conf_inputs[1], &buf.data[1], 11);
 
 	if (prov_send(&buf, NULL)) {
 		BT_ERR("Failed to send capabilities");
@@ -287,12 +287,12 @@ static void send_start(void)
 	net_buf_simple_add_u8(&start, PROV_ALG_P256);
 	net_buf_simple_add_u8(&start, PUB_KEY_NO_OOB);
 	net_buf_simple_add_u8(&start, AUTH_METHOD_NO_OOB);
-	memset(link.auth, 0, sizeof(link.auth));
+	(void) memset(link.auth, 0, sizeof(link.auth));
 
 	net_buf_simple_add_u8(&start, 0); /* Auth Action */
 	net_buf_simple_add_u8(&start, 0); /* Auth Size */
 
-	memcpy(&link.conf_inputs[12], &start.data[1], 5);
+	(void) memcpy(&link.conf_inputs[12], &start.data[1], 5);
 
 	if (prov_send(&start, start_sent)) {
 		BT_ERR("Failed to send start");
@@ -352,7 +352,7 @@ static void prov_capabilities(const uint
 		return;
 	}
 
-	memcpy(&link.conf_inputs[1], data, 11);
+	(void) memcpy(&link.conf_inputs[1], data, 11);
 
 	send_start();
 }
@@ -409,8 +409,8 @@ static int prov_auth(uint8_t method, uin
 			return -EINVAL;
 		}
 
-		memcpy(link.auth + 16 - prov->static_val_len,
-		       prov->static_val, prov->static_val_len);
+		(void) memcpy(link.auth + 16 - prov->static_val_len,
+				prov->static_val, prov->static_val_len);
 		(void)memset(link.auth, 0,
 			     sizeof(link.auth) - prov->static_val_len);
 		return 0;
@@ -448,7 +448,7 @@ static int prov_auth(uint8_t method, uin
 			}
 			str[size] = '\0';
 
-			memcpy(link.auth, str, size);
+			(void) memcpy(link.auth, str, size);
 			(void)memset(link.auth + size, 0,
 				     sizeof(link.auth) - size);
 
@@ -514,7 +514,7 @@ static void prov_start(const uint8_t *da
 		return;
 	}
 
-	memcpy(&link.conf_inputs[12], data, 5);
+	(void) memcpy(&link.conf_inputs[12], data, 5);
 
 	link.expect = PROV_PUB_KEY;
 
@@ -642,10 +642,10 @@ static void send_pub_key(void)
 
 	if (atomic_test_bit(link.flags, PROVISIONER)) {
 		/* PublicKeyProvisioner */
-		memcpy(&link.conf_inputs[17], &buf.data[1], 64);
+		(void) memcpy(&link.conf_inputs[17], &buf.data[1], 64);
 	} else {
 		/* PublicKeyRemote */
-		memcpy(&link.conf_inputs[81], &buf.data[1], 64);
+		(void) memcpy(&link.conf_inputs[81], &buf.data[1], 64);
 	}
 
 	if (prov_send(&buf, NULL)) {
@@ -715,11 +715,11 @@ static void prov_pub_key(const uint8_t *
 
 	if (atomic_test_bit(link.flags, PROVISIONER)) {
 		/* PublicKeyDevice */
-		memcpy(&link.conf_inputs[81], data, 64);
+		(void) memcpy(&link.conf_inputs[81], data, 64);
 		link.bearer->clear_tx();
 	} else {
 		/* PublicKeyProvisioner */
-		memcpy(&link.conf_inputs[17], data, 64);
+		(void) memcpy(&link.conf_inputs[17], data, 64);
 
 		if (!bt_pub_key_get()) {
 			/* Clear retransmit timer */
@@ -931,7 +931,7 @@ static void prov_confirm(const uint8_t *
 {
 	BT_DBG("Remote Confirm: %s", bt_hex(data, 16));
 
-	memcpy(link.conf, data, 16);
+	(void) memcpy(link.conf, data, 16);
 
 	notify_input_complete();
 
@@ -1142,11 +1142,11 @@ int bt_mesh_pb_adv_open(const uint8_t uu
 
 	struct bt_uuid_128 uuid_repr = { .uuid = { BT_UUID_TYPE_128 } };
 
-	memcpy(uuid_repr.val, uuid, 16);
+	(void) memcpy(uuid_repr.val, uuid, 16);
 	BT_DBG("Provisioning %s", bt_uuid_str(&uuid_repr.uuid));
 
 	atomic_set_bit(link.flags, PROVISIONER);
-	memcpy(link.provisioner->uuid, uuid, 16);
+	(void) memcpy(link.provisioner->uuid, uuid, 16);
 	link.provisioner->addr = addr;
 	link.provisioner->net_idx = net_idx;
 	link.provisioner->attention_duration = attention_duration;
@@ -1201,7 +1201,7 @@ int bt_mesh_prov_enable(bt_mesh_prov_bea
 	if (IS_ENABLED(CONFIG_BT_DEBUG)) {
 		struct bt_uuid_128 uuid = { .uuid = { BT_UUID_TYPE_128 } };
 
-		memcpy(uuid.val, prov->uuid, 16);
+		(void) memcpy(uuid.val, prov->uuid, 16);
 		BT_INFO("Device UUID: %s", bt_uuid_str(&uuid.uuid));
 	}
 
diff -u -p a/subsys/bluetooth/host/hci_core.c b/subsys/bluetooth/host/hci_core.c
--- a/subsys/bluetooth/host/hci_core.c
+++ b/subsys/bluetooth/host/hci_core.c
@@ -1563,7 +1563,7 @@ int bt_le_create_conn_legacy(const struc
 	}
 
 	cp = net_buf_add(buf, sizeof(*cp));
-	memset(cp, 0, sizeof(*cp));
+	(void) memset(cp, 0, sizeof(*cp));
 	cp->own_addr_type = own_addr_type;
 
 	if (use_filter) {
@@ -2322,8 +2322,8 @@ static void le_remote_feat_complete(stru
 	}
 
 	if (!evt->status) {
-		memcpy(conn->le.features, evt->features,
-		       sizeof(conn->le.features));
+		(void) memcpy(conn->le.features, evt->features,
+				sizeof(conn->le.features));
 	}
 
 	atomic_set_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH);
@@ -3190,7 +3190,7 @@ static void inquiry_result_with_rssi(str
 		priv->pscan_rep_mode = evt->pscan_rep_mode;
 		priv->clock_offset = evt->clock_offset;
 
-		memcpy(result->cod, evt->cod, 3);
+		(void) memcpy(result->cod, evt->cod, 3);
 		result->rssi = evt->rssi;
 
 		/* we could reuse slot so make sure EIR is cleared */
@@ -3220,8 +3220,8 @@ static void extended_inquiry_result(stru
 	priv->clock_offset = evt->clock_offset;
 
 	result->rssi = evt->rssi;
-	memcpy(result->cod, evt->cod, 3);
-	memcpy(result->eir, evt->eir, sizeof(result->eir));
+	(void) memcpy(result->cod, evt->cod, 3);
+	(void) memcpy(result->eir, evt->eir, sizeof(result->eir));
 }
 
 static void remote_name_request_complete(struct net_buf *buf)
@@ -3269,7 +3269,7 @@ static void remote_name_request_complete
 				eir[1] = EIR_SHORT_NAME;
 			}
 
-			memcpy(&eir[2], evt->name, eir[0] - 1);
+			(void) memcpy(&eir[2], evt->name, eir[0] - 1);
 
 			break;
 		}
@@ -3326,7 +3326,7 @@ static void read_remote_features_complet
 		goto done;
 	}
 
-	memcpy(conn->br.features[0], evt->features, sizeof(evt->features));
+	(void) memcpy(conn->br.features[0], evt->features, sizeof(evt->features));
 
 	if (!BT_FEAT_EXT_FEATURES(conn->br.features)) {
 		goto done;
@@ -3364,8 +3364,8 @@ static void read_remote_ext_features_com
 	}
 
 	if (!evt->status && evt->page == 0x01) {
-		memcpy(conn->br.features[1], evt->features,
-		       sizeof(conn->br.features[1]));
+		(void) memcpy(conn->br.features[1], evt->features,
+				sizeof(conn->br.features[1]));
 	}
 
 	bt_conn_unref(conn);
@@ -3463,10 +3463,10 @@ static int hci_id_add(uint8_t id, const 
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	bt_addr_le_copy(&cp->peer_id_addr, addr);
-	memcpy(cp->peer_irk, peer_irk, 16);
+	(void) memcpy(cp->peer_irk, peer_irk, 16);
 
 #if defined(CONFIG_BT_PRIVACY)
-	memcpy(cp->local_irk, bt_dev.irk[id], 16);
+	(void) memcpy(cp->local_irk, bt_dev.irk[id], 16);
 #else
 	(void)memset(cp->local_irk, 0, 16);
 #endif
@@ -3918,7 +3918,7 @@ static void le_ltk_reply(uint16_t handle
 
 	cp = net_buf_add(buf, sizeof(*cp));
 	cp->handle = sys_cpu_to_le16(handle);
-	memcpy(cp->ltk, ltk, sizeof(cp->ltk));
+	(void) memcpy(cp->ltk, ltk, sizeof(cp->ltk));
 
 	bt_hci_cmd_send(BT_HCI_OP_LE_LTK_REQ_REPLY, buf);
 }
@@ -3961,7 +3961,7 @@ static void le_pkey_complete(struct net_
 	atomic_clear_bit(bt_dev.flags, BT_DEV_PUB_KEY_BUSY);
 
 	if (!evt->status) {
-		memcpy(pub_key, evt->key, 64);
+		(void) memcpy(pub_key, evt->key, 64);
 		atomic_set_bit(bt_dev.flags, BT_DEV_HAS_PUB_KEY);
 	}
 
@@ -5220,7 +5220,7 @@ static void read_le_features_complete(st
 
 	BT_DBG("status 0x%02x", rp->status);
 
-	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
+	(void) memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
 }
 
 #if defined(CONFIG_BT_BREDR)
@@ -5340,8 +5340,8 @@ static void read_supported_commands_comp
 
 	BT_DBG("status 0x%02x", rp->status);
 
-	memcpy(bt_dev.supported_commands, rp->commands,
-	       sizeof(bt_dev.supported_commands));
+	(void) memcpy(bt_dev.supported_commands, rp->commands,
+			sizeof(bt_dev.supported_commands));
 
 	/*
 	 * Report "LE Read Local P-256 Public Key" and "LE Generate DH Key" as
@@ -5359,7 +5359,7 @@ static void read_local_features_complete
 
 	BT_DBG("status 0x%02x", rp->status);
 
-	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
+	(void) memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
 }
 
 static void le_read_supp_states_complete(struct net_buf *buf)
@@ -5717,8 +5717,8 @@ static int read_ext_features(void)
 
 		rp = (void *)rsp->data;
 
-		memcpy(&bt_dev.features[i], rp->ext_features,
-		       sizeof(bt_dev.features[i]));
+		(void) memcpy(&bt_dev.features[i], rp->ext_features,
+				sizeof(bt_dev.features[i]));
 
 		if (rp->max_page <= i) {
 			net_buf_unref(rsp);
@@ -6178,7 +6178,7 @@ static void hci_vs_init(void)
 	}
 
 	rp.cmds = (void *)rsp->data;
-	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
+	(void) memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
 	net_buf_unref(rsp);
 
 	if (BT_VS_CMD_SUP_FEAT(bt_dev.vs_commands)) {
@@ -6198,8 +6198,8 @@ static void hci_vs_init(void)
 		}
 
 		rp.feat = (void *)rsp->data;
-		memcpy(bt_dev.vs_features, rp.feat->features,
-		       BT_DEV_VS_FEAT_MAX);
+		(void) memcpy(bt_dev.vs_features, rp.feat->features,
+				BT_DEV_VS_FEAT_MAX);
 		net_buf_unref(rsp);
 	}
 }
@@ -6595,7 +6595,7 @@ static int set_data_add(uint8_t *set_dat
 			set_data[set_data_len++] = len + 1;
 			set_data[set_data_len++] = type;
 
-			memcpy(&set_data[set_data_len], data[j].data, len);
+			(void) memcpy(&set_data[set_data_len], data[j].data, len);
 			set_data_len += len;
 		}
 	}
@@ -6748,7 +6748,7 @@ void bt_id_get(bt_addr_le_t *addrs, size
 {
 	size_t to_copy = MIN(*count, bt_dev.id_count);
 
-	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
+	(void) memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
 	*count = to_copy;
 }
 
@@ -6789,11 +6789,11 @@ static void id_create(uint8_t id, bt_add
 		uint8_t zero_irk[16] = { 0 };
 
 		if (irk && memcmp(irk, zero_irk, 16)) {
-			memcpy(&bt_dev.irk[id], irk, 16);
+			(void) memcpy(&bt_dev.irk[id], irk, 16);
 		} else {
 			bt_rand(&bt_dev.irk[id], 16);
 			if (irk) {
-				memcpy(irk, &bt_dev.irk[id], 16);
+				(void) memcpy(irk, &bt_dev.irk[id], 16);
 			}
 		}
 	}
@@ -6935,7 +6935,7 @@ int bt_id_delete(uint8_t id)
 static void bt_read_identity_root(uint8_t *ir)
 {
 	/* Invalid IR */
-	memset(ir, 0, 16);
+	(void) memset(ir, 0, 16);
 
 #if defined(CONFIG_BT_HCI_VS_EXT)
 	struct bt_hci_rp_vs_read_key_hierarchy_roots *rp;
@@ -6961,7 +6961,7 @@ static void bt_read_identity_root(uint8_
 	}
 
 	rp = (void *)rsp->data;
-	memcpy(ir, rp->ir, 16);
+	(void) memcpy(ir, rp->ir, 16);
 
 	net_buf_unref(rsp);
 #endif /* defined(CONFIG_BT_HCI_VS_EXT) */
@@ -7034,7 +7034,7 @@ uint8_t bt_read_static_addr(struct bt_hc
 	}
 
 	for (i = 0; i < cnt; i++) {
-		memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
+		(void) memcpy(&addrs[i], rp->a, sizeof(struct bt_hci_vs_static_addr));
 	}
 
 	net_buf_unref(rsp);
@@ -8714,7 +8714,7 @@ int bt_le_set_chan_map(uint8_t chan_map[
 
 	cp = net_buf_add(buf, sizeof(*cp));
 
-	memcpy(&cp->ch_map[0], &chan_map[0], 4);
+	(void) memcpy(&cp->ch_map[0], &chan_map[0], 4);
 	cp->ch_map[4] = chan_map[4] & BIT_MASK(5);
 
 	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
@@ -8829,7 +8829,7 @@ static int br_start_inquiry(const struct
 	cp->length = param->length;
 	cp->num_rsp = 0xff; /* we limit discovery only by time */
 
-	memcpy(cp->lap, iac, 3);
+	(void) memcpy(cp->lap, iac, 3);
 	if (param->limited) {
 		cp->lap[0] = 0x00;
 	}
@@ -9068,7 +9068,7 @@ int bt_dh_key_gen(const uint8_t remote_p
 	}
 
 	cp = net_buf_add(buf, sizeof(*cp));
-	memcpy(cp->key, remote_pk, sizeof(cp->key));
+	(void) memcpy(cp->key, remote_pk, sizeof(cp->key));
 
 	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_GENERATE_DHKEY, buf, NULL);
 	if (err) {
diff -u -p a/subsys/bluetooth/host/uuid.c b/subsys/bluetooth/host/uuid.c
--- a/subsys/bluetooth/host/uuid.c
+++ b/subsys/bluetooth/host/uuid.c
@@ -42,7 +42,7 @@ static void uuid_to_uuid128(const struct
 			     &dst->val[UUID_16_BASE_OFFSET]);
 		return;
 	case BT_UUID_TYPE_128:
-		memcpy(dst, src, sizeof(*dst));
+		(void) memcpy(dst, src, sizeof(*dst));
 		return;
 	}
 }
@@ -90,7 +90,7 @@ bool bt_uuid_create(struct bt_uuid *uuid
 		break;
 	case 16:
 		uuid->type = BT_UUID_TYPE_128;
-		memcpy(&BT_UUID_128(uuid)->val, data, 16);
+		(void) memcpy(&BT_UUID_128(uuid)->val, data, 16);
 		break;
 	default:
 		return false;
@@ -111,12 +111,12 @@ void bt_uuid_to_str(const struct bt_uuid
 		snprintk(str, len, "%08x", BT_UUID_32(uuid)->val);
 		break;
 	case BT_UUID_TYPE_128:
-		memcpy(&tmp0, &BT_UUID_128(uuid)->val[0], sizeof(tmp0));
-		memcpy(&tmp1, &BT_UUID_128(uuid)->val[2], sizeof(tmp1));
-		memcpy(&tmp2, &BT_UUID_128(uuid)->val[6], sizeof(tmp2));
-		memcpy(&tmp3, &BT_UUID_128(uuid)->val[8], sizeof(tmp3));
-		memcpy(&tmp4, &BT_UUID_128(uuid)->val[10], sizeof(tmp4));
-		memcpy(&tmp5, &BT_UUID_128(uuid)->val[12], sizeof(tmp5));
+		(void) memcpy(&tmp0, &BT_UUID_128(uuid)->val[0], sizeof(tmp0));
+		(void) memcpy(&tmp1, &BT_UUID_128(uuid)->val[2], sizeof(tmp1));
+		(void) memcpy(&tmp2, &BT_UUID_128(uuid)->val[6], sizeof(tmp2));
+		(void) memcpy(&tmp3, &BT_UUID_128(uuid)->val[8], sizeof(tmp3));
+		(void) memcpy(&tmp4, &BT_UUID_128(uuid)->val[10], sizeof(tmp4));
+		(void) memcpy(&tmp5, &BT_UUID_128(uuid)->val[12], sizeof(tmp5));
 
 		snprintk(str, len, "%08x-%04x-%04x-%04x-%08x%04x",
 			 tmp5, tmp4, tmp3, tmp2, tmp1, tmp0);
diff -u -p a/subsys/bluetooth/host/crypto.c b/subsys/bluetooth/host/crypto.c
--- a/subsys/bluetooth/host/crypto.c
+++ b/subsys/bluetooth/host/crypto.c
@@ -46,7 +46,7 @@ static int prng_reseed(struct tc_hmac_pr
 		}
 
 		rp = (void *)rsp->data;
-		memcpy(&seed[i * 8], rp->rand, 8);
+		(void) memcpy(&seed[i * 8], rp->rand, 8);
 
 		net_buf_unref(rsp);
 	}
diff -u -p a/subsys/bluetooth/shell/gatt.c b/subsys/bluetooth/shell/gatt.c
--- a/subsys/bluetooth/shell/gatt.c
+++ b/subsys/bluetooth/shell/gatt.c
@@ -444,7 +444,7 @@ static void update_write_stats(uint16_t 
 
 static void reset_write_stats(void)
 {
-	memset(&write_stats, 0, sizeof(write_stats));
+	(void) memset(&write_stats, 0, sizeof(write_stats));
 }
 
 static void print_write_stats(void)
@@ -693,7 +693,7 @@ static int cmd_show_db(const struct shel
 	struct bt_uuid_16 uuid;
 	size_t total_len;
 
-	memset(&stats, 0, sizeof(stats));
+	(void) memset(&stats, 0, sizeof(stats));
 
 	if (argc > 1) {
 		uint16_t num_matches = 0;
@@ -793,7 +793,7 @@ static ssize_t write_vnd(struct bt_conn 
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -827,7 +827,7 @@ static ssize_t write_long_vnd(struct bt_
 	}
 
 	/* Copy to buffer */
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -914,7 +914,7 @@ static int cmd_notify(const struct shell
 		data = strtoul(argv[1], NULL, 16);
 	}
 
-	memset(&params, 0, sizeof(params));
+	(void) memset(&params, 0, sizeof(params));
 
 	params.uuid = &vnd1_echo_uuid.uuid;
 	params.attr = vnd1_attrs;
@@ -961,7 +961,7 @@ static ssize_t write_met(struct bt_conn 
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	update_write_stats(len);
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c
--- a/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c
+++ b/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c
@@ -187,9 +187,9 @@ static int prepare_cb(struct lll_prepare
 			/* Copy the address from the adv packet we will send
 			 * into the scan response.
 			 */
-			memcpy(&scan_pdu->adv_ext_ind.ext_hdr_adi_adv_data[1],
-			       &sec_pdu->adv_ext_ind.ext_hdr_adi_adv_data[1],
-			       BDADDR_SIZE);
+			(void) memcpy(&scan_pdu->adv_ext_ind.ext_hdr_adi_adv_data[1],
+					&sec_pdu->adv_ext_ind.ext_hdr_adi_adv_data[1],
+					BDADDR_SIZE);
 		}
 #else
 		ARG_UNUSED(scan_pdu);
diff -u -p a/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/ecb.c b/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/ecb.c
--- a/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/ecb.c
+++ b/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/ecb.c
@@ -54,12 +54,12 @@ void ecb_encrypt_be(uint8_t const *const
 {
 	struct ecb_param ecb;
 
-	memcpy(&ecb.key[0], key_be, sizeof(ecb.key));
-	memcpy(&ecb.clear_text[0], clear_text_be, sizeof(ecb.clear_text));
+	(void) memcpy(&ecb.key[0], key_be, sizeof(ecb.key));
+	(void) memcpy(&ecb.clear_text[0], clear_text_be, sizeof(ecb.clear_text));
 
 	do_ecb(&ecb);
 
-	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
+	(void) memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
 }
 
 void ecb_encrypt(uint8_t const *const key_le, uint8_t const *const clear_text_le,
@@ -78,8 +78,8 @@ void ecb_encrypt(uint8_t const *const ke
 	}
 
 	if (cipher_text_be) {
-		memcpy(cipher_text_be, &ecb.cipher_text[0],
-			 sizeof(ecb.cipher_text));
+		(void) memcpy(cipher_text_be, &ecb.cipher_text[0],
+				sizeof(ecb.cipher_text));
 	}
 }
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_adv.c b/subsys/bluetooth/controller/ll_sw/ull_adv.c
--- a/subsys/bluetooth/controller/ll_sw/ull_adv.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_adv.c
@@ -1445,8 +1445,8 @@ uint8_t ull_adv_data_set(struct ll_adv_s
 
 	pdu->tx_addr = prev->tx_addr;
 	pdu->rx_addr = prev->rx_addr;
-	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
-	memcpy(&pdu->adv_ind.data[0], data, len);
+	(void) memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
+	(void) memcpy(&pdu->adv_ind.data[0], data, len);
 	pdu->len = BDADDR_SIZE + len;
 
 	lll_adv_data_enqueue(&adv->lll, idx);
@@ -1728,7 +1728,7 @@ static void disabled_cb(void *param)
 	rx->hdr.handle = 0xffff;
 
 	cc = (void *)rx->pdu;
-	memset(cc, 0x00, sizeof(struct node_rx_cc));
+	(void) memset(cc, 0x00, sizeof(struct node_rx_cc));
 	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 
 	ftr = &(rx->hdr.rx_ftr);
diff -u -p a/subsys/bluetooth/controller/ll_sw/ull_conn.c b/subsys/bluetooth/controller/ll_sw/ull_conn.c
--- a/subsys/bluetooth/controller/ll_sw/ull_conn.c
+++ b/subsys/bluetooth/controller/ll_sw/ull_conn.c
@@ -353,8 +353,8 @@ uint8_t ll_chm_get(uint16_t handle, uint
 	 */
 	do {
 		conn->chm_updated = 0U;
-		memcpy(chm, conn->lll.data_chan_map,
-		       sizeof(conn->lll.data_chan_map));
+		(void) memcpy(chm, conn->lll.data_chan_map,
+				sizeof(conn->lll.data_chan_map));
 	} while (conn->chm_updated);
 
 	return 0;
@@ -2453,9 +2453,9 @@ static inline void event_ch_map_prep(str
 				sizeof(struct pdu_data_llctrl_chan_map_ind);
 			pdu_ctrl_tx->llctrl.opcode =
 				PDU_DATA_LLCTRL_TYPE_CHAN_MAP_IND;
-			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
-			       &conn->llcp.chan_map.chm[0],
-			       sizeof(pdu_ctrl_tx->llctrl.chan_map_ind.chm));
+			(void) memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
+					&conn->llcp.chan_map.chm[0],
+					sizeof(pdu_ctrl_tx->llctrl.chan_map_ind.chm));
 			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
 				sys_cpu_to_le16(conn->llcp.chan_map.instant);
 
@@ -2469,9 +2469,9 @@ static inline void event_ch_map_prep(str
 		conn->llcp_ack = conn->llcp_req;
 
 		/* copy to active channel map */
-		memcpy(&lll->data_chan_map[0],
-		       &conn->llcp.chan_map.chm[0],
-		       sizeof(lll->data_chan_map));
+		(void) memcpy(&lll->data_chan_map[0],
+				&conn->llcp.chan_map.chm[0],
+				sizeof(lll->data_chan_map));
 		lll->data_chan_count =
 			util_ones_count_get(&lll->data_chan_map[0],
 					    sizeof(lll->data_chan_map));
@@ -3792,8 +3792,9 @@ static uint8_t chan_map_upd_recv(struct 
 	}
 
 
-	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
-	       sizeof(conn->llcp.chan_map.chm));
+	(void) memcpy(&conn->llcp.chan_map.chm[0],
+			&pdu->llctrl.chan_map_ind.chm[0],
+			sizeof(conn->llcp.chan_map.chm));
 	conn->llcp.chan_map.instant = instant;
 	conn->llcp.chan_map.initiate = 0U;
 
@@ -3827,8 +3828,9 @@ static void enc_req_reused_send(struct l
 	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
 			   sizeof(struct pdu_data_llctrl_enc_req);
 	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
-	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
-	       sizeof(pdu_ctrl_tx->llctrl.enc_req.rand));
+	(void) memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0],
+			&conn->llcp_enc.rand[0],
+			sizeof(pdu_ctrl_tx->llctrl.enc_req.rand));
 	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
 	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
 
@@ -3884,10 +3886,10 @@ static int enc_rsp_send(struct ll_conn *
 			   sizeof(pdu_ctrl_tx->llctrl.enc_rsp.ivs));
 
 	/* things from slave stored for session key calculation */
-	memcpy(&conn->llcp.encryption.skd[8],
-	       &pdu_ctrl_tx->llctrl.enc_rsp.skds[0], 8);
-	memcpy(&conn->lll.ccm_rx.iv[4],
-	       &pdu_ctrl_tx->llctrl.enc_rsp.ivs[0], 4);
+	(void) memcpy(&conn->llcp.encryption.skd[8],
+			&pdu_ctrl_tx->llctrl.enc_rsp.skds[0], 8);
+	(void) memcpy(&conn->lll.ccm_rx.iv[4],
+			&pdu_ctrl_tx->llctrl.enc_rsp.ivs[0], 4);
 
 	ctrl_tx_enqueue(conn, tx);
 
@@ -4965,10 +4967,10 @@ static inline void ctrl_tx_ack(struct ll
 #if defined(CONFIG_BT_CTLR_LE_ENC)
 	case PDU_DATA_LLCTRL_TYPE_ENC_REQ:
 		/* things from master stored for session key calculation */
-		memcpy(&conn->llcp.encryption.skd[0],
-		       &pdu_tx->llctrl.enc_req.skdm[0], 8);
-		memcpy(&conn->lll.ccm_rx.iv[0],
-		       &pdu_tx->llctrl.enc_req.ivm[0], 4);
+		(void) memcpy(&conn->llcp.encryption.skd[0],
+				&pdu_tx->llctrl.enc_req.skdm[0], 8);
+		(void) memcpy(&conn->lll.ccm_rx.iv[0],
+				&pdu_tx->llctrl.enc_req.ivm[0], 4);
 
 		/* pause data packet tx */
 		conn->llcp_enc.pause_tx = 1U;
@@ -5284,9 +5286,9 @@ static inline int ctrl_rx(memq_link_t *l
 		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 #else /* CONFIG_BT_CTLR_FAST_ENC */
 		/* back up rand and ediv for deferred generation of Enc Req */
-		memcpy(&conn->llcp_enc.rand[0],
-		       &pdu_rx->llctrl.enc_req.rand[0],
-		       sizeof(conn->llcp_enc.rand));
+		(void) memcpy(&conn->llcp_enc.rand[0],
+				&pdu_rx->llctrl.enc_req.rand[0],
+				sizeof(conn->llcp_enc.rand));
 		conn->llcp_enc.ediv[0] = pdu_rx->llctrl.enc_req.ediv[0];
 		conn->llcp_enc.ediv[1] = pdu_rx->llctrl.enc_req.ediv[1];
 
@@ -5302,10 +5304,10 @@ static inline int ctrl_rx(memq_link_t *l
 		conn->llcp_ack -= 2U;
 
 		/* things from master stored for session key calculation */
-		memcpy(&conn->llcp.encryption.skd[0],
-		       &pdu_rx->llctrl.enc_req.skdm[0], 8);
-		memcpy(&conn->lll.ccm_rx.iv[0],
-		       &pdu_rx->llctrl.enc_req.ivm[0], 4);
+		(void) memcpy(&conn->llcp.encryption.skd[0],
+				&pdu_rx->llctrl.enc_req.skdm[0], 8);
+		(void) memcpy(&conn->lll.ccm_rx.iv[0],
+				&pdu_rx->llctrl.enc_req.ivm[0], 4);
 
 		/* pause rx data packets */
 		conn->llcp_enc.pause_rx = 1U;
@@ -5324,10 +5326,10 @@ static inline int ctrl_rx(memq_link_t *l
 		}
 
 		/* things sent by slave stored for session key calculation */
-		memcpy(&conn->llcp.encryption.skd[8],
-		       &pdu_rx->llctrl.enc_rsp.skds[0], 8);
-		memcpy(&conn->lll.ccm_rx.iv[4],
-		       &pdu_rx->llctrl.enc_rsp.ivs[0], 4);
+		(void) memcpy(&conn->llcp.encryption.skd[8],
+				&pdu_rx->llctrl.enc_rsp.skds[0], 8);
+		(void) memcpy(&conn->lll.ccm_rx.iv[4],
+				&pdu_rx->llctrl.enc_rsp.ivs[0], 4);
 
 		/* pause rx data packets */
 		conn->llcp_enc.pause_rx = 1U;
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/ecb.c b/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/ecb.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/ecb.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/ecb.c
@@ -27,7 +27,7 @@ void ecb_encrypt_be(uint8_t const *const
 
 	cau3_handle_t handle;
 
-	memcpy(&keyAes, key_be, sizeof(keyAes));
+	(void) memcpy(&keyAes, key_be, sizeof(keyAes));
 
 	/* CAU3 driver supports 4 key slots. */
 	handle.keySlot = kCAU3_KeySlot1;
@@ -98,7 +98,7 @@ void ecb_encrypt(uint8_t const *const ke
 	}
 
 	if (cipher_text_be) {
-		memcpy(cipher_text_be, &cipher, sizeof(cipher));
+		(void) memcpy(cipher_text_be, &cipher, sizeof(cipher));
 	}
 }
 
diff -u -p a/subsys/bluetooth/services/ots/ots_l2cap.c b/subsys/bluetooth/services/ots/ots_l2cap.c
--- a/subsys/bluetooth/services/ots/ots_l2cap.c
+++ b/subsys/bluetooth/services/ots/ots_l2cap.c
@@ -82,7 +82,7 @@ static void l2cap_sent(struct bt_l2cap_c
 	}
 
 	/* TX completed - notify upper layers and clean up. */
-	memset(&l2cap_ctx->tx, 0, sizeof(l2cap_ctx->tx));
+	(void) memset(&l2cap_ctx->tx, 0, sizeof(l2cap_ctx->tx));
 
 	LOG_DBG("Scheduled TX on L2CAP CoC is complete");
 
@@ -133,7 +133,7 @@ static int l2cap_accept(struct bt_conn *
 		}
 
 		l2cap_chan_init(&l2cap_ctx->ot_chan);
-		memset(&l2cap_ctx->tx, 0, sizeof(l2cap_ctx->tx));
+		(void) memset(&l2cap_ctx->tx, 0, sizeof(l2cap_ctx->tx));
 
 		*chan = &l2cap_ctx->ot_chan.chan;
 
diff -u -p a/subsys/bluetooth/services/ots/ots_oacp.c b/subsys/bluetooth/services/ots/ots_oacp.c
--- a/subsys/bluetooth/services/ots/ots_oacp.c
+++ b/subsys/bluetooth/services/ots/ots_oacp.c
@@ -56,8 +56,9 @@ static enum bt_gatt_ots_oacp_res_code oa
 
 	ots->cur_obj->state.type = BT_GATT_OTS_OBJECT_READ_OP_STATE;
 	ots->cur_obj->state.read_op.sent_len = 0;
-	memcpy(&ots->cur_obj->state.read_op.oacp_params, &proc->read_params,
-		sizeof(ots->cur_obj->state.read_op.oacp_params));
+	(void) memcpy(&ots->cur_obj->state.read_op.oacp_params,
+			&proc->read_params,
+			sizeof(ots->cur_obj->state.read_op.oacp_params));
 
 	LOG_DBG("Read procedure is accepted");
 
@@ -272,8 +273,8 @@ static int oacp_ind_send(const struct bt
 	oacp_res[oacp_res_len++] = oacp_status;
 
 	/* Prepare indication parameters */
-	memset(&ots->oacp_ind.params, 0, sizeof(ots->oacp_ind.params));
-	memcpy(&ots->oacp_ind.attr, oacp_attr, sizeof(ots->oacp_ind.attr));
+	(void) memset(&ots->oacp_ind.params, 0, sizeof(ots->oacp_ind.params));
+	(void) memcpy(&ots->oacp_ind.attr, oacp_attr, sizeof(ots->oacp_ind.attr));
 	ots->oacp_ind.params.attr = &ots->oacp_ind.attr;
 	ots->oacp_ind.params.func = oacp_ind_cb;
 	ots->oacp_ind.params.data = oacp_res;
diff -u -p a/subsys/fs/littlefs_fs.c b/subsys/fs/littlefs_fs.c
--- a/subsys/fs/littlefs_fs.c
+++ b/subsys/fs/littlefs_fs.c
@@ -210,7 +210,7 @@ static int littlefs_open(struct fs_file_
 
 	struct lfs_file_data *fdp = fp->filep;
 
-	memset(fdp, 0, sizeof(*fdp));
+	(void) memset(fdp, 0, sizeof(*fdp));
 
 	ret = k_mem_pool_alloc(&file_cache_pool, &fdp->cache_block,
 			       lfs->cfg->cache_size, K_NO_WAIT);
@@ -383,7 +383,7 @@ static int littlefs_opendir(struct fs_di
 		return -ENOMEM;
 	}
 
-	memset(dp->dirp, 0, sizeof(struct lfs_dir));
+	(void) memset(dp->dirp, 0, sizeof(struct lfs_dir));
 
 	path = fs_impl_strip_prefix(path, dp->mp);
 
diff -u -p a/tests/crypto/tinycrypt_hmac_prng/src/hmac_prng.c b/tests/crypto/tinycrypt_hmac_prng/src/hmac_prng.c
--- a/tests/crypto/tinycrypt_hmac_prng/src/hmac_prng.c
+++ b/tests/crypto/tinycrypt_hmac_prng/src/hmac_prng.c
@@ -74,21 +74,21 @@ unsigned int do_hmac_prng_pr_false_test(
 
 	uint8_t *p = seed_material;
 
-	memset(&h, 0x0, sizeof(h));
+	(void) memset(&h, 0x0, sizeof(h));
 
 	if (vec->entropyinputlen > 0) {
-		memcpy(p, vec->entropyinput, vec->entropyinputlen);
+		(void) memcpy(p, vec->entropyinput, vec->entropyinputlen);
 		p += vec->entropyinputlen;
 	}
 
 	if (vec->noncelen > 0) {
-		memcpy(p, vec->nonce, vec->noncelen);
+		(void) memcpy(p, vec->nonce, vec->noncelen);
 		p += vec->noncelen;
 	}
 
 	if (vec->personalizationstringlen > 0) {
-		memcpy(p, vec->personalizationstring,
-		vec->personalizationstringlen);
+		(void) memcpy(p, vec->personalizationstring,
+				vec->personalizationstringlen);
 	}
 
 	seed_material_size = vec->entropyinputlen + vec->noncelen +
diff -u -p a/tests/net/tcp2/src/main.c b/tests/net/tcp2/src/main.c
--- a/tests/net/tcp2/src/main.c
+++ b/tests/net/tcp2/src/main.c
@@ -222,7 +222,7 @@ static struct net_pkt *tester_prepare_tc
 		goto fail;
 	}
 
-	memset(th, 0U, sizeof(struct tcphdr));
+	(void) memset(th, 0U, sizeof(struct tcphdr));
 
 	th->th_sport = src_port;
 	th->th_dport = dst_port;
diff -u -p a/tests/net/ipv6_fragment/src/main.c b/tests/net/ipv6_fragment/src/main.c
--- a/tests/net/ipv6_fragment/src/main.c
+++ b/tests/net/ipv6_fragment/src/main.c
@@ -1975,7 +1975,7 @@ static void test_recv_ipv6_fragment(void
 	net_pkt_set_ip_hdr_len(pkt1, sizeof(struct net_ipv6_hdr));
 	net_pkt_cursor_init(pkt1);
 
-	memcpy(&ipv6_hdr, ipv6_reass_frag1, sizeof(struct net_ipv6_hdr));
+	(void) memcpy(&ipv6_hdr, ipv6_reass_frag1, sizeof(struct net_ipv6_hdr));
 
 	ret = net_pkt_write(pkt1, ipv6_reass_frag1,
 			    sizeof(struct net_ipv6_hdr) + 1);
@@ -2014,7 +2014,7 @@ static void test_recv_ipv6_fragment(void
 	net_pkt_set_ip_hdr_len(pkt2, sizeof(struct net_ipv6_hdr));
 	net_pkt_cursor_init(pkt2);
 
-	memcpy(&ipv6_hdr, ipv6_reass_frag2, sizeof(struct net_ipv6_hdr));
+	(void) memcpy(&ipv6_hdr, ipv6_reass_frag2, sizeof(struct net_ipv6_hdr));
 
 	ret = net_pkt_write(pkt2, ipv6_reass_frag2,
 			    sizeof(struct net_ipv6_hdr) + 1);
diff -u -p a/tests/net/lib/mqtt_packet/src/mqtt_packet.c b/tests/net/lib/mqtt_packet/src/mqtt_packet.c
--- a/tests/net/lib/mqtt_packet/src/mqtt_packet.c
+++ b/tests/net/lib/mqtt_packet/src/mqtt_packet.c
@@ -768,7 +768,7 @@ static int eval_msg_publish(struct mqtt_
 	uint32_t length;
 	struct buf_ctx buf;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	buf.cur = client.tx_buf;
 	buf.end = client.tx_buf + client.tx_buf_size;
@@ -776,8 +776,8 @@ static int eval_msg_publish(struct mqtt_
 	rc = publish_encode(param, &buf);
 
 	/* Payload is not copied, copy it manually just after the header.*/
-	memcpy(buf.end, param->message.payload.data,
-	       param->message.payload.len);
+	(void) memcpy(buf.end, param->message.payload.data,
+			param->message.payload.len);
 	buf.end += param->message.payload.len;
 
 	/**TESTPOINT: Check publish_encode function*/
@@ -868,7 +868,7 @@ static int eval_msg_suback(struct mqtt_t
 	buf.cur = mqtt_test->expected;
 	buf.end = mqtt_test->expected + mqtt_test->expected_len;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	rc = fixed_header_decode(&buf, &type_and_flags, &length);
 
@@ -922,7 +922,7 @@ static int eval_msg_puback(struct mqtt_t
 	uint32_t length;
 	struct buf_ctx buf;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	buf.cur = client.tx_buf;
 	buf.end = client.tx_buf + client.tx_buf_size;
@@ -960,7 +960,7 @@ static int eval_msg_pubcomp(struct mqtt_
 	uint8_t type_and_flags;
 	struct buf_ctx buf;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	buf.cur = client.tx_buf;
 	buf.end = client.tx_buf + client.tx_buf_size;
@@ -998,7 +998,7 @@ static int eval_msg_pubrec(struct mqtt_t
 	uint8_t type_and_flags;
 	struct buf_ctx buf;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	buf.cur = client.tx_buf;
 	buf.end = client.tx_buf + client.tx_buf_size;
@@ -1036,7 +1036,7 @@ static int eval_msg_pubrel(struct mqtt_t
 	uint8_t type_and_flags;
 	struct buf_ctx buf;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	buf.cur = client.tx_buf;
 	buf.end = client.tx_buf + client.tx_buf_size;
@@ -1074,7 +1074,7 @@ static int eval_msg_unsuback(struct mqtt
 	uint8_t type_and_flags;
 	struct buf_ctx buf;
 
-	memset(&dec_param, 0, sizeof(dec_param));
+	(void) memset(&dec_param, 0, sizeof(dec_param));
 
 	buf.cur = mqtt_test->expected;
 	buf.end = mqtt_test->expected + mqtt_test->expected_len;
diff -u -p a/tests/net/route_mcast/src/main.c b/tests/net/route_mcast/src/main.c
--- a/tests/net/route_mcast/src/main.c
+++ b/tests/net/route_mcast/src/main.c
@@ -370,7 +370,7 @@ static void test_route_mcast_route_add(v
 	zassert_not_null(test_mcast_routes[4],
 			"add for nw prefix based failed");
 
-	memcpy(&nw_prefix_based_all_nodes, &mcast_prefix_nw_based,
+	(void) memcpy(&nw_prefix_based_all_nodes, &mcast_prefix_nw_based,
 			sizeof(struct in6_addr));
 	nw_prefix_based_all_nodes.s6_addr[15] = 0x01;
 
@@ -463,10 +463,10 @@ static void test_route_mcast_scenario1(v
 	 *		only iface_2 forwards
 	 */
 	reset_counters();
-	memcpy(&active_scenario.src, &iface_1_addr, sizeof(struct in6_addr));
+	(void) memcpy(&active_scenario.src, &iface_1_addr, sizeof(struct in6_addr));
 	active_scenario.src.s6_addr[15] = 0x02;
 
-	memcpy(&active_scenario.mcast, &mcast_prefix_site_local,
+	(void) memcpy(&active_scenario.mcast, &mcast_prefix_site_local,
 			sizeof(struct in6_addr));
 	active_scenario.mcast.s6_addr[15] = 0x01;
 
@@ -490,7 +490,7 @@ static void test_route_mcast_scenario1(v
 
 	reset_counters();
 
-	memcpy(&active_scenario.src, &iface_3_addr, sizeof(struct in6_addr));
+	(void) memcpy(&active_scenario.src, &iface_3_addr, sizeof(struct in6_addr));
 	active_scenario.src.s6_addr[15] = 0x09;
 
 	struct net_pkt *pkt2 = setup_ipv6_udp(iface_3, &active_scenario.src,
@@ -525,10 +525,10 @@ static void test_route_mcast_scenario2(v
 	 *		now iface_1 must forward due to routing entry
 	 */
 	reset_counters();
-	memcpy(&active_scenario.src, &iface_1_addr, sizeof(struct in6_addr));
+	(void) memcpy(&active_scenario.src, &iface_1_addr, sizeof(struct in6_addr));
 	active_scenario.src.s6_addr[15] = 0x08;
 
-	memcpy(&active_scenario.mcast, &mcast_prefix_admin,
+	(void) memcpy(&active_scenario.mcast, &mcast_prefix_admin,
 			sizeof(struct in6_addr));
 	active_scenario.mcast.s6_addr[15] = 0x01;
 
@@ -549,7 +549,7 @@ static void test_route_mcast_scenario2(v
 	zassert_equal(forwarding_counter, 0, "wrong count forwarded packets");
 
 	reset_counters();
-	memcpy(&active_scenario.src, &iface_3_addr, sizeof(struct in6_addr));
+	(void) memcpy(&active_scenario.src, &iface_3_addr, sizeof(struct in6_addr));
 	active_scenario.src.s6_addr[15] = 0x08;
 
 	struct net_pkt *pkt2 = setup_ipv6_udp(iface_3, &active_scenario.src,
@@ -581,11 +581,11 @@ static void test_route_mcast_scenario3(v
 	 *		no iface forwards
 	 */
 	reset_counters();
-	memcpy(&active_scenario.src, &iface_3_addr, sizeof(struct in6_addr));
+	(void) memcpy(&active_scenario.src, &iface_3_addr, sizeof(struct in6_addr));
 	active_scenario.src.s6_addr[15] = 0x08;
 
-	memcpy(&active_scenario.mcast, &mcast_prefix_nw_based,
-				sizeof(struct in6_addr));
+	(void) memcpy(&active_scenario.mcast, &mcast_prefix_nw_based,
+			sizeof(struct in6_addr));
 	active_scenario.mcast.s6_addr[15] = 0x01;
 
 	struct net_pkt *pkt = setup_ipv6_udp(iface_3, &active_scenario.src,
diff -u -p a/tests/net/socket/websocket/src/main.c b/tests/net/socket/websocket/src/main.c
--- a/tests/net/socket/websocket/src/main.c
+++ b/tests/net/socket/websocket/src/main.c
@@ -113,13 +113,13 @@ static void test_recv(int count)
 	int total_read = 0;
 	int ret, i, left;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 
 	ctx.tmp_buf = temp_recv_buf;
 	ctx.tmp_buf_len = sizeof(temp_recv_buf);
 	ctx.tmp_buf_pos = 0;
 
-	memcpy(feed_buf, &frame1, sizeof(frame1));
+	(void) memcpy(feed_buf, &frame1, sizeof(frame1));
 
 	NET_DBG("Reading %d bytes at a time, frame %zd hdr %zd", count,
 		sizeof(frame1), FRAME1_HDR_SIZE);
@@ -233,12 +233,12 @@ static void test_recv_2(int count)
 	int total_read = 0;
 	int ret;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 
 	ctx.tmp_buf = temp_recv_buf;
 	ctx.tmp_buf_len = sizeof(temp_recv_buf);
 
-	memcpy(feed_buf, &frame2, sizeof(frame2));
+	(void) memcpy(feed_buf, &frame2, sizeof(frame2));
 
 	NET_DBG("Reading %d bytes at a time, frame %zd hdr %zd", count,
 		sizeof(frame2), FRAME1_HDR_SIZE);
@@ -277,7 +277,7 @@ int verify_sent_and_received_msg(struct 
 	size_t split_len = 0, total_read = 0;
 	int ret;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 
 	ctx.tmp_buf = temp_recv_buf;
 	ctx.tmp_buf_len = sizeof(temp_recv_buf);
@@ -337,7 +337,7 @@ static void test_send_and_recv_lorem_ips
 	static struct websocket_context ctx;
 	int ret;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 
 	ctx.tmp_buf = temp_recv_buf;
 	ctx.tmp_buf_len = sizeof(temp_recv_buf);
@@ -358,7 +358,7 @@ static void test_recv_two_large_split_ms
 	static struct websocket_context ctx;
 	int ret;
 
-	memset(&ctx, 0, sizeof(ctx));
+	(void) memset(&ctx, 0, sizeof(ctx));
 
 	ctx.tmp_buf = temp_recv_buf;
 	ctx.tmp_buf_len = sizeof(temp_recv_buf);
diff -u -p a/tests/net/socket/socketpair/src/test_socketpair_happy_path.c b/tests/net/socket/socketpair/src/test_socketpair_happy_path.c
--- a/tests/net/socket/socketpair/src/test_socketpair_happy_path.c
+++ b/tests/net/socket/socketpair/src/test_socketpair_happy_path.c
@@ -63,7 +63,7 @@ static void happy_path(
 		zassert_equal(actual_msg_len, expected_msg_len,
 				  "did not write entire message");
 
-		memset(actual_msg, 0, sizeof(actual_msg));
+		(void) memset(actual_msg, 0, sizeof(actual_msg));
 
 		LOG_DBG("calling read(%d, %p, %u)", sv[i], actual_msg,
 			(unsigned int)sizeof(actual_msg));
@@ -89,7 +89,7 @@ static void happy_path(
 		zassert_equal(actual_msg_len, expected_msg_len,
 				  "did not send entire message");
 
-		memset(actual_msg, 0, sizeof(actual_msg));
+		(void) memset(actual_msg, 0, sizeof(actual_msg));
 
 		res = recv(sv[(!i) & 1], actual_msg, sizeof(actual_msg), 0);
 
@@ -113,7 +113,7 @@ static void happy_path(
 		zassert_equal(actual_msg_len, expected_msg_len,
 				  "did not sendto entire message");
 
-		memset(actual_msg, 0, sizeof(actual_msg));
+		(void) memset(actual_msg, 0, sizeof(actual_msg));
 
 		len = 0;
 		res = recvfrom(sv[(!i) & 1], actual_msg, sizeof(actual_msg), 0,
@@ -131,7 +131,7 @@ static void happy_path(
 		 * Test with sendmsg(2) / recv(2) - Zephyr lacks recvmsg atm
 		 */
 
-		memset(&msghdr, 0, sizeof(msghdr));
+		(void) memset(&msghdr, 0, sizeof(msghdr));
 		msghdr.msg_iov = &iovec;
 		msghdr.msg_iovlen = 1;
 		iovec.iov_base = (void *)expected_msg;
diff -u -p a/tests/drivers/led/led_api/src/test_led_api.c b/tests/drivers/led/led_api/src/test_led_api.c
--- a/tests/drivers/led/led_api/src/test_led_api.c
+++ b/tests/drivers/led/led_api/src/test_led_api.c
@@ -181,7 +181,7 @@ void test_led_set_color(void)
 			continue;
 		}
 
-		memset(colors, 0, sizeof(colors));
+		(void) memset(colors, 0, sizeof(colors));
 
 		/* Try to set more colors than supported. */
 		ret = led_set_color(led_ctrl, led, num_colors + 1, colors);
@@ -206,7 +206,7 @@ void test_led_set_color(void)
 		for (col = 0; col < num_colors; col++) {
 			uint16_t level;
 
-			memset(colors, 0, sizeof(colors));
+			(void) memset(colors, 0, sizeof(colors));
 
 			for (level = 0; level <= COLOR_FULL; level++) {
 				colors[col] = level;
diff -u -p a/tests/drivers/dma/loop_transfer/src/dma.c b/tests/drivers/dma/loop_transfer/src/dma.c
--- a/tests/drivers/dma/loop_transfer/src/dma.c
+++ b/tests/drivers/dma/loop_transfer/src/dma.c
@@ -79,11 +79,11 @@ void main(void)
 	printk("Preparing DMA Controller\n");
 
 #if CONFIG_NOCACHE_MEMORY
-	memset(tx_data, 0, sizeof(tx_data));
-	memcpy(tx_data, TX_DATA, sizeof(TX_DATA));
+	(void) memset(tx_data, 0, sizeof(tx_data));
+	(void) memcpy(tx_data, TX_DATA, sizeof(TX_DATA));
 #endif
 
-	memset(rx_data, 0, sizeof(rx_data));
+	(void) memset(rx_data, 0, sizeof(rx_data));
 
 	dma = device_get_binding(DMA_DEVICE_NAME);
 	if (!dma) {
diff -u -p a/tests/subsys/settings/fcb/src/settings_test_save_2_fcb.c b/tests/subsys/settings/fcb/src/settings_test_save_2_fcb.c
--- a/tests/subsys/settings/fcb/src/settings_test_save_2_fcb.c
+++ b/tests/subsys/settings/fcb/src/settings_test_save_2_fcb.c
@@ -35,7 +35,7 @@ void test_config_save_2_fcb(void)
 		     "can't register FCB as configuration destination");
 
 	test_config_fill_area(test_ref_value, 0);
-	memcpy(val_string, test_ref_value, sizeof(val_string));
+	(void) memcpy(val_string, test_ref_value, sizeof(val_string));
 
 	val8 = 42U;
 	rc = settings_save();
@@ -58,7 +58,7 @@ void test_config_save_2_fcb(void)
 
 	for (i = 0; i < TESTS_S2_FCB_ITERATIONS; i++) {
 		test_config_fill_area(test_ref_value, i);
-		memcpy(val_string, test_ref_value, sizeof(val_string));
+		(void) memcpy(val_string, test_ref_value, sizeof(val_string));
 
 		rc = settings_save();
 		zassert_true(rc == 0, "fcb write error");
diff -u -p a/tests/subsys/settings/fs/src/settings_test_fs.c b/tests/subsys/settings/fs/src/settings_test_fs.c
--- a/tests/subsys/settings/fs/src/settings_test_fs.c
+++ b/tests/subsys/settings/fs/src/settings_test_fs.c
@@ -47,19 +47,19 @@ int c1_handle_get(const char *name, char
 
 	if (settings_name_steq(name, "mybar", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val8));
-		memcpy(val, &val8, MIN(val_len_max, sizeof(val8)));
+		(void) memcpy(val, &val8, MIN(val_len_max, sizeof(val8)));
 		return val_len_max;
 	}
 
 	if (settings_name_steq(name, "mybar16", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val16));
-		memcpy(val, &val16, MIN(val_len_max, sizeof(val16)));
+		(void) memcpy(val, &val16, MIN(val_len_max, sizeof(val16)));
 		return val_len_max;
 	}
 
 	if (settings_name_steq(name, "mybar64", &next) && !next) {
 		val_len_max = MIN(val_len_max, sizeof(val64));
-		memcpy(val, &val64, MIN(val_len_max, sizeof(val64)));
+		(void) memcpy(val, &val64, MIN(val_len_max, sizeof(val64)));
 		return val_len_max;
 	}
 
diff -u -p a/tests/subsys/settings/src/settings_enc.c b/tests/subsys/settings/src/settings_enc.c
--- a/tests/subsys/settings/src/settings_enc.c
+++ b/tests/subsys/settings/src/settings_enc.c
@@ -20,7 +20,7 @@ static int write_handler(void *ctx, off_
 		return -EIO;
 	}
 
-	memcpy(&enc_buf[off], buf, len);
+	(void) memcpy(&enc_buf[off], buf, len);
 	enc_buf_cnt += len;
 	return 0;
 }
@@ -86,7 +86,7 @@ static int read_handle(void *ctx, off_t 
 		return 0;
 	}
 
-	memcpy(buf, &enc_buf[off], r_len);
+	(void) memcpy(buf, &enc_buf[off], r_len);
 	*len = r_len;
 	return 0;
 }
@@ -100,7 +100,7 @@ static void test_raw_read_iteration(uint
 	int rc;
 	size_t expected;
 
-	memset(read_buf, 0x00, sizeof(read_buf));
+	(void) memset(read_buf, 0x00, sizeof(read_buf));
 
 	settings_line_io_init(read_handle, write_handler, NULL, rbs);
 
@@ -153,7 +153,7 @@ static void test_val_read_iteration(char
 	size_t len_read;
 	int rc;
 
-	memcpy(enc_buf, src, src_len);
+	(void) memcpy(enc_buf, src, src_len);
 
 	test_rwbs = rbs;
 
diff -u -p a/tests/subsys/canbus/isotp/implementation/src/main.c b/tests/subsys/canbus/isotp/implementation/src/main.c
--- a/tests/subsys/canbus/isotp/implementation/src/main.c
+++ b/tests/subsys/canbus/isotp/implementation/src/main.c
@@ -83,7 +83,7 @@ static void get_sf_net(struct isotp_recv
 
 	ret = memcmp(random_data, buf->data, buf->len);
 	zassert_equal(ret, 0, "received data differ");
-	memset(buf->data, 0, buf->len);
+	(void) memset(buf->data, 0, buf->len);
 	net_buf_unref(buf);
 }
 
@@ -92,7 +92,7 @@ static void get_sf(struct isotp_recv_ctx
 	int ret;
 	uint8_t *data_buf_ptr = data_buf;
 
-	memset(data_buf, 0, sizeof(data_buf));
+	(void) memset(data_buf, 0, sizeof(data_buf));
 	ret = isotp_recv(recv_ctx, data_buf_ptr++, 1, K_MSEC(1000));
 	zassert_equal(ret, 1, "recv returned %d", ret);
 	ret = isotp_recv(recv_ctx, data_buf_ptr++, sizeof(data_buf) - 1,
@@ -157,7 +157,7 @@ static void receive_test_data_net(struct
 		if (delay) {
 			k_msleep(delay);
 		}
-		memset(buf->data, 0, buf->len);
+		(void) memset(buf->data, 0, buf->len);
 		net_buf_unref(buf);
 	} while (remaining_len);
 
@@ -189,7 +189,7 @@ static void receive_test_data(struct iso
 	const uint8_t *data_ptr = data;
 
 	do {
-		memset(data_buf, 0, sizeof(data_buf));
+		(void) memset(data_buf, 0, sizeof(data_buf));
 		ret = isotp_recv(recv_ctx, data_buf, sizeof(data_buf),
 				 K_MSEC(1000));
 		zassert_true(ret >= 0, "recv error: %d", ret);
@@ -300,7 +300,7 @@ static void test_send_receive_net_single
 
 		do {
 			data_ptr = check_frag(frag, data_ptr);
-			memset(frag->data, 0, frag->len);
+			(void) memset(frag->data, 0, frag->len);
 		} while ((frag = frag->frags));
 
 		net_buf_unref(buf);
@@ -322,7 +322,7 @@ static void test_send_receive_single_blo
 	for (i = 0; i < NUMBER_OF_REPETITIONS; i++) {
 		send_test_data(can_dev, random_data, send_len);
 
-		memset(data_buf, 0, sizeof(data_buf));
+		(void) memset(data_buf, 0, sizeof(data_buf));
 		ret = isotp_recv(&recv_ctx, data_buf, sizeof(data_buf),
 				 K_MSEC(1000));
 		zassert_equal(ret, send_len,
diff -u -p a/tests/subsys/fs/fs_api/src/test_fs_dir_file.c b/tests/subsys/fs/fs_api/src/test_fs_dir_file.c
--- a/tests/subsys/fs/fs_api/src/test_fs_dir_file.c
+++ b/tests/subsys/fs/fs_api/src/test_fs_dir_file.c
@@ -197,7 +197,7 @@ void test_opendir(void)
 
 	TC_PRINT("\nopendir tests:\n");
 
-	memset(&dirp, 0, sizeof(dirp));
+	(void) memset(&dirp, 0, sizeof(dirp));
 	TC_PRINT("Test null path\n");
 	ret = fs_opendir(NULL, NULL);
 	zassert_not_equal(ret, 0, "Open NULL dir");
@@ -231,7 +231,7 @@ void test_closedir(void)
 	struct fs_dir_t dirp;
 
 	TC_PRINT("\nclosedir tests: %s\n", TEST_DIR);
-	memset(&dirp, 0, sizeof(dirp));
+	(void) memset(&dirp, 0, sizeof(dirp));
 	ret = fs_opendir(&dirp, TEST_DIR);
 	zassert_equal(ret, 0, "Fail to open dir");
 
@@ -251,8 +251,8 @@ static int _test_lsdir(const char *path)
 
 	TC_PRINT("\nlsdir tests:\n");
 
-	memset(&dirp, 0, sizeof(dirp));
-	memset(&entry, 0, sizeof(entry));
+	(void) memset(&dirp, 0, sizeof(dirp));
+	(void) memset(&entry, 0, sizeof(entry));
 
 	TC_PRINT("read an unopened dir\n");
 	dirp.dirp = "somepath";
diff -u -p a/tests/subsys/fs/nvs/src/main.c b/tests/subsys/fs/nvs/src/main.c
--- a/tests/subsys/fs/nvs/src/main.c
+++ b/tests/subsys/fs/nvs/src/main.c
@@ -91,7 +91,7 @@ static void execute_long_pattern_write(u
 
 	BUILD_ASSERT((sizeof(wr_buf) % sizeof(pattern)) == 0);
 	for (int i = 0; i < sizeof(wr_buf); i += sizeof(pattern)) {
-		memcpy(wr_buf + i, pattern, sizeof(pattern));
+		(void) memcpy(wr_buf + i, pattern, sizeof(pattern));
 	}
 
 	len = nvs_write(&fs, id, wr_buf, sizeof(wr_buf));
@@ -156,7 +156,7 @@ void test_nvs_corrupted_write(void)
 
 	BUILD_ASSERT((sizeof(wr_buf_1) % sizeof(pattern_1)) == 0);
 	for (int i = 0; i < sizeof(wr_buf_1); i += sizeof(pattern_1)) {
-		memcpy(wr_buf_1 + i, pattern_1, sizeof(pattern_1));
+		(void) memcpy(wr_buf_1 + i, pattern_1, sizeof(pattern_1));
 	}
 
 	len = nvs_write(&fs, TEST_DATA_ID, wr_buf_1, sizeof(wr_buf_1));
@@ -170,7 +170,7 @@ void test_nvs_corrupted_write(void)
 
 	BUILD_ASSERT((sizeof(wr_buf_2) % sizeof(pattern_2)) == 0);
 	for (int i = 0; i < sizeof(wr_buf_2); i += sizeof(pattern_2)) {
-		memcpy(wr_buf_2 + i, pattern_2, sizeof(pattern_2));
+		(void) memcpy(wr_buf_2 + i, pattern_2, sizeof(pattern_2));
 	}
 
 	/* Set the maximum number of writes that the flash simulator can
@@ -191,7 +191,7 @@ void test_nvs_corrupted_write(void)
 	zassert_true(len == sizeof(wr_buf_2), "nvs_write failed: %d", len);
 
 	/* Reinitialize the NVS. */
-	memset(&fs, 0, sizeof(fs));
+	(void) memset(&fs, 0, sizeof(fs));
 	test_nvs_init();
 
 	len = nvs_read(&fs, TEST_DATA_ID, rd_buf, sizeof(rd_buf));
@@ -225,7 +225,7 @@ void test_nvs_gc(void)
 		uint8_t id = (i % max_id);
 		uint8_t id_data = id + max_id * (i / max_id);
 
-		memset(buf, id_data, sizeof(buf));
+		(void) memset(buf, id_data, sizeof(buf));
 
 		len = nvs_write(&fs, id, buf, sizeof(buf));
 		zassert_true(len == sizeof(buf), "nvs_write failed: %d", len);
@@ -273,7 +273,7 @@ static void write_content(uint16_t max_i
 		uint8_t id = (i % max_id);
 		uint8_t id_data = id + max_id * (i / max_id);
 
-		memset(buf, id_data, sizeof(buf));
+		(void) memset(buf, id_data, sizeof(buf));
 
 		len = nvs_write(fs, id, buf, sizeof(buf));
 		zassert_true(len == sizeof(buf), "nvs_write failed: %d", len);
@@ -451,7 +451,7 @@ void test_nvs_corrupted_sector_close_ope
 		uint8_t id = (i % max_id);
 		uint8_t id_data = id + max_id * (i / max_id);
 
-		memset(buf, id_data, sizeof(buf));
+		(void) memset(buf, id_data, sizeof(buf));
 
 		if (i == max_writes - 1) {
 			/* Reset stats. */
diff -u -p a/tests/bluetooth/mesh/src/main.c b/tests/bluetooth/mesh/src/main.c
--- a/tests/bluetooth/mesh/src/main.c
+++ b/tests/bluetooth/mesh/src/main.c
@@ -50,7 +50,7 @@ static int fault_get_cur(struct bt_mesh_
 
 	*test_id = 0x00;
 	*company_id = BT_COMP_ID_LF;
-	memcpy(faults, reg_faults, sizeof(reg_faults));
+	(void) memcpy(faults, reg_faults, sizeof(reg_faults));
 	*fault_count = sizeof(reg_faults);
 
 	return 0;
@@ -70,7 +70,7 @@ static int fault_get_reg(struct bt_mesh_
 	if (has_reg_fault) {
 		uint8_t reg_faults[MAX_FAULT] = { [0 ... (MAX_FAULT - 1)] = 0xff };
 
-		memcpy(faults, reg_faults, sizeof(reg_faults));
+		(void) memcpy(faults, reg_faults, sizeof(reg_faults));
 		*fault_count = sizeof(reg_faults);
 	} else {
 		*fault_count = 0U;
diff -u -p a/tests/bluetooth/tester/src/gap.c b/tests/bluetooth/tester/src/gap.c
--- a/tests/bluetooth/tester/src/gap.c
+++ b/tests/bluetooth/tester/src/gap.c
@@ -44,7 +44,7 @@ static void le_connected(struct bt_conn 
 
 	bt_conn_get_info(conn, &info);
 
-	memcpy(ev.address, info.le.dst->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, info.le.dst->a.val, sizeof(ev.address));
 	ev.address_type = info.le.dst->type;
 	ev.interval = sys_cpu_to_le16(info.le.interval);
 	ev.latency = sys_cpu_to_le16(info.le.latency);
@@ -59,7 +59,7 @@ static void le_disconnected(struct bt_co
 	struct gap_device_disconnected_ev ev;
 	const bt_addr_le_t *addr = bt_conn_get_dst(conn);
 
-	memcpy(ev.address, addr->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, addr->a.val, sizeof(ev.address));
 	ev.address_type = addr->type;
 
 	tester_send(BTP_SERVICE_ID_GAP, GAP_EV_DEVICE_DISCONNECTED,
@@ -72,11 +72,11 @@ static void le_identity_resolved(struct 
 	struct gap_identity_resolved_ev ev;
 
 	ev.address_type = rpa->type;
-	memcpy(ev.address, rpa->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, rpa->a.val, sizeof(ev.address));
 
 	ev.identity_address_type = identity->type;
-	memcpy(ev.identity_address, identity->a.val,
-	       sizeof(ev.identity_address));
+	(void) memcpy(ev.identity_address, identity->a.val,
+			sizeof(ev.identity_address));
 
 	tester_send(BTP_SERVICE_ID_GAP, GAP_EV_IDENTITY_RESOLVED,
 		    CONTROLLER_INDEX, (uint8_t *) &ev, sizeof(ev));
@@ -88,7 +88,7 @@ static void le_param_updated(struct bt_c
 	struct gap_conn_param_update_ev ev;
 	const bt_addr_le_t *addr = bt_conn_get_dst(conn);
 
-	memcpy(ev.address, addr->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, addr->a.val, sizeof(ev.address));
 	ev.address_type = addr->type;
 	ev.interval = sys_cpu_to_le16(interval);
 	ev.latency = sys_cpu_to_le16(latency);
@@ -158,7 +158,7 @@ static void controller_info(uint8_t *dat
 	(void)memset(&rp, 0, sizeof(rp));
 
 	bt_le_oob_get_local(BT_ID_DEFAULT, &oob);
-	memcpy(rp.address, &oob.addr.a, sizeof(bt_addr_t));
+	(void) memcpy(rp.address, &oob.addr.a, sizeof(bt_addr_t));
 	/*
 	 * If privacy is used, the device uses random type address, otherwise
 	 * static random or public type address is used.
@@ -178,7 +178,7 @@ static void controller_info(uint8_t *dat
 	rp.supported_settings = sys_cpu_to_le32(supported_settings);
 	rp.current_settings = sys_cpu_to_le32(current_settings);
 
-	memcpy(rp.name, CONTROLLER_NAME, sizeof(CONTROLLER_NAME));
+	(void) memcpy(rp.name, CONTROLLER_NAME, sizeof(CONTROLLER_NAME));
 
 	tester_send(BTP_SERVICE_ID_GAP, GAP_READ_CONTROLLER_INFO,
 		    CONTROLLER_INDEX, (uint8_t *) &rp, sizeof(rp));
@@ -373,12 +373,12 @@ static void store_adv(const bt_addr_le_t
 
 	ev = net_buf_simple_add(adv_buf, sizeof(*ev));
 
-	memcpy(ev->address, addr->a.val, sizeof(ev->address));
+	(void) memcpy(ev->address, addr->a.val, sizeof(ev->address));
 	ev->address_type = addr->type;
 	ev->rssi = rssi;
 	ev->flags = GAP_DEVICE_FOUND_FLAG_AD | GAP_DEVICE_FOUND_FLAG_RSSI;
 	ev->eir_data_len = ad->len;
-	memcpy(net_buf_simple_add(adv_buf, ad->len), ad->data, ad->len);
+	(void) memcpy(net_buf_simple_add(adv_buf, ad->len), ad->data, ad->len);
 }
 
 static void device_found(const bt_addr_le_t *addr, int8_t rssi, uint8_t evtype,
@@ -416,7 +416,7 @@ static void device_found(const bt_addr_l
 
 		ev = (void *) adv_buf->data;
 		a.type = ev->address_type;
-		memcpy(a.a.val, ev->address, sizeof(a.a.val));
+		(void) memcpy(a.a.val, ev->address, sizeof(a.a.val));
 
 		/*
 		 * in general, the Scan Response comes right after the
@@ -431,7 +431,7 @@ static void device_found(const bt_addr_l
 		ev->eir_data_len += ad->len;
 		ev->flags |= GAP_DEVICE_FOUND_FLAG_SD;
 
-		memcpy(net_buf_simple_add(adv_buf, ad->len), ad->data, ad->len);
+		(void) memcpy(net_buf_simple_add(adv_buf, ad->len), ad->data, ad->len);
 
 		goto done;
 	}
@@ -555,7 +555,7 @@ static void auth_passkey_display(struct 
 	struct gap_passkey_display_ev ev;
 	const bt_addr_le_t *addr = bt_conn_get_dst(conn);
 
-	memcpy(ev.address, addr->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, addr->a.val, sizeof(ev.address));
 	ev.address_type = addr->type;
 	ev.passkey = sys_cpu_to_le32(passkey);
 
@@ -568,7 +568,7 @@ static void auth_passkey_entry(struct bt
 	struct gap_passkey_entry_req_ev ev;
 	const bt_addr_le_t *addr = bt_conn_get_dst(conn);
 
-	memcpy(ev.address, addr->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, addr->a.val, sizeof(ev.address));
 	ev.address_type = addr->type;
 
 	tester_send(BTP_SERVICE_ID_GAP, GAP_EV_PASSKEY_ENTRY_REQ,
@@ -580,7 +580,7 @@ static void auth_passkey_confirm(struct 
 	struct gap_passkey_confirm_req_ev ev;
 	const bt_addr_le_t *addr = bt_conn_get_dst(conn);
 
-	memcpy(ev.address, addr->a.val, sizeof(ev.address));
+	(void) memcpy(ev.address, addr->a.val, sizeof(ev.address));
 	ev.address_type = addr->type;
 	ev.passkey = sys_cpu_to_le32(passkey);
 
@@ -678,7 +678,7 @@ static void unpair(const uint8_t *data, 
 	int err;
 
 	addr.type = cmd->address_type;
-	memcpy(addr.a.val, cmd->address, sizeof(addr.a.val));
+	(void) memcpy(addr.a.val, cmd->address, sizeof(addr.a.val));
 
 	conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, &addr);
 	if (!conn) {
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_2_1.c
@@ -219,7 +219,7 @@ static ssize_t write_value_v2(struct bt_
 	if (offset + len > sizeof(value_v2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -271,7 +271,7 @@ static ssize_t write_long_des_v2d1(struc
 	if (offset + len > sizeof(long_des_v2d1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -301,7 +301,7 @@ static ssize_t write_value_v2_1(struct b
 	if (offset + len > sizeof(value_v2_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -353,7 +353,7 @@ static ssize_t write_long_des_v2d2(struc
 	if (offset + len > sizeof(long_des_v2d2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -383,7 +383,7 @@ static ssize_t write_value_v2_2(struct b
 	if (offset + len > sizeof(value_v2_2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -435,7 +435,7 @@ static ssize_t write_long_des_v2d3(struc
 	if (offset + len > sizeof(long_des_v2d3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -487,7 +487,7 @@ static ssize_t write_value_v2_3(struct b
 	if (offset + len > sizeof(value_v2_3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -539,7 +539,7 @@ static ssize_t write_long_des_v2d1_1(str
 	if (offset + len > sizeof(long_des_v2d1_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -591,7 +591,7 @@ static ssize_t write_value_v2_4(struct b
 	if (offset + len > sizeof(value_v2_4_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -643,7 +643,7 @@ static ssize_t write_long_des_v2d2_1(str
 	if (offset + len > sizeof(long_des_v2d2_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -695,7 +695,7 @@ static ssize_t write_value_v2_5(struct b
 	if (offset + len > sizeof(value_v2_5_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -747,7 +747,7 @@ static ssize_t write_long_des_v2d3_1(str
 	if (offset + len > sizeof(long_des_v2d3_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -777,7 +777,7 @@ static ssize_t write_value_v2_6(struct b
 	if (offset + len > sizeof(value_v2_6_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -829,7 +829,7 @@ static ssize_t write_long_des_v2d1_2(str
 	if (offset + len > sizeof(long_des_v2d1_2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -885,7 +885,7 @@ static ssize_t write_value_v2_7(struct b
 	if (!bAuthorized)
 		return BT_GATT_ERR(BT_ATT_ERR_AUTHORIZATION);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -942,7 +942,7 @@ static ssize_t write_long_des_v2d2_2(str
 	if (!bAuthorized)
 		return BT_GATT_ERR(BT_ATT_ERR_AUTHORIZATION);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -972,7 +972,7 @@ static ssize_t write_value_v2_8(struct b
 	if (offset + len > sizeof(value_v2_8_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -1024,7 +1024,7 @@ static ssize_t write_long_des_v2d3_2(str
 	if (offset + len > sizeof(long_des_v2d3_2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_2.c
@@ -52,7 +52,7 @@ static ssize_t write_value_v7(struct bt_
 	if (offset + len > sizeof(value_v7_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_2.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_2.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_2.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_c_1_2.c
@@ -98,7 +98,7 @@ static ssize_t write_value_v9__128_bit_u
 	if (offset + len > sizeof(value_v9__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -152,7 +152,7 @@ static ssize_t write_des_v9d2__128_bit_u
 	if (offset + len > sizeof(des_v9d2__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -183,7 +183,7 @@ static ssize_t write_des_v9d3__128_bit_u
 	if (offset + len > sizeof(des_v9d3__128_bit_uuid_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_b_4_1.c
@@ -52,7 +52,7 @@ static ssize_t write_value_v7(struct bt_
 	if (offset + len > sizeof(value_v7_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_a_1.c
@@ -157,7 +157,7 @@ static ssize_t write_value_v2(struct bt_
 	if (offset + len > sizeof(value_v2_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -187,7 +187,7 @@ static ssize_t write_value_v2_1(struct b
 	if (offset + len > sizeof(value_v2_1_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -216,7 +216,7 @@ static ssize_t write_value_v3(struct bt_
 	if (offset + len > sizeof(value_v3_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
diff -u -p a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_f_1.c b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_f_1.c
--- a/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_f_1.c
+++ b/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/gatt/service_f_1.c
@@ -154,7 +154,7 @@ static ssize_t write_value_v15(struct bt
 	if (offset + len > sizeof(value_v15_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 
 	return len;
 }
@@ -207,7 +207,7 @@ static ssize_t write_value_v6(struct bt_
 	if (offset + len > sizeof(value_v6_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy((uint8_t *)&value_v6_conv + offset, buf, len);
+	(void) memcpy((uint8_t *)&value_v6_conv + offset, buf, len);
 
 	*value = sys_le16_to_cpu(value_v6_conv);
 
@@ -262,7 +262,7 @@ static ssize_t write_value_v7(struct bt_
 	if (offset + len > sizeof(value_v7_value))
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 
-	memcpy((uint8_t *)&value_v7_conv + offset, buf, len);
+	(void) memcpy((uint8_t *)&value_v7_conv + offset, buf, len);
 
 	*value = sys_le32_to_cpu(value_v7_conv);
 
diff -u -p a/tests/benchmarks/mbedtls/src/benchmark.c b/tests/benchmarks/mbedtls/src/benchmark.c
--- a/tests/benchmarks/mbedtls/src/benchmark.c
+++ b/tests/benchmarks/mbedtls/src/benchmark.c
@@ -249,7 +249,7 @@ static int myrand(void *rng_state, unsig
 		}
 
 		rnd = sys_rand32_get();
-		memcpy(output, &rnd, use_len);
+		(void) memcpy(output, &rnd, use_len);
 		output += use_len;
 		len -= use_len;
 	}
@@ -306,10 +306,10 @@ void main(void)
 	mbedtls_ssl_conf_dbg(&conf, my_debug, NULL);
 
 	k_delayed_work_init(&mbedtls_alarm, mbedtls_alarm_timeout);
-	memset(&todo, 1, sizeof(todo));
+	(void) memset(&todo, 1, sizeof(todo));
 
-	memset(buf, 0xAA, sizeof(buf));
-	memset(tmp, 0xBB, sizeof(tmp));
+	(void) memset(buf, 0xAA, sizeof(buf));
+	(void) memset(tmp, 0xBB, sizeof(tmp));
 
 #if defined(MBEDTLS_MD4_C)
 	if (todo.md4) {
@@ -398,8 +398,8 @@ void main(void)
 		unsigned char output[8];
 		const mbedtls_cipher_info_t *cipher_info;
 
-		memset(buf, 0, sizeof(buf));
-		memset(tmp, 0, sizeof(tmp));
+		(void) memset(buf, 0, sizeof(buf));
+		(void) memset(tmp, 0, sizeof(tmp));
 
 		cipher_info = mbedtls_cipher_info_from_type(
 						MBEDTLS_CIPHER_DES_EDE3_ECB);
@@ -423,8 +423,8 @@ void main(void)
 			snprintk(title, sizeof(title),
 				 "AES-CBC-%d", keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 			mbedtls_aes_setkey_enc(&aes, tmp, keysize);
 
 			TIME_AND_TSC(title,
@@ -447,8 +447,8 @@ void main(void)
 			snprintk(title, sizeof(title),
 				 "AES-XTS-%d", keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 
 			mbedtls_aes_xts_setkey_enc(&ctx, tmp, keysize * 2);
 
@@ -472,8 +472,8 @@ void main(void)
 			snprintk(title, sizeof(title), "AES-GCM-%d",
 				 keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 			mbedtls_gcm_setkey(&gcm, MBEDTLS_CIPHER_ID_AES, tmp,
 					   keysize);
 
@@ -498,8 +498,8 @@ void main(void)
 			snprintk(title, sizeof(title), "AES-CCM-%d",
 				 keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 			mbedtls_ccm_setkey(&ccm, MBEDTLS_CIPHER_ID_AES, tmp,
 					   keysize);
 
@@ -518,8 +518,8 @@ void main(void)
 
 		mbedtls_chachapoly_init(&chachapoly);
 
-		memset(buf, 0, sizeof(buf));
-		memset(tmp, 0, sizeof(tmp));
+		(void) memset(buf, 0, sizeof(buf));
+		(void) memset(tmp, 0, sizeof(tmp));
 
 		snprintk(title, sizeof(title), "ChaCha20-Poly1305");
 
@@ -544,8 +544,8 @@ void main(void)
 			snprintk(title, sizeof(title), "AES-CMAC-%d",
 				 keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 
 			cipher_info = mbedtls_cipher_info_from_type(
 							cipher_type);
@@ -557,8 +557,8 @@ void main(void)
 							 output));
 		}
 
-		memset(buf, 0, sizeof(buf));
-		memset(tmp, 0, sizeof(tmp));
+		(void) memset(buf, 0, sizeof(buf));
+		(void) memset(tmp, 0, sizeof(tmp));
 
 		TIME_AND_TSC("AES-CMAC-PRF-128",
 			     mbedtls_aes_cmac_prf_128(tmp, 16, buf, BUFSIZE,
@@ -578,8 +578,8 @@ void main(void)
 			snprintk(title, sizeof(title),
 				 "ARIA-CBC-%d", keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 
 			mbedtls_aria_setkey_enc(&aria, tmp, keysize);
 
@@ -604,8 +604,8 @@ void main(void)
 			snprintk(title, sizeof(title),
 				 "CAMELLIA-CBC-%d", keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 
 			mbedtls_camellia_setkey_enc(&camellia, tmp, keysize);
 
@@ -647,8 +647,8 @@ void main(void)
 			snprintk(title, sizeof(title),
 				 "BLOWFISH-CBC-%d", keysize);
 
-			memset(buf, 0, sizeof(buf));
-			memset(tmp, 0, sizeof(tmp));
+			(void) memset(buf, 0, sizeof(buf));
+			(void) memset(tmp, 0, sizeof(tmp));
 
 			mbedtls_blowfish_setkey(&blowfish, tmp, keysize);
 
@@ -863,7 +863,7 @@ void main(void)
 		const mbedtls_ecp_curve_info *curve_info;
 		mbedtls_ecdsa_context ecdsa;
 
-		memset(buf, 0x2A, sizeof(buf));
+		(void) memset(buf, 0x2A, sizeof(buf));
 
 		for (curve_info = mbedtls_ecp_curve_list();
 		     curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
diff -u -p a/tests/lib/cmsis_dsp/distance/src/f32.c b/tests/lib/cmsis_dsp/distance/src/f32.c
--- a/tests/lib/cmsis_dsp/distance/src/f32.c
+++ b/tests/lib/cmsis_dsp/distance/src/f32.c
@@ -56,8 +56,8 @@ static void test_arm_distance(int op, bo
 
 		/* Load input values into the scratch buffers */
 		if (scratchy) {
-			memcpy(tmp1, input1, DIMS_VEC * sizeof(float32_t));
-			memcpy(tmp2, input2, DIMS_VEC * sizeof(float32_t));
+			(void) memcpy(tmp1, input1, DIMS_VEC * sizeof(float32_t));
+			(void) memcpy(tmp2, input2, DIMS_VEC * sizeof(float32_t));
 		}
 
 		/* Run test function */
diff -u -p a/tests/lib/cmsis_dsp/transform/src/rq15.c b/tests/lib/cmsis_dsp/transform/src/rq15.c
--- a/tests/lib/cmsis_dsp/transform/src/rq15.c
+++ b/tests/lib/cmsis_dsp/transform/src/rq15.c
@@ -50,7 +50,7 @@ static void test_arm_rfft_q15(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load input data into the scratch buffer */
-	memcpy(scratch, input, length * sizeof(q15_t));
+	(void) memcpy(scratch, input, length * sizeof(q15_t));
 
 	/* Run test function */
 	arm_rfft_q15(&inst, scratch, output);
@@ -131,7 +131,7 @@ static void test_arm_rifft_q15(
 	zassert_not_null(output, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load input data into the scratch buffer */
-	memcpy(scratch, input, length * sizeof(q15_t));
+	(void) memcpy(scratch, input, length * sizeof(q15_t));
 
 	/* Run test function */
 	arm_rfft_q15(&inst, scratch, output);
diff -u -p a/tests/lib/cmsis_dsp/transform/src/rf32.c b/tests/lib/cmsis_dsp/transform/src/rf32.c
--- a/tests/lib/cmsis_dsp/transform/src/rf32.c
+++ b/tests/lib/cmsis_dsp/transform/src/rf32.c
@@ -34,7 +34,7 @@ static void test_arm_rfft_f32_real_backe
 	zassert_not_null(scratch, ASSERT_MSG_BUFFER_ALLOC_FAILED);
 
 	/* Load data in place */
-	memcpy(scratch, input, length * sizeof(float32_t));
+	(void) memcpy(scratch, input, length * sizeof(float32_t));
 
 	/* Run test function */
 	arm_rfft_fast_f32(&inst, scratch, output, inverse);
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/binary_q15.c b/tests/lib/cmsis_dsp/matrix/src/binary_q15.c
--- a/tests/lib/cmsis_dsp/matrix/src/binary_q15.c
+++ b/tests/lib/cmsis_dsp/matrix/src/binary_q15.c
@@ -72,11 +72,11 @@ static void test_op2(int op, const q15_t
 		mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input1,
-		       rows * internal * sizeof(q15_t));
+		(void) memcpy(mat_in1.pData, input1,
+				rows * internal * sizeof(q15_t));
 
-		memcpy(mat_in2.pData, input2,
-		       internal * columns * sizeof(q15_t));
+		(void) memcpy(mat_in2.pData, input2,
+				internal * columns * sizeof(q15_t));
 
 		/* Run test function */
 		switch (op) {
@@ -161,11 +161,11 @@ static void test_op2c(int op, const q15_
 		mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input1,
-		       2 * rows * internal * sizeof(q15_t));
+		(void) memcpy(mat_in1.pData, input1,
+				2 * rows * internal * sizeof(q15_t));
 
-		memcpy(mat_in2.pData, input2,
-		       2 * internal * columns * sizeof(q15_t));
+		(void) memcpy(mat_in2.pData, input2,
+				2 * internal * columns * sizeof(q15_t));
 
 		/* Run test function */
 		switch (op) {
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/binary_f32.c b/tests/lib/cmsis_dsp/matrix/src/binary_f32.c
--- a/tests/lib/cmsis_dsp/matrix/src/binary_f32.c
+++ b/tests/lib/cmsis_dsp/matrix/src/binary_f32.c
@@ -67,11 +67,11 @@ static void test_op2(int op, const uint3
 		mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input1,
-		       rows * internal * sizeof(float32_t));
+		(void) memcpy(mat_in1.pData, input1,
+				rows * internal * sizeof(float32_t));
 
-		memcpy(mat_in2.pData, input2,
-		       internal * columns * sizeof(float32_t));
+		(void) memcpy(mat_in2.pData, input2,
+				internal * columns * sizeof(float32_t));
 
 		/* Run test function */
 		switch (op) {
@@ -152,11 +152,11 @@ static void test_op2c(int op, const uint
 		mat_out.numCols = columns;
 
 		/* Load matrix data */
-		memcpy(mat_in1.pData, input1,
-		       2 * rows * internal * sizeof(float32_t));
+		(void) memcpy(mat_in1.pData, input1,
+				2 * rows * internal * sizeof(float32_t));
 
-		memcpy(mat_in2.pData, input2,
-		       2 * internal * columns * sizeof(float32_t));
+		(void) memcpy(mat_in2.pData, input2,
+				2 * internal * columns * sizeof(float32_t));
 
 		/* Run test function */
 		switch (op) {
diff -u -p a/tests/kernel/pipe/pipe_api/src/test_pipe_contexts.c b/tests/kernel/pipe/pipe_api/src/test_pipe_contexts.c
--- a/tests/kernel/pipe/pipe_api/src/test_pipe_contexts.c
+++ b/tests/kernel/pipe/pipe_api/src/test_pipe_contexts.c
@@ -65,7 +65,7 @@ static void tpipe_block_put(struct k_pip
 		/**TESTPOINT: pipe block put*/
 		zassert_equal(k_mem_pool_alloc(&mpool, &block, BYTES_TO_WRITE,
 					       timeout), 0, NULL);
-		memcpy(block.data, &data[i], BYTES_TO_WRITE);
+		(void) memcpy(block.data, &data[i], BYTES_TO_WRITE);
 		k_pipe_block_put(ppipe, &block, BYTES_TO_WRITE, sema);
 		if (sema) {
 			k_sem_take(sema, K_FOREVER);
diff -u -p a/tests/kernel/mem_protect/syscalls/src/main.c b/tests/kernel/mem_protect/syscalls/src/main.c
--- a/tests/kernel/mem_protect/syscalls/src/main.c
+++ b/tests/kernel/mem_protect/syscalls/src/main.c
@@ -98,7 +98,7 @@ static inline int z_vrfy_string_copy(cha
  */
 int z_impl_to_copy(char *dest)
 {
-	memcpy(dest, kernel_string, BUF_SIZE);
+	(void) memcpy(dest, kernel_string, BUF_SIZE);
 	return 0;
 }
 
diff -u -p a/samples/net/sockets/net_mgmt/src/main.c b/samples/net/sockets/net_mgmt/src/main.c
--- a/samples/net/sockets/net_mgmt/src/main.c
+++ b/samples/net/sockets/net_mgmt/src/main.c
@@ -93,7 +93,7 @@ static void listener(void)
 		exit(1);
 	}
 
-	memset(&sockaddr, 0, sizeof(sockaddr));
+	(void) memset(&sockaddr, 0, sizeof(sockaddr));
 
 	sockaddr.nm_family = AF_NET_MGMT;
 	sockaddr.nm_ifindex = 0; /* Any network interface */
@@ -111,7 +111,7 @@ static void listener(void)
 	while (1) {
 		struct net_mgmt_msghdr *hdr;
 
-		memset(buf, 0, sizeof(buf));
+		(void) memset(buf, 0, sizeof(buf));
 		event_addr_len = sizeof(event_addr);
 
 		ret = recvfrom(fd, buf, sizeof(buf), 0,
diff -u -p a/samples/net/sockets/coap_server/src/coap-server.c b/samples/net/sockets/coap_server/src/coap-server.c
--- a/samples/net/sockets/coap_server/src/coap-server.c
+++ b/samples/net/sockets/coap_server/src/coap-server.c
@@ -107,7 +107,7 @@ static int start_coap_server(void)
 	struct sockaddr_in6 addr6;
 	int r;
 
-	memset(&addr6, 0, sizeof(addr6));
+	(void) memset(&addr6, 0, sizeof(addr6));
 	addr6.sin6_family = AF_INET6;
 	addr6.sin6_port = htons(MY_COAP_PORT);
 
@@ -133,7 +133,7 @@ static int start_coap_server(void)
 	struct sockaddr_in addr;
 	int r;
 
-	memset(&addr, 0, sizeof(addr));
+	(void) memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
 	addr.sin_port = htons(MY_COAP_PORT);
 
@@ -482,7 +482,7 @@ static int query_get(struct coap_resourc
 			break;
 		}
 
-		memcpy(str, options[i].value, options[i].len);
+		(void) memcpy(str, options[i].value, options[i].len);
 		str[options[i].len] = '\0';
 
 		LOG_INF("query[%d]: %s", i + 1, str);
@@ -754,7 +754,7 @@ static int large_get(struct coap_resourc
 	size = MIN(coap_block_size_to_bytes(ctx.block_size),
 		   ctx.total_size - ctx.current);
 
-	memset(payload, 'A', MIN(size, sizeof(payload)));
+	(void) memset(payload, 'A', MIN(size, sizeof(payload)));
 
 	r = coap_packet_append_payload(&response, (uint8_t *)payload, size);
 	if (r < 0) {
@@ -764,7 +764,7 @@ static int large_get(struct coap_resourc
 	r = coap_next_block(&response, &ctx);
 	if (!r) {
 		/* Will return 0 when it's the last block. */
-		memset(&ctx, 0, sizeof(ctx));
+		(void) memset(&ctx, 0, sizeof(ctx));
 	}
 
 	r = send_coap_reply(&response, addr, addr_len);
diff -u -p a/samples/net/sockets/civetweb/src/main.c b/samples/net/sockets/civetweb/src/main.c
--- a/samples/net/sockets/civetweb/src/main.c
+++ b/samples/net/sockets/civetweb/src/main.c
@@ -152,7 +152,7 @@ void *main_pthread(void *arg)
 
 	(void)arg;
 
-	memset(&callbacks, 0, sizeof(callbacks));
+	(void) memset(&callbacks, 0, sizeof(callbacks));
 	ctx = mg_start(&callbacks, 0, (const char **)options);
 
 	if (ctx == NULL) {
diff -u -p a/samples/drivers/led_ws2812/src/main.c b/samples/drivers/led_ws2812/src/main.c
--- a/samples/drivers/led_ws2812/src/main.c
+++ b/samples/drivers/led_ws2812/src/main.c
@@ -49,8 +49,8 @@ void main(void)
 
 	LOG_INF("Displaying pattern on strip");
 	while (1) {
-		memset(&pixels, 0x00, sizeof(pixels));
-		memcpy(&pixels[cursor], &colors[color], sizeof(struct led_rgb));
+		(void) memset(&pixels, 0x00, sizeof(pixels));
+		(void) memcpy(&pixels[cursor], &colors[color], sizeof(struct led_rgb));
 		rc = led_strip_update_rgb(strip, pixels, STRIP_NUM_PIXELS);
 
 		if (rc) {
diff -u -p a/samples/drivers/espi/src/main.c b/samples/drivers/espi/src/main.c
--- a/samples/drivers/espi/src/main.c
+++ b/samples/drivers/espi/src/main.c
@@ -435,7 +435,7 @@ static int espi_flash_test(uint32_t star
 	flash_addr = start_flash_addr;
 	pattern = 0x99;
 	for (i = 0; i <= blocks; i++) {
-		memset(flash_write_buf, pattern++, sizeof(flash_write_buf));
+		(void) memset(flash_write_buf, pattern++, sizeof(flash_write_buf));
 		ret = write_test_block(flash_write_buf, flash_addr,
 				       sizeof(flash_write_buf));
 		if (ret) {
@@ -451,9 +451,9 @@ static int espi_flash_test(uint32_t star
 	pattern = 0x99;
 	for (i = 0; i <= blocks; i++) {
 		/* Set expected content */
-		memset(flash_write_buf, pattern, sizeof(flash_write_buf));
+		(void) memset(flash_write_buf, pattern, sizeof(flash_write_buf));
 		/* Clear last read content */
-		memset(flash_read_buf, 0, sizeof(flash_read_buf));
+		(void) memset(flash_read_buf, 0, sizeof(flash_read_buf));
 		ret = read_test_block(flash_read_buf, flash_addr,
 				      sizeof(flash_read_buf));
 		if (ret) {
diff -u -p a/samples/subsys/settings/src/main.c b/samples/subsys/settings/src/main.c
--- a/samples/subsys/settings/src/main.c
+++ b/samples/subsys/settings/src/main.c
@@ -187,7 +187,7 @@ int beta_handle_get(const char *name, ch
 
 	if (settings_name_steq(name, "source", &next) && !next) {
 		val_len_max = MIN(val_len_max, strlen(source_name_val));
-		memcpy(val, source_name_val, val_len_max);
+		(void) memcpy(val, source_name_val, val_len_max);
 		return val_len_max;
 	}
 
diff -u -p a/samples/subsys/ipc/openamp_rsc_table/src/main_remote.c b/samples/subsys/ipc/openamp_rsc_table/src/main_remote.c
--- a/samples/subsys/ipc/openamp_rsc_table/src/main_remote.c
+++ b/samples/subsys/ipc/openamp_rsc_table/src/main_remote.c
@@ -76,7 +76,7 @@ static void platform_ipm_callback(const 
 static int rpmsg_recv_callback(struct rpmsg_endpoint *ept, void *data,
 			       size_t len, uint32_t src, void *priv)
 {
-	memcpy(rcv_msg, data, len);
+	(void) memcpy(rcv_msg, data, len);
 	rcv_len = len;
 	k_sem_give(&data_rx_sem);
 
diff -u -p a/samples/bluetooth/peripheral_csc/src/main.c b/samples/bluetooth/peripheral_csc/src/main.c
--- a/samples/bluetooth/peripheral_csc/src/main.c
+++ b/samples/bluetooth/peripheral_csc/src/main.c
@@ -238,7 +238,7 @@ static void ctrl_point_ind(struct bt_con
 
 	/* Send data (supported locations) if present */
 	if (data && data_len) {
-		memcpy(ind->data, data, data_len);
+		(void) memcpy(ind->data, data, data_len);
 	}
 
 	bt_gatt_notify(conn, &csc_svc.attrs[8], buf, sizeof(buf));
@@ -279,7 +279,7 @@ static void measurement_nfy(struct bt_co
 		data.cwr = sys_cpu_to_le32(cwr);
 		data.lwet = sys_cpu_to_le16(lwet);
 
-		memcpy(nfy->data, &data, sizeof(data));
+		(void) memcpy(nfy->data, &data, sizeof(data));
 		len += sizeof(data);
 	}
 
@@ -291,7 +291,7 @@ static void measurement_nfy(struct bt_co
 		data.ccr = sys_cpu_to_le16(ccr);
 		data.lcet = sys_cpu_to_le16(lcet);
 
-		memcpy(nfy->data + len, &data, sizeof(data));
+		(void) memcpy(nfy->data + len, &data, sizeof(data));
 	}
 
 	bt_gatt_notify(NULL, &csc_svc.attrs[1], buf, sizeof(buf));
diff -u -p a/samples/bluetooth/peripheral/src/cts.c b/samples/bluetooth/peripheral/src/cts.c
--- a/samples/bluetooth/peripheral/src/cts.c
+++ b/samples/bluetooth/peripheral/src/cts.c
@@ -49,7 +49,7 @@ static ssize_t write_ct(struct bt_conn *
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
 	}
 
-	memcpy(value + offset, buf, len);
+	(void) memcpy(value + offset, buf, len);
 	ct_update = 1U;
 
 	return len;
@@ -75,7 +75,7 @@ static void generate_current_time(uint8_
 	 */
 
 	year = sys_cpu_to_le16(2015);
-	memcpy(buf,  &year, 2); /* year */
+	(void) memcpy(buf,  &year, 2); /* year */
 	buf[2] = 5U; /* months starting from 1 */
 	buf[3] = 30U; /* day */
 	buf[4] = 12U; /* hours */
diff -u -p a/samples/boards/reel_board/mesh_badge/src/main.c b/samples/boards/reel_board/mesh_badge/src/main.c
--- a/samples/boards/reel_board/mesh_badge/src/main.c
+++ b/samples/boards/reel_board/mesh_badge/src/main.c
@@ -46,7 +46,7 @@ static ssize_t write_name(struct bt_conn
 		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
 	}
 
-	memcpy(name, buf, len);
+	(void) memcpy(name, buf, len);
 	name[len] = '\0';
 
 	err = bt_set_name(name);
diff -u -p a/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c b/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c
--- a/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c
+++ b/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c
@@ -111,7 +111,7 @@ static void tun_drv_process_command(uint
 
 	if (len) {
 		/* copy the received data into the tuning packet buffer */
-		memcpy(&command_buffer.buffer[command_buffer.index], data, len);
+		(void) memcpy(&command_buffer.buffer[command_buffer.index], data, len);
 		command_buffer.index += len;
 	}
 
diff -u -p a/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/ble_mesh.c b/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/ble_mesh.c
--- a/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/ble_mesh.c
+++ b/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/ble_mesh.c
@@ -72,7 +72,7 @@ void bt_ready(void)
 	if (bt_le_oob_get_local(BT_ID_DEFAULT, &oob)) {
 		printk("Identity Address unavailable\n");
 	} else {
-		memcpy(dev_uuid, oob.addr.a.val, 6);
+		(void) memcpy(dev_uuid, oob.addr.a.val, 6);
 	}
 
 	bt_mesh_prov_enable(BT_MESH_PROV_GATT | BT_MESH_PROV_ADV);
diff -u -p a/arch/arm/core/aarch32/cortex_a_r/stacks.c b/arch/arm/core/aarch32/cortex_a_r/stacks.c
--- a/arch/arm/core/aarch32/cortex_a_r/stacks.c
+++ b/arch/arm/core/aarch32/cortex_a_r/stacks.c
@@ -18,11 +18,11 @@ K_KERNEL_STACK_DEFINE(z_arm_sys_stack,  
 #if defined(CONFIG_INIT_STACKS)
 void z_arm_init_stacks(void)
 {
-	memset(z_arm_fiq_stack, 0xAA, CONFIG_ARMV7_FIQ_STACK_SIZE);
-	memset(z_arm_svc_stack, 0xAA, CONFIG_ARMV7_SVC_STACK_SIZE);
-	memset(z_arm_abort_stack, 0xAA, CONFIG_ARMV7_EXCEPTION_STACK_SIZE);
-	memset(z_arm_undef_stack, 0xAA, CONFIG_ARMV7_EXCEPTION_STACK_SIZE);
-	memset(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0]), 0xAA,
-	       K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[0]));
+	(void) memset(z_arm_fiq_stack, 0xAA, CONFIG_ARMV7_FIQ_STACK_SIZE);
+	(void) memset(z_arm_svc_stack, 0xAA, CONFIG_ARMV7_SVC_STACK_SIZE);
+	(void) memset(z_arm_abort_stack, 0xAA, CONFIG_ARMV7_EXCEPTION_STACK_SIZE);
+	(void) memset(z_arm_undef_stack, 0xAA, CONFIG_ARMV7_EXCEPTION_STACK_SIZE);
+	(void) memset(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0]), 0xAA,
+			K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[0]));
 }
 #endif
diff -u -p a/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c b/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c
--- a/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c
+++ b/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c
@@ -89,7 +89,7 @@ static int remoteproc_mgr_boot(const str
 	 * assumed that the application image has access to the shared
 	 * memory at this point (see #24147).
 	 */
-	memset((void *) SHM_BASE_ADDRESS, 0, SHM_SIZE);
+	(void) memset((void *) SHM_BASE_ADDRESS, 0, SHM_SIZE);
 #endif
 
 	/* Release the Network MCU, 'Release force off signal' */
diff -u -p a/lib/cmsis_rtos_v2/event_flags.c b/lib/cmsis_rtos_v2/event_flags.c
--- a/lib/cmsis_rtos_v2/event_flags.c
+++ b/lib/cmsis_rtos_v2/event_flags.c
@@ -38,7 +38,7 @@ osEventFlagsId_t osEventFlagsNew(const o
 
 	if (k_mem_slab_alloc(&cv2_event_flags_slab, (void **)&events, K_MSEC(100))
 	    == 0) {
-		memset(events, 0, sizeof(struct cv2_event_flags));
+		(void) memset(events, 0, sizeof(struct cv2_event_flags));
 	} else {
 		return NULL;
 	}
-------------------------------------------------------------------------

Processing int_ms_to_timeout.cocci
with option(s) " --include-headers"

Message example to submit a patch:
 The semantic patch that makes this report is available
 in scripts/coccinelle//int_ms_to_timeout.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//int_ms_to_timeout.cocci --include-headers --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
-------------------------------------------------------------------------

Invalid mode "report" supplied!
Available modes for "irq_lock.cocci" are: patch
Using random available mode: "patch"

Processing irq_lock.cocci
with option(s) ""

Message example to submit a patch:
 Use unsigned int as the return value for irq_lock()

 The semantic patch that makes this change is available
 in scripts/coccinelle//irq_lock.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D patch --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//irq_lock.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
diff -u -p a/drivers/ieee802154/ieee802154_kw41z.c b/drivers/ieee802154/ieee802154_kw41z.c
--- a/drivers/ieee802154/ieee802154_kw41z.c
+++ b/drivers/ieee802154/ieee802154_kw41z.c
@@ -204,7 +204,7 @@ static inline void kw41z_wait_for_idle(v
 
 static void kw41z_phy_abort(void)
 {
-	int key;
+	unsigned int key;
 
 	key = irq_lock();
 
@@ -620,7 +620,7 @@ static int kw41z_tx(const struct device 
 	uint8_t payload_len = frag->len;
 	uint32_t tx_timeout;
 	uint8_t xcvseq;
-	int key;
+	unsigned int key;
 
 	if (mode != IEEE802154_TX_MODE_DIRECT) {
 		NET_ERR("TX mode %d not supported", mode);
diff -u -p a/drivers/timer/sam0_rtc_timer.c b/drivers/timer/sam0_rtc_timer.c
--- a/drivers/timer/sam0_rtc_timer.c
+++ b/drivers/timer/sam0_rtc_timer.c
@@ -293,7 +293,7 @@ void z_clock_set_timeout(int32_t ticks, 
 	/* Avoid race condition between reading counter and ISR incrementing
 	 * it.
 	 */
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	rtc_timeout = rtc_counter + ticks;
 	irq_unlock(key);
diff -u -p a/drivers/ethernet/eth_liteeth.c b/drivers/ethernet/eth_liteeth.c
--- a/drivers/ethernet/eth_liteeth.c
+++ b/drivers/ethernet/eth_liteeth.c
@@ -83,7 +83,7 @@ static int eth_initialize(const struct d
 
 static int eth_tx(const struct device *dev, struct net_pkt *pkt)
 {
-	int key;
+	unsigned int key;
 	uint16_t len;
 	struct eth_liteeth_dev_data *context = dev->data;
 
diff -u -p a/drivers/modem/hl7800.c b/drivers/modem/hl7800.c
--- a/drivers/modem/hl7800.c
+++ b/drivers/modem/hl7800.c
@@ -4069,7 +4069,7 @@ int32_t mdm_hl7800_power_off(void)
 
 void mdm_hl7800_register_event_callback(mdm_hl7800_event_callback_t cb)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	ictx.event_callback = cb;
 	irq_unlock(key);
diff -u -p a/drivers/serial/uart_nrfx_uarte.c b/drivers/serial/uart_nrfx_uarte.c
--- a/drivers/serial/uart_nrfx_uarte.c
+++ b/drivers/serial/uart_nrfx_uarte.c
@@ -579,7 +579,7 @@ static int uarte_nrfx_rx_buf_rsp(const s
 	struct uarte_nrfx_data *data = get_dev_data(dev);
 	int err;
 	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if ((data->async->rx_buf == NULL)) {
 		err = -EACCES;
@@ -849,7 +849,7 @@ static void endrx_isr(const struct devic
 	 * and here we just do the swap of which buffer the driver is following,
 	 * the next rx_timeout() will update the rx_offset.
 	 */
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (data->async->rx_next_buf) {
 		data->async->rx_buf = data->async->rx_next_buf;
diff -u -p a/subsys/net/lib/sockets/socketpair.c b/subsys/net/lib/sockets/socketpair.c
--- a/subsys/net/lib/sockets/socketpair.c
+++ b/subsys/net/lib/sockets/socketpair.c
@@ -382,7 +382,7 @@ out:
 static ssize_t spair_write(void *obj, const void *buffer, size_t count)
 {
 	int res;
-	int key;
+	unsigned int key;
 	size_t avail;
 	bool is_nonblock;
 	size_t bytes_written;
@@ -586,7 +586,7 @@ out:
 static ssize_t spair_read(void *obj, void *buffer, size_t count)
 {
 	int res;
-	int key;
+	unsigned int key;
 	bool is_connected;
 	size_t avail;
 	bool is_nonblock;
diff -u -p a/tests/arch/xtensa_asm2/src/main.c b/tests/arch/xtensa_asm2/src/main.c
--- a/tests/arch/xtensa_asm2/src/main.c
+++ b/tests/arch/xtensa_asm2/src/main.c
@@ -513,7 +513,7 @@ void main(void)
 	 * interrupt which is not masked by irq_lock(), so it doesn't
 	 * care).
 	 */
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	/* Strictly not a "test", we just want to know that the jump
 	 * worked.  If the rest of the code runs, this must have
diff -u -p a/drivers/hwinfo/hwinfo_sam.c b/drivers/hwinfo/hwinfo_sam.c
--- a/drivers/hwinfo/hwinfo_sam.c
+++ b/drivers/hwinfo/hwinfo_sam.c
@@ -66,7 +66,7 @@ static int hwinfo_sam_init(const struct 
 {
 	Efc *efc = (Efc *)DT_REG_ADDR(DT_INST(0, atmel_sam_flash_controller));
 	uint32_t fmr;
-	int key;
+	unsigned int key;
 
 	/* Disable interrupts. */
 	key = irq_lock();
diff -u -p a/drivers/timer/litex_timer.c b/drivers/timer/litex_timer.c
--- a/drivers/timer/litex_timer.c
+++ b/drivers/timer/litex_timer.c
@@ -31,7 +31,7 @@
 static void litex_timer_irq_handler(const void *device)
 {
 	ARG_UNUSED(device);
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	sys_write8(TIMER_EV, TIMER_EV_PENDING_ADDR);
 	z_clock_announce(1);
diff -u -p a/drivers/counter/counter_sam0_tc32.c b/drivers/counter/counter_sam0_tc32.c
--- a/drivers/counter/counter_sam0_tc32.c
+++ b/drivers/counter/counter_sam0_tc32.c
@@ -195,7 +195,7 @@ static int counter_sam0_tc32_set_alarm(c
 		return -EINVAL;
 	}
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (data->ch.callback) {
 		irq_unlock(key);
@@ -226,7 +226,7 @@ static int counter_sam0_tc32_cancel_alar
 	const struct counter_sam0_tc32_config *const cfg = DEV_CFG(dev);
 	TcCount32 *tc = cfg->regs;
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	ARG_UNUSED(chan_id);
 
@@ -245,7 +245,7 @@ static int counter_sam0_tc32_set_top_val
 	const struct counter_sam0_tc32_config *const cfg = DEV_CFG(dev);
 	TcCount32 *tc = cfg->regs;
 	int err = 0;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (data->ch.callback) {
 		irq_unlock(key);
diff -u -p a/drivers/serial/uart_liteuart.c b/drivers/serial/uart_liteuart.c
--- a/drivers/serial/uart_liteuart.c
+++ b/drivers/serial/uart_liteuart.c
@@ -275,7 +275,7 @@ static void uart_liteuart_irq_callback_s
 static void liteuart_uart_irq_handler(const struct device *dev)
 {
 	struct uart_liteuart_data *data = DEV_DATA(dev);
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (data->callback) {
 		data->callback(dev, data->cb_data);
diff -u -p a/subsys/net/l2/ethernet/gptp/gptp_mi.c b/subsys/net/l2/ethernet/gptp/gptp_mi.c
--- a/subsys/net/l2/ethernet/gptp/gptp_mi.c
+++ b/subsys/net/l2/ethernet/gptp/gptp_mi.c
@@ -744,7 +744,7 @@ static void gptp_update_local_port_clock
 	int64_t second_diff;
 	const struct device *clk;
 	struct net_ptp_time tm;
-	int key;
+	unsigned int key;
 
 	state = &GPTP_STATE()->clk_slave_sync;
 	global_ds = GPTP_GLOBAL_DS();
diff -u -p a/tests/arch/arm/arm_interrupt/src/arm_interrupt.c b/tests/arch/arm/arm_interrupt/src/arm_interrupt.c
--- a/tests/arch/arm/arm_interrupt/src/arm_interrupt.c
+++ b/tests/arch/arm/arm_interrupt/src/arm_interrupt.c
@@ -394,7 +394,7 @@ void z_impl_test_arm_user_interrupt_sysc
 		first_call = 0;
 
 		/* Lock IRQs in supervisor mode */
-		int key = irq_lock();
+		unsigned int key = irq_lock();
 
 		/* Verify that IRQs were not already locked */
 		zassert_false(key, "IRQs locked in system call\n");
@@ -422,7 +422,7 @@ void test_arm_user_interrupt(void)
 	/* Attempt to lock again should return non-zero value of previous
 	 * locking attempt, if that were to be successful.
 	 */
-	int lock = irq_lock();
+	unsigned int lock = irq_lock();
 
 	zassert_false(lock, "IRQs shown locked in user mode\n");
 
diff -u -p a/lib/cmsis_rtos_v2/event_flags.c b/lib/cmsis_rtos_v2/event_flags.c
--- a/lib/cmsis_rtos_v2/event_flags.c
+++ b/lib/cmsis_rtos_v2/event_flags.c
@@ -64,7 +64,7 @@ osEventFlagsId_t osEventFlagsNew(const o
 uint32_t osEventFlagsSet(osEventFlagsId_t ef_id, uint32_t flags)
 {
 	struct cv2_event_flags *events = (struct cv2_event_flags *)ef_id;
-	int key;
+	unsigned int key;
 
 	if ((ef_id == NULL) || (flags & 0x80000000)) {
 		return osFlagsErrorParameter;
@@ -85,7 +85,7 @@ uint32_t osEventFlagsSet(osEventFlagsId_
 uint32_t osEventFlagsClear(osEventFlagsId_t ef_id, uint32_t flags)
 {
 	struct cv2_event_flags *events = (struct cv2_event_flags *)ef_id;
-	int key;
+	unsigned int key;
 	uint32_t sig;
 
 	if ((ef_id == NULL) || (flags & 0x80000000)) {
diff -u -p a/drivers/clock_control/clock_control_nrf.c b/drivers/clock_control/clock_control_nrf.c
--- a/drivers/clock_control/clock_control_nrf.c
+++ b/drivers/clock_control/clock_control_nrf.c
@@ -125,7 +125,7 @@ static enum clock_control_status get_sta
 static int set_off_state(uint32_t *flags, uint32_t ctx)
 {
 	int err = 0;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 	uint32_t current_ctx = GET_CTX(*flags);
 
 	if ((current_ctx != 0) && (current_ctx != ctx)) {
@@ -142,7 +142,7 @@ static int set_off_state(uint32_t *flags
 static int set_starting_state(uint32_t *flags, uint32_t ctx)
 {
 	int err = 0;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 	uint32_t current_ctx = GET_CTX(*flags);
 
 	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
@@ -160,7 +160,7 @@ static int set_starting_state(uint32_t *
 
 static void set_on_state(uint32_t *flags)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
 	irq_unlock(key);
@@ -254,7 +254,7 @@ static void generic_hfclk_start(void)
 {
 	nrf_clock_hfclk_t type;
 	bool already_started = false;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	hfclk_users |= HF_USER_GENERIC;
 	if (hfclk_users & HF_USER_BT) {
@@ -608,7 +608,7 @@ static int cmd_status(const struct shell
 				get_onoff_manager(DEVICE_GET(clock_nrf),
 						  CLOCK_CONTROL_NRF_TYPE_LFCLK);
 	uint32_t abs_start, abs_stop;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 	uint64_t now = k_uptime_get();
 
 	(void)nrfx_clock_is_running(NRF_CLOCK_DOMAIN_HFCLK, (void *)&hfclk_src);
diff -u -p a/drivers/ethernet/eth_mcux.c b/drivers/ethernet/eth_mcux.c
--- a/drivers/ethernet/eth_mcux.c
+++ b/drivers/ethernet/eth_mcux.c
@@ -1227,7 +1227,7 @@ static void eth_mcux_dispacher_isr(const
 {
 	struct eth_context *context = dev->data;
 	uint32_t EIR = ENET_GetInterruptStatus(context->base);
-	int irq_lock_key = irq_lock();
+	unsigned int irq_lock_key = irq_lock();
 
 	if (EIR & (kENET_RxBufferInterrupt | kENET_RxFrameInterrupt)) {
 		ENET_ReceiveIRQHandler(context->base, &context->enet_handle);
diff -u -p a/drivers/dma/dma_mcux_edma.c b/drivers/dma/dma_mcux_edma.c
--- a/drivers/dma/dma_mcux_edma.c
+++ b/drivers/dma/dma_mcux_edma.c
@@ -194,7 +194,7 @@ static int dma_mcux_edma_configure(const
 	struct dma_block_config *block_config = config->head_block;
 	uint32_t slot = config->dma_slot;
 	edma_transfer_type_t transfer_type;
-	int key;
+	unsigned int key;
 
 	if (NULL == dev || NULL == config) {
 		return -EINVAL;
diff -u -p a/drivers/serial/uart_nrfx_uart.c b/drivers/serial/uart_nrfx_uart.c
--- a/drivers/serial/uart_nrfx_uart.c
+++ b/drivers/serial/uart_nrfx_uart.c
@@ -500,7 +500,7 @@ static int uart_nrfx_rx_buf_rsp(const st
 				size_t len)
 {
 	int err;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (!uart0_cb.rx_enabled) {
 		err = -EACCES;
@@ -608,7 +608,7 @@ static void rx_isr(const struct device *
 		}
 		rx_rdy_evt(dev);
 
-		int key = irq_lock();
+		unsigned int key = irq_lock();
 
 		if (uart0_cb.rx_secondary_buffer_length == 0) {
 			uart0_cb.rx_enabled = 0;
diff -u -p a/tests/kernel/interrupt/src/prevent_irq.c b/tests/kernel/interrupt/src/prevent_irq.c
--- a/tests/kernel/interrupt/src/prevent_irq.c
+++ b/tests/kernel/interrupt/src/prevent_irq.c
@@ -32,7 +32,7 @@ static void timer_handler(struct k_timer
  */
 void test_prevent_interruption(void)
 {
-	int key;
+	unsigned int key;
 
 	printk("locking interrupts\n");
 	key = irq_lock();
diff -u -p a/samples/userspace/prod_consumer/src/sample_driver_foo.c b/samples/userspace/prod_consumer/src/sample_driver_foo.c
--- a/samples/userspace/prod_consumer/src/sample_driver_foo.c
+++ b/samples/userspace/prod_consumer/src/sample_driver_foo.c
@@ -43,7 +43,7 @@ static int sample_driver_foo_set_callbac
 					  void *context)
 {
 	struct sample_driver_foo_dev_data *data = DEV_DATA(dev);
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	data->cb_context = context;
 	data->cb = cb;
diff -u -p a/lib/posix/pthread_cond.c b/lib/posix/pthread_cond.c
--- a/lib/posix/pthread_cond.c
+++ b/lib/posix/pthread_cond.c
@@ -49,7 +49,7 @@ static int cond_wait(pthread_cond_t *cv,
 
 int pthread_cond_signal(pthread_cond_t *cv)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	_ready_one_thread(&cv->wait_q);
 	z_reschedule_irqlock(key);
@@ -59,7 +59,7 @@ int pthread_cond_signal(pthread_cond_t *
 
 int pthread_cond_broadcast(pthread_cond_t *cv)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	while (z_waitq_head(&cv->wait_q)) {
 		_ready_one_thread(&cv->wait_q);
diff -u -p a/drivers/interrupt_controller/intc_sam0_eic.c b/drivers/interrupt_controller/intc_sam0_eic.c
--- a/drivers/interrupt_controller/intc_sam0_eic.c
+++ b/drivers/interrupt_controller/intc_sam0_eic.c
@@ -109,7 +109,7 @@ int sam0_eic_acquire(int port, int pin, 
 	int line_index;
 	int config_index;
 	int config_shift;
-	int key;
+	unsigned int key;
 	uint32_t config;
 
 	line_index = sam0_eic_map_to_line(port, pin);
@@ -216,7 +216,7 @@ int sam0_eic_release(int port, int pin)
 	int line_index;
 	int config_index;
 	int config_shift;
-	int key;
+	unsigned int key;
 
 	line_index = sam0_eic_map_to_line(port, pin);
 	if (line_index < 0) {
diff -u -p a/drivers/i2c/i2c_sam0.c b/drivers/i2c/i2c_sam0.c
--- a/drivers/i2c/i2c_sam0.c
+++ b/drivers/i2c/i2c_sam0.c
@@ -191,7 +191,7 @@ static void i2c_sam0_dma_write_done(cons
 	ARG_UNUSED(dma_dev);
 	ARG_UNUSED(id);
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (i2c_sam0_terminate_on_error(dev)) {
 		irq_unlock(key);
@@ -286,7 +286,7 @@ static void i2c_sam0_dma_read_done(const
 	ARG_UNUSED(dma_dev);
 	ARG_UNUSED(id);
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (i2c_sam0_terminate_on_error(dev)) {
 		irq_unlock(key);
@@ -425,7 +425,7 @@ static int i2c_sam0_transfer(const struc
 #endif
 		}
 
-		int key = irq_lock();
+		unsigned int key = irq_lock();
 
 		/*
 		 * Writing the address starts the transaction, issuing
diff -u -p a/drivers/dma/dma_sam0.c b/drivers/dma/dma_sam0.c
--- a/drivers/dma/dma_sam0.c
+++ b/drivers/dma/dma_sam0.c
@@ -70,7 +70,7 @@ static int dma_sam0_config(const struct 
 	struct dma_block_config *block = config->head_block;
 	struct dma_sam0_channel *channel_control;
 	DMAC_BTCTRL_Type btctrl = { .reg = 0 };
-	int key;
+	unsigned int key;
 
 	if (channel >= DMAC_CH_NUM) {
 		LOG_ERR("Unsupported channel");
@@ -266,7 +266,7 @@ inval:
 
 static int dma_sam0_start(const struct device *dev, uint32_t channel)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	ARG_UNUSED(dev);
 
@@ -297,7 +297,7 @@ static int dma_sam0_start(const struct d
 
 static int dma_sam0_stop(const struct device *dev, uint32_t channel)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	ARG_UNUSED(dev);
 
@@ -320,7 +320,7 @@ static int dma_sam0_reload(const struct 
 {
 	struct dma_sam0_data *data = DEV_DATA(dev);
 	DmacDescriptor *desc = &data->descriptors[channel];
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	switch (desc->BTCTRL.bit.BEATSIZE) {
 	case DMAC_BTCTRL_BEATSIZE_BYTE_Val:
diff -u -p a/drivers/serial/uart_sam0.c b/drivers/serial/uart_sam0.c
--- a/drivers/serial/uart_sam0.c
+++ b/drivers/serial/uart_sam0.c
@@ -133,7 +133,7 @@ static void uart_sam0_dma_tx_done(const 
 
 	k_delayed_work_cancel(&dev_data->tx_timeout_work);
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	struct uart_event evt = {
 		.type = UART_TX_DONE,
@@ -156,7 +156,7 @@ static void uart_sam0_dma_tx_done(const 
 static int uart_sam0_tx_halt(struct uart_sam0_dev_data *dev_data)
 {
 	const struct uart_sam0_dev_cfg *const cfg = dev_data->cfg;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 	size_t tx_active = dev_data->tx_len;
 	struct dma_status st;
 
@@ -237,7 +237,7 @@ static void uart_sam0_dma_rx_done(const 
 	const struct device *dev = dev_data->dev;
 	const struct uart_sam0_dev_cfg *const cfg = dev_data->cfg;
 	SercomUsart * const regs = cfg->regs;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (dev_data->rx_len == 0U) {
 		irq_unlock(key);
@@ -316,7 +316,7 @@ static void uart_sam0_rx_timeout(struct 
 	const struct uart_sam0_dev_cfg *const cfg = dev_data->cfg;
 	SercomUsart * const regs = cfg->regs;
 	struct dma_status st;
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (dev_data->rx_len == 0U) {
 		irq_unlock(key);
@@ -834,7 +834,7 @@ static int uart_sam0_tx(const struct dev
 		return -EINVAL;
 	}
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (dev_data->tx_len != 0U) {
 		retval = -EBUSY;
@@ -894,7 +894,7 @@ static int uart_sam0_rx_enable(const str
 		return -EINVAL;
 	}
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (dev_data->rx_len != 0U) {
 		retval = -EBUSY;
@@ -941,7 +941,7 @@ static int uart_sam0_rx_buf_rsp(const st
 	}
 
 	struct uart_sam0_dev_data *const dev_data = DEV_DATA(dev);
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 	int retval = 0;
 
 	if (dev_data->rx_len == 0U) {
@@ -974,7 +974,7 @@ static int uart_sam0_rx_disable(const st
 
 	k_delayed_work_cancel(&dev_data->rx_timeout_work);
 
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (dev_data->rx_len == 0U) {
 		irq_unlock(key);
diff -u -p a/subsys/tracing/cpu_stats.c b/subsys/tracing/cpu_stats.c
--- a/subsys/tracing/cpu_stats.c
+++ b/subsys/tracing/cpu_stats.c
@@ -59,7 +59,7 @@ static void cpu_stats_update_counters(vo
 
 void cpu_stats_get_ns(struct cpu_stats *cpu_stats_ns)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	cpu_stats_update_counters();
 	cpu_stats_ns->idle = k_cyc_to_ns_floor64(stats_hw_tick.idle);
@@ -70,7 +70,7 @@ void cpu_stats_get_ns(struct cpu_stats *
 
 uint32_t cpu_stats_non_idle_and_sched_get_percent(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	cpu_stats_update_counters();
 	irq_unlock(key);
@@ -81,7 +81,7 @@ uint32_t cpu_stats_non_idle_and_sched_ge
 
 void cpu_stats_reset_counters(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	stats_hw_tick.idle = 0;
 	stats_hw_tick.non_idle = 0;
@@ -92,7 +92,7 @@ void cpu_stats_reset_counters(void)
 
 void sys_trace_thread_switched_in(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	__ASSERT_NO_MSG(nested_interrupts == 0);
 
@@ -108,7 +108,7 @@ void sys_trace_thread_switched_in(void)
 
 void sys_trace_thread_switched_out(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	__ASSERT_NO_MSG(nested_interrupts == 0);
 	__ASSERT_NO_MSG(!current_thread || (current_thread == k_current_get()));
@@ -120,7 +120,7 @@ void sys_trace_thread_switched_out(void)
 
 void sys_trace_isr_enter(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	if (nested_interrupts == 0) {
 		cpu_stats_update_counters();
@@ -133,7 +133,7 @@ void sys_trace_isr_enter(void)
 
 void sys_trace_isr_exit(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	nested_interrupts--;
 	if (nested_interrupts == 0) {
diff -u -p a/tests/drivers/clock_control/clock_control_api/src/test_clock_control.c b/tests/drivers/clock_control/clock_control_api/src/test_clock_control.c
--- a/tests/drivers/clock_control/clock_control_api/src/test_clock_control.c
+++ b/tests/drivers/clock_control/clock_control_api/src/test_clock_control.c
@@ -267,7 +267,7 @@ static void test_async_on_stopped_on_ins
 	const struct device *dev = device_get_binding(dev_name);
 	enum clock_control_status status;
 	int err;
-	int key;
+	unsigned int key;
 	bool executed = false;
 	struct clock_control_async_data data = {
 		.cb = clock_on_callback,
diff -u -p a/tests/kernel/mem_protect/userspace/src/main.c b/tests/kernel/mem_protect/userspace/src/main.c
--- a/tests/kernel/mem_protect/userspace/src/main.c
+++ b/tests/kernel/mem_protect/userspace/src/main.c
@@ -938,7 +938,7 @@ void test_oops_stackcheck(void)
 
 void z_impl_check_syscall_context(void)
 {
-	int key = irq_lock();
+	unsigned int key = irq_lock();
 
 	irq_unlock(key);
 
diff -u -p a/arch/x86/core/ia32/irq_manage.c b/arch/x86/core/ia32/irq_manage.c
--- a/arch/x86/core/ia32/irq_manage.c
+++ b/arch/x86/core/ia32/irq_manage.c
@@ -188,7 +188,7 @@ extern const struct pseudo_descriptor z_
 
 static void idt_vector_install(int vector, void *irq_handler)
 {
-	int key;
+	unsigned int key;
 
 	key = irq_lock();
 	z_init_irq_gate(&z_x86_idt.entries[vector], CODE_SEG,
diff -u -p a/lib/cmsis_rtos_v2/thread_flags.c b/lib/cmsis_rtos_v2/thread_flags.c
--- a/lib/cmsis_rtos_v2/thread_flags.c
+++ b/lib/cmsis_rtos_v2/thread_flags.c
@@ -15,7 +15,7 @@
  */
 uint32_t osThreadFlagsSet(osThreadId_t thread_id, uint32_t flags)
 {
-	int key;
+	unsigned int key;
 	struct cv2_thread *tid = (struct cv2_thread *)thread_id;
 
 	if ((thread_id == NULL) || (is_cmsis_rtos_v2_thread(thread_id) == NULL)
-------------------------------------------------------------------------

Processing mini_lock.cocci
with option(s) ""

Message example to submit a patch:
 Find missing unlocks.  This semantic match considers the specific case
 where the unlock is missing from an if branch, and there is a lock
 before the if and an unlock after the if.  False positives are due to
 cases where the if branch represents a case where the function is
 supposed to exit with the lock held, or where there is some preceding
 function call that releases the lock.

 The semantic patch that makes this report is available
 in scripts/coccinelle//mini_lock.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//mini_lock.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
diff -u -p /Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c /tmp/nothing/drivers/can/can_mcux_flexcan.c
--- /Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c
+++ /tmp/nothing/drivers/can/can_mcux_flexcan.c
@@ -313,7 +313,6 @@ static int mcux_flexcan_attach_isr(const
 
 	__ASSERT_NO_MSG(isr);
 
-	k_mutex_lock(&data->rx_mutex, K_FOREVER);
 
 	/* Find and allocate RX message buffer */
 	for (i = 0; i < MCUX_FLEXCAN_MAX_RX; i++) {
@@ -324,7 +323,6 @@ static int mcux_flexcan_attach_isr(const
 	}
 
 	if (alloc == CAN_NO_FREE_FILTER) {
-		return alloc;
 	}
 
 	mcux_flexcan_copy_zfilter_to_mbconfig(filter,
@@ -349,7 +347,6 @@ static int mcux_flexcan_attach_isr(const
 		alloc = CAN_NO_FREE_FILTER;
 	}
 
-	k_mutex_unlock(&data->rx_mutex);
 
 	return alloc;
 }
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcux_flexcan.c:327:2-8: preceding lock on line 316
diff -u -p /Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c /tmp/nothing/drivers/i2c/i2c_cc13xx_cc26xx.c
--- /Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c
+++ /tmp/nothing/drivers/i2c/i2c_cc13xx_cc26xx.c
@@ -89,7 +89,6 @@ static int i2c_cc13xx_cc26xx_transmit(co
 
 	I2CMasterControl(base, I2C_MASTER_CMD_BURST_SEND_START);
 
-	k_sem_take(&data->complete, K_FOREVER);
 
 	if (data->error != I2C_MASTER_ERR_NONE) {
 		goto send_error_stop;
@@ -100,7 +99,6 @@ static int i2c_cc13xx_cc26xx_transmit(co
 
 		I2CMasterControl(base, I2C_MASTER_CMD_BURST_SEND_CONT);
 
-		k_sem_take(&data->complete, K_FOREVER);
 
 		if (data->error != I2C_MASTER_ERR_NONE) {
 			goto send_error_stop;
@@ -111,7 +109,6 @@ static int i2c_cc13xx_cc26xx_transmit(co
 
 	I2CMasterControl(base, I2C_MASTER_CMD_BURST_SEND_FINISH);
 
-	k_sem_take(&data->complete, K_FOREVER);
 
 	if (data->error != I2C_MASTER_ERR_NONE) {
 		return -EIO;
@@ -121,7 +118,6 @@ static int i2c_cc13xx_cc26xx_transmit(co
 
 send_error_stop:
 	I2CMasterControl(base, I2C_MASTER_CMD_BURST_SEND_ERROR_STOP);
-	return -EIO;
 }
 
 static int i2c_cc13xx_cc26xx_receive(const struct device *dev, uint8_t *buf,
@@ -160,7 +156,6 @@ static int i2c_cc13xx_cc26xx_receive(con
 	/* Burst receive */
 	I2CMasterControl(base, I2C_MASTER_CMD_BURST_RECEIVE_START);
 
-	k_sem_take(&data->complete, K_FOREVER);
 
 	if (data->error != I2C_MASTER_ERR_NONE) {
 		goto recv_error_stop;
@@ -171,7 +166,6 @@ static int i2c_cc13xx_cc26xx_receive(con
 	for (int i = 1; i < len - 1; i++) {
 		I2CMasterControl(base, I2C_MASTER_CMD_BURST_RECEIVE_CONT);
 
-		k_sem_take(&data->complete, K_FOREVER);
 
 		if (data->error != I2C_MASTER_ERR_NONE) {
 			goto recv_error_stop;
@@ -182,7 +176,6 @@ static int i2c_cc13xx_cc26xx_receive(con
 
 	I2CMasterControl(base, I2C_MASTER_CMD_BURST_RECEIVE_FINISH);
 
-	k_sem_take(&data->complete, K_FOREVER);
 
 	if (data->error != I2C_MASTER_ERR_NONE) {
 		return -EIO;
@@ -194,7 +187,6 @@ static int i2c_cc13xx_cc26xx_receive(con
 
 recv_error_stop:
 	I2CMasterControl(base, I2C_MASTER_CMD_BURST_RECEIVE_ERROR_STOP);
-	return -EIO;
 }
 
 static int i2c_cc13xx_cc26xx_transfer(const struct device *dev,
diff -u -p /Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c /tmp/nothing/subsys/net/ip/ipv6_nbr.c
--- /Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c
+++ /tmp/nothing/subsys/net/ip/ipv6_nbr.c
@@ -508,7 +508,6 @@ static void ipv6_nd_remove_old_stale_nbr
 	uint32_t oldest = UINT32_MAX;
 	int i;
 
-	k_sem_take(&nbr_lock, K_FOREVER);
 
 	for (i = 0; i < CONFIG_NET_IPV6_MAX_NEIGHBORS; i++) {
 		nbr = get_nbr(i);
@@ -539,14 +538,12 @@ static void ipv6_nd_remove_old_stale_nbr
 	if (nbr_idx != -1) {
 		nbr = get_nbr(nbr_idx);
 		if (!nbr) {
-			return;
 		}
 
 		net_ipv6_nbr_rm(nbr->iface,
 				&net_ipv6_nbr_data(nbr)->addr);
 	}
 
-	k_sem_give(&nbr_lock);
 }
 
 static struct net_nbr *add_nbr(struct net_if *iface,
diff -u -p /Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/rfcomm.c /tmp/nothing/subsys/bluetooth/host/rfcomm.c
--- /Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/rfcomm.c
+++ /tmp/nothing/subsys/bluetooth/host/rfcomm.c
@@ -511,10 +511,8 @@ static void rfcomm_check_fc(struct bt_rf
 
 	BT_DBG("Wait for credits or MSC FC %p", dlc);
 	/* Wait for credits or MSC FC */
-	k_sem_take(&dlc->tx_credits, K_FOREVER);
 
 	if (dlc->session->cfc == BT_RFCOMM_CFC_SUPPORTED) {
-		return;
 	}
 
 	k_sem_take(&dlc->session->fc, K_FOREVER);
@@ -525,7 +523,6 @@ static void rfcomm_check_fc(struct bt_rf
 	 * with 1, is received.
 	 */
 	k_sem_give(&dlc->session->fc);
-	k_sem_give(&dlc->tx_credits);
 }
 
 static void rfcomm_dlc_tx_thread(void *p1, void *p2, void *p3)
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:197:1-7: preceding lock on line 163
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:197:1-7: preceding lock on line 174
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:124:1-7: preceding lock on line 92
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:124:1-7: preceding lock on line 103
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:542:3-9: preceding lock on line 511
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/rfcomm.c:517:2-8: preceding lock on line 514
diff -u -p /Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c /tmp/nothing/subsys/net/lib/tftp/tftp_client.c
--- /Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c
+++ /tmp/nothing/subsys/net/lib/tftp/tftp_client.c
@@ -246,13 +246,11 @@ int tftp_get(struct sockaddr *server, st
 	}
 
 	/* Obtain Global Lock before accessing critical resources. */
-	k_mutex_lock(&tftpc_lock, K_FOREVER);
 
 	/* Send out the request to the TFTP Server. */
 	stat = tftp_send_request(sock, READ_REQUEST, remote_file, mode);
 	if (stat == ERROR_OPCODE) {
 		LOG_ERR("Server responded with error.");
-		return TFTPC_REMOTE_ERROR;
 	}
 
 process_resp:
@@ -275,7 +273,6 @@ tftpc_recv:
 		/* Retries exhausted ? */
 		if (++retx_cnt >= TFTP_REQ_RETX) {
 			LOG_ERR("No more retransmits available. Exiting");
-			return TFTPC_RETRIES_EXHAUSTED;
 		}
 
 		/* Start Retransmission. */
@@ -290,7 +287,6 @@ tftpc_recv:
 
 req_done:
 	/* Clean up. */
-	k_mutex_unlock(&tftpc_lock);
 	close(sock);
 	return stat;
 }
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:255:2-8: preceding lock on line 249
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:278:3-9: preceding lock on line 249
-------------------------------------------------------------------------

Processing ms_timeout.cocci
with option(s) " --include-headers"

Message example to submit a patch:
 The semantic patch that makes this report is available
 in scripts/coccinelle//ms_timeout.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//ms_timeout.cocci --include-headers --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
-------------------------------------------------------------------------

Processing noderef.cocci
with option(s) " --no-includes --include-headers"

Message example to submit a patch:
 sizeof when applied to a pointer typed expression gives the size of
 the pointer

 The semantic patch that makes this report is available
 in scripts/coccinelle//noderef.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//noderef.cocci --no-includes --include-headers --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
diff -u -p /Users/yangxueqi/Documents/zephyr/drivers/can/can_handlers.c /tmp/nothing/drivers/can/can_handlers.c
--- /Users/yangxueqi/Documents/zephyr/drivers/can/can_handlers.c
+++ /tmp/nothing/drivers/can/can_handlers.c
@@ -78,7 +78,6 @@ enum can_state z_vrfy_can_get_state(cons
 	Z_OOPS(Z_SYSCALL_OBJ(dev, K_OBJ_DRIVER_CAN));
 
 	if (err_cnt) {
-		Z_OOPS(Z_SYSCALL_MEMORY_WRITE(err_cnt, sizeof(err_cnt)));
 	}
 
 	return z_impl_can_get_state(dev, err_cnt);
diff -u -p /Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/util/mem.c /tmp/nothing/subsys/bluetooth/controller/util/mem.c
--- /Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/util/mem.c
+++ /tmp/nothing/subsys/bluetooth/controller/util/mem.c
@@ -76,7 +76,6 @@ void mem_release(void *mem, void **mem_h
 	}
 	free_count++;
 
-	memcpy(mem, mem_head, sizeof(mem));
 
 	/* Store free mem_count after the list's next pointer */
 	*((uint16_t *)MROUND((uint8_t *)mem + sizeof(mem))) = free_count;
/Users/yangxueqi/Documents/zephyr/drivers/can/can_handlers.c:81:41-47: ERROR: application of sizeof to pointer
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/util/mem.c:79:23-29: ERROR: application of sizeof to pointer
diff -u -p /Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c /tmp/nothing/drivers/adc/adc_lmp90xxx.c
--- /Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c
+++ /tmp/nothing/drivers/adc/adc_lmp90xxx.c
@@ -247,7 +247,6 @@ static int lmp90xxx_read_reg(const struc
 static int lmp90xxx_read_reg8(const struct device *dev, uint8_t addr,
 			      uint8_t *val)
 {
-	return lmp90xxx_read_reg(dev, addr, val, sizeof(val));
 }
 
 static int lmp90xxx_write_reg(const struct device *dev, uint8_t addr,
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:250:42-48: ERROR: application of sizeof to pointer
-------------------------------------------------------------------------

Processing returnvar.cocci
with option(s) ""

Message example to submit a patch:

 Remove unneeded variable used to store return value.

 The semantic patch that makes this report is available
 in scripts/coccinelle//returnvar.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//returnvar.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:674:12-15: Unneeded variable: "res". Return "NRFX_ERROR_INVALID_ADDR" on line 676
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_cc13xx_cc26xx.c:218:5-8: Unneeded variable: "ret". Return "0" on line 251
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/cdc_acm.c:545:5-8: Unneeded variable: "ret". Return "0" on line 557
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll.c:265:5-8: Unneeded variable: "ret". Return "0" on line 299
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_cc13xx_cc26xx.c:277:5-8: Unneeded variable: "ret". Return "0" on line 295
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/openthread/platform/uart.c:207:9-15: Unneeded variable: "result". Return "OT_ERROR_NONE" on line 218
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:4520:5-8: Unneeded variable: "ret". Return "0" on line 4537
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll.c:284:5-8: Unneeded variable: "ret". Return "0" on line 318
-------------------------------------------------------------------------

Processing semicolon.cocci
with option(s) " --no-includes --include-headers"

Message example to submit a patch:

 Remove unneeded semicolon.

 The semantic patch that makes this report is available
 in scripts/coccinelle//semicolon.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//semicolon.cocci --no-includes --include-headers --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_rf2xx.c:270:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_npcx.c:92:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/device_power.c:151:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/device_power.c:157:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/device_power.c:163:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_utils.c:299:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_wildcard.c:98:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/hci_core.c:3033:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/hci_core.c:3253:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_output.c:647:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/tests/kernel/smp/src/main.c:465:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/sensor/mpu6050/src/main.c:106:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/boards/up_squared/gpio_counter/src/main.c:172:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/http/http_client.c:101:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/l2cap_br.c:608:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bredr.c:117:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:2813:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/tests/drivers/i2c/i2c_slave_api/common/i2c_virtual.c:204:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/sensor/lps22hh/src/main.c:77:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/boards/arm/arty/board.c:36:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/lib/libc/minimal/source/string/string.c:316:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/lib/libc/minimal/source/string/string.c:362:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_cc13xx_cc26xx.c:72:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_cc13xx_cc26xx.c:53:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xlnx_axi_quadspi.c:274:4-5: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcp23s17.c:229:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:172:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:181:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/power.c:69:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_nrfx.c:240:4-5: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:287:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:204:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:219:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:230:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:52:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_help.c:159:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/canbus/canopen/canopen_program.c:246:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/smp.c:4523:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/smp.c:4529:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/tests/drivers/watchdog/wdt_basic_api/src/test_wdt.c:242:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/tests/drivers/watchdog/wdt_basic_api/src/test_wdt.c:304:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/tests/drivers/watchdog/wdt_basic_api/src/test_wdt.c:188:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/websocket_client/src/main.c:217:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/net/wpan_serial/src/main.c:575:2-3: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/sensor/hts221/src/main.c:66:3-4: Unneeded semicolon
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/pong/src/main.c:217:2-3: Unneeded semicolon
-------------------------------------------------------------------------

Processing unsigned_lesser_than_zero.cocci
with option(s) ""

Message example to submit a patch:
 Unsigned expressions cannot be lesser than zero. Presence of
 comparisons 'unsigned (<|<=) 0' often indicates a bug,
 usually wrong type of variable.

 The semantic patch that makes this report is available
 in scripts/coccinelle//unsigned_lesser_than_zero.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//unsigned_lesser_than_zero.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
/Users/yangxueqi/Documents/zephyr/drivers/hwinfo/hwinfo_sam4l.c:23:37-43: WARNING: Unsigned expression compared with zero.
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/hawkbit/hawkbit_device.c:15:5-11: WARNING: Unsigned expression compared with zero.
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/updatehub/updatehub_device.c:16:5-11: WARNING: Unsigned expression compared with zero.
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_liteeth.c:152:5-6: WARNING: Unsigned expression compared with zero.
-------------------------------------------------------------------------

Invalid mode "report" supplied!
Available modes for "unsigned_shift.cocci" are: patch
Using random available mode: "patch"

Processing unsigned_shift.cocci
with option(s) ""

Message example to submit a patch:
 Use BIT() helper macro instead of hardcoding using bitshifting

 The semantic patch that makes this change is available
 in scripts/coccinelle//unsigned_shift.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D patch --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//unsigned_shift.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
diff -u -p a/drivers/ieee802154/ieee802154_kw41z.c b/drivers/ieee802154/ieee802154_kw41z.c
--- a/drivers/ieee802154/ieee802154_kw41z.c
+++ b/drivers/ieee802154/ieee802154_kw41z.c
@@ -574,7 +574,7 @@ out:
 
 #define ACK_FRAME_LEN 3
 #define ACK_FRAME_TYPE (2 << 0)
-#define ACK_FRAME_PENDING_BIT (1 << 4)
+#define ACK_FRAME_PENDING_BIT BIT(4)
 
 static void handle_ack(struct kw41z_context *kw41z, uint8_t seq_number)
 {
diff -u -p a/drivers/pwm/pwm_sam.c b/drivers/pwm/pwm_sam.c
--- a/drivers/pwm/pwm_sam.c
+++ b/drivers/pwm/pwm_sam.c
@@ -32,7 +32,7 @@ static int sam_pwm_get_cycles_per_sec(co
 	uint8_t divider = DEV_CFG(dev)->divider;
 
 	*cycles = SOC_ATMEL_SAM_MCK_FREQ_HZ /
-		  ((1 << prescaler) * divider);
+		  (BIT(prescaler) * divider);
 
 	return 0;
 }
@@ -70,7 +70,7 @@ static int sam_pwm_pin_set(const struct 
 	pwm->PWM_CH_NUM[ch].PWM_CDTYUPD = pulse_cycles;
 
 	/* Enable the output */
-	pwm->PWM_ENA = 1 << ch;
+	pwm->PWM_ENA = BIT(ch);
 
 	return 0;
 }
diff -u -p a/drivers/pwm/pwm_pca9685.c b/drivers/pwm/pwm_pca9685.c
--- a/drivers/pwm/pwm_pca9685.c
+++ b/drivers/pwm/pwm_pca9685.c
@@ -93,14 +93,14 @@ static int pwm_pca9685_pin_set_cycles(co
 	 */
 	if (pulse_count >= PWM_ONE_PERIOD_TICKS) {
 		buf[1] = 0x0;
-		buf[2] = (1 << 4);
+		buf[2] = BIT(4);
 		buf[3] = 0x0;
 		buf[4] = 0x0;
 	} else if (pulse_count == 0U) {
 		buf[1] = 0x0;
 		buf[2] = 0x0;
 		buf[3] = 0x0;
-		buf[4] = (1 << 4);
+		buf[4] = BIT(4);
 	} else {
 		/* No start delay given. When the count is 0 the
 		 * pwm will be high .
@@ -145,7 +145,7 @@ int pwm_pca9685_init(const struct device
 	/* MODE1 register */
 
 	buf[0] = REG_MODE1;
-	buf[1] = (1 << 5); /* register addr auto increment */
+	buf[1] = BIT(5); /* register addr auto increment */
 
 	ret = i2c_write(i2c_master, buf, 2, config->i2c_slave_addr);
 	if (ret != 0) {
diff -u -p a/drivers/interrupt_controller/intc_loapic.c b/drivers/interrupt_controller/intc_loapic.c
--- a/drivers/interrupt_controller/intc_loapic.c
+++ b/drivers/interrupt_controller/intc_loapic.c
@@ -102,7 +102,7 @@ void z_loapic_enable(unsigned char cpu_n
 	 *
 	 * in X2APIC, LDR is read-only.
 	 */
-	x86_write_xapic(LOAPIC_LDR, 1 << (cpu_number + 24));
+	x86_write_xapic(LOAPIC_LDR, BIT((cpu_number + 24)));
 #endif
 
 	/*
diff -u -p a/drivers/interrupt_controller/intc_exti_stm32.c b/drivers/interrupt_controller/intc_exti_stm32.c
--- a/drivers/interrupt_controller/intc_exti_stm32.c
+++ b/drivers/interrupt_controller/intc_exti_stm32.c
@@ -109,9 +109,9 @@ void stm32_exti_enable(int line)
 
 	/* Enable requested line interrupt */
 #if defined(CONFIG_SOC_SERIES_STM32H7X) && defined(CONFIG_CPU_CORTEX_M4)
-	LL_C2_EXTI_EnableIT_0_31(1 << line);
+	LL_C2_EXTI_EnableIT_0_31(BIT(line));
 #else
-	LL_EXTI_EnableIT_0_31(1 << line);
+	LL_EXTI_EnableIT_0_31(BIT(line));
 #endif
 
 	/* Enable exti irq interrupt */
@@ -124,9 +124,9 @@ void stm32_exti_disable(int line)
 
 	if (line < 32) {
 #if defined(CONFIG_SOC_SERIES_STM32H7X) && defined(CONFIG_CPU_CORTEX_M4)
-		LL_C2_EXTI_DisableIT_0_31(1 << line);
+		LL_C2_EXTI_DisableIT_0_31(BIT(line));
 #else
-		LL_EXTI_DisableIT_0_31(1 << line);
+		LL_EXTI_DisableIT_0_31(BIT(line));
 #endif
 	} else {
 		__ASSERT_NO_MSG(line);
@@ -145,12 +145,12 @@ static inline int stm32_exti_is_pending(
 #if defined(CONFIG_SOC_SERIES_STM32MP1X) || \
 	defined(CONFIG_SOC_SERIES_STM32G0X) || \
 	defined(CONFIG_SOC_SERIES_STM32L5X)
-		return (LL_EXTI_IsActiveRisingFlag_0_31(1 << line) ||
-			LL_EXTI_IsActiveFallingFlag_0_31(1 << line));
+		return (LL_EXTI_IsActiveRisingFlag_0_31(BIT(line)) ||
+			LL_EXTI_IsActiveFallingFlag_0_31(BIT(line)));
 #elif defined(CONFIG_SOC_SERIES_STM32H7X) && defined(CONFIG_CPU_CORTEX_M4)
-		return LL_C2_EXTI_IsActiveFlag_0_31(1 << line);
+		return LL_C2_EXTI_IsActiveFlag_0_31(BIT(line));
 #else
-		return LL_EXTI_IsActiveFlag_0_31(1 << line);
+		return LL_EXTI_IsActiveFlag_0_31(BIT(line));
 #endif
 	} else {
 		__ASSERT_NO_MSG(line);
@@ -169,12 +169,12 @@ static inline void stm32_exti_clear_pend
 #if defined(CONFIG_SOC_SERIES_STM32MP1X) || \
 	defined(CONFIG_SOC_SERIES_STM32G0X) || \
 	defined(CONFIG_SOC_SERIES_STM32L5X)
-		LL_EXTI_ClearRisingFlag_0_31(1 << line);
-		LL_EXTI_ClearFallingFlag_0_31(1 << line);
+		LL_EXTI_ClearRisingFlag_0_31(BIT(line));
+		LL_EXTI_ClearFallingFlag_0_31(BIT(line));
 #elif defined(CONFIG_SOC_SERIES_STM32H7X) && defined(CONFIG_CPU_CORTEX_M4)
-		LL_C2_EXTI_ClearFlag_0_31(1 << line);
+		LL_C2_EXTI_ClearFlag_0_31(BIT(line));
 #else
-		LL_EXTI_ClearFlag_0_31(1 << line);
+		LL_EXTI_ClearFlag_0_31(BIT(line));
 #endif
 	} else {
 		__ASSERT_NO_MSG(line);
@@ -192,20 +192,20 @@ void stm32_exti_trigger(int line, int tr
 
 	switch (trigger) {
 	case STM32_EXTI_TRIG_NONE:
-		LL_EXTI_DisableRisingTrig_0_31(1 << line);
-		LL_EXTI_DisableFallingTrig_0_31(1 << line);
+		LL_EXTI_DisableRisingTrig_0_31(BIT(line));
+		LL_EXTI_DisableFallingTrig_0_31(BIT(line));
 		break;
 	case STM32_EXTI_TRIG_RISING:
-		LL_EXTI_EnableRisingTrig_0_31(1 << line);
-		LL_EXTI_DisableFallingTrig_0_31(1 << line);
+		LL_EXTI_EnableRisingTrig_0_31(BIT(line));
+		LL_EXTI_DisableFallingTrig_0_31(BIT(line));
 		break;
 	case STM32_EXTI_TRIG_FALLING:
-		LL_EXTI_EnableFallingTrig_0_31(1 << line);
-		LL_EXTI_DisableRisingTrig_0_31(1 << line);
+		LL_EXTI_EnableFallingTrig_0_31(BIT(line));
+		LL_EXTI_DisableRisingTrig_0_31(BIT(line));
 		break;
 	case STM32_EXTI_TRIG_BOTH:
-		LL_EXTI_EnableRisingTrig_0_31(1 << line);
-		LL_EXTI_EnableFallingTrig_0_31(1 << line);
+		LL_EXTI_EnableRisingTrig_0_31(BIT(line));
+		LL_EXTI_EnableFallingTrig_0_31(BIT(line));
 		break;
 	default:
 		__ASSERT_NO_MSG(trigger);
diff -u -p a/drivers/i2c/i2c_sifive.c b/drivers/i2c/i2c_sifive.c
--- a/drivers/i2c/i2c_sifive.c
+++ b/drivers/i2c/i2c_sifive.c
@@ -38,24 +38,24 @@ LOG_MODULE_REGISTER(i2c_sifive);
 
 /* Values */
 
-#define SF_CONTROL_EN	(1 << 7)
-#define SF_CONTROL_IE	(1 << 6)
+#define SF_CONTROL_EN	BIT(7)
+#define SF_CONTROL_IE	BIT(6)
 
 #define SF_TX_WRITE	(0 << 0)
-#define SF_TX_READ	(1 << 0)
+#define SF_TX_READ	BIT(0)
 
-#define SF_CMD_START	(1 << 7)
-#define SF_CMD_STOP	(1 << 6)
-#define SF_CMD_READ	(1 << 5)
-#define SF_CMD_WRITE	(1 << 4)
-#define SF_CMD_ACK	(1 << 3)
-#define SF_CMD_IACK	(1 << 0)
-
-#define SF_STATUS_RXACK	(1 << 7)
-#define SF_STATUS_BUSY	(1 << 6)
-#define SF_STATUS_AL	(1 << 5)
-#define SF_STATUS_TIP	(1 << 1)
-#define SF_STATUS_IP	(1 << 0)
+#define SF_CMD_START	BIT(7)
+#define SF_CMD_STOP	BIT(6)
+#define SF_CMD_READ	BIT(5)
+#define SF_CMD_WRITE	BIT(4)
+#define SF_CMD_ACK	BIT(3)
+#define SF_CMD_IACK	BIT(0)
+
+#define SF_STATUS_RXACK	BIT(7)
+#define SF_STATUS_BUSY	BIT(6)
+#define SF_STATUS_AL	BIT(5)
+#define SF_STATUS_TIP	BIT(1)
+#define SF_STATUS_IP	BIT(0)
 
 /* Structure declarations */
 
diff -u -p a/drivers/i2c/i2c_cc32xx.c b/drivers/i2c/i2c_cc32xx.c
--- a/drivers/i2c/i2c_cc32xx.c
+++ b/drivers/i2c/i2c_cc32xx.c
@@ -346,7 +346,7 @@ static int i2c_cc32xx_init(const struct 
 
 	/* Take I2C hardware semaphore. */
 	regval = HWREG(COMMON_REG_BASE);
-	regval = (regval & ~I2C_SEM_MASK) | (0x01 << I2C_SEM_TAKE);
+	regval = (regval & ~I2C_SEM_MASK) | BIT(I2C_SEM_TAKE);
 	HWREG(COMMON_REG_BASE) = regval;
 
 	/* Set to default configuration: */
diff -u -p a/drivers/usb/device/usb_dc_dw.c b/drivers/usb/device/usb_dc_dw.c
--- a/drivers/usb/device/usb_dc_dw.c
+++ b/drivers/usb/device/usb_dc_dw.c
@@ -166,8 +166,8 @@ static void usb_dw_flush_tx_fifo(int ep)
 {
 	int fnum = usb_dw_ctrl.in_ep_ctrl[ep].fifo_num;
 
-	USB_DW->grstctl = (fnum << 6) | (1<<5);
-	while (USB_DW->grstctl & (1<<5)) {
+	USB_DW->grstctl = (fnum << 6) | BIT(5);
+	while (USB_DW->grstctl & BIT(5)) {
 	}
 }
 
@@ -322,7 +322,7 @@ static void usb_dw_prep_rx(const uint8_t
 
 	USB_DW->out_ep_reg[ep_idx].doeptsiz =
 		(USB_DW_SUP_CNT << USB_DW_DOEPTSIZ_SUP_CNT_OFFSET) |
-		(1 << USB_DW_DEPTSIZ_PKT_CNT_OFFSET) | ep_mps;
+		BIT(USB_DW_DEPTSIZ_PKT_CNT_OFFSET) | ep_mps;
 
 	/* Clear NAK and enable ep */
 	if (!setup) {
diff -u -p a/drivers/spi/spi_ll_stm32.c b/drivers/spi/spi_ll_stm32.c
--- a/drivers/spi/spi_ll_stm32.c
+++ b/drivers/spi/spi_ll_stm32.c
@@ -535,7 +535,7 @@ static int spi_stm32_configure(const str
 
 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 		    " mode %u/%u/%u, slave %u",
-		    config, clock >> br, 1 << br,
+		    config, clock >> br, BIT(br),
 		    (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) ? 1 : 0,
 		    (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) ? 1 : 0,
 		    (SPI_MODE_GET(config->operation) & SPI_MODE_LOOP) ? 1 : 0,
diff -u -p a/drivers/watchdog/wdt_wwdg_stm32.c b/drivers/watchdog/wdt_wwdg_stm32.c
--- a/drivers/watchdog/wdt_wwdg_stm32.c
+++ b/drivers/watchdog/wdt_wwdg_stm32.c
@@ -92,7 +92,7 @@ static uint32_t wwdg_stm32_get_timeout(c
 				       uint32_t prescaler,
 				       uint32_t counter)
 {
-	uint32_t divider = WWDG_INTERNAL_DIVIDER * (1 << (prescaler >> 7));
+	uint32_t divider = WWDG_INTERNAL_DIVIDER * BIT((prescaler >> 7));
 	float f_wwdg = (float)wwdg_stm32_get_pclk(dev) / divider;
 
 	return USEC_PER_SEC * (((counter & 0x3F) + 1) / f_wwdg);
diff -u -p a/drivers/sensor/amg88xx/amg88xx.c b/drivers/sensor/amg88xx/amg88xx.c
--- a/drivers/sensor/amg88xx/amg88xx.c
+++ b/drivers/sensor/amg88xx/amg88xx.c
@@ -52,7 +52,7 @@ static int amg88xx_channel_get(const str
 
 	for (size_t idx = 0; idx < len; idx++) {
 		/* fix negative values */
-		if (drv_data->sample[idx] & (1 << 11)) {
+		if (drv_data->sample[idx] & BIT(11)) {
 			drv_data->sample[idx] |= 0xF000;
 		}
 		val[idx].val1 = (((int32_t)drv_data->sample[idx]) *
diff -u -p a/drivers/sensor/lsm6dsl/lsm6dsl_spi.c b/drivers/sensor/lsm6dsl/lsm6dsl_spi.c
--- a/drivers/sensor/lsm6dsl/lsm6dsl_spi.c
+++ b/drivers/sensor/lsm6dsl/lsm6dsl_spi.c
@@ -16,7 +16,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define LSM6DSL_SPI_READ		(1 << 7)
+#define LSM6DSL_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(LSM6DSL, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/bme680/bme680.c b/drivers/sensor/bme680/bme680.c
--- a/drivers/sensor/bme680/bme680.c
+++ b/drivers/sensor/bme680/bme680.c
@@ -103,7 +103,7 @@ static void bme680_calc_humidity(struct 
 	var2_2 = ((temp_scaled * (int32_t)data->par_h4) / (int32_t)100)
 		 + (((temp_scaled * ((temp_scaled * (int32_t)data->par_h5)
 				     / ((int32_t)100))) >> 6) / ((int32_t)100))
-		 +  (int32_t)(1 << 14);
+		 +  (int32_t) BIT(14);
 	var2 = (var2_1 * var2_2) >> 10;
 	var3 = var1 * var2;
 	var4 = (int32_t)data->par_h6 << 7;
diff -u -p a/drivers/sensor/lis2dh/lis2dh.c b/drivers/sensor/lis2dh/lis2dh.c
--- a/drivers/sensor/lis2dh/lis2dh.c
+++ b/drivers/sensor/lis2dh/lis2dh.c
@@ -180,7 +180,7 @@ static int lis2dh_acc_odr_set(const stru
 
 #ifdef CONFIG_LIS2DH_ACCEL_RANGE_RUNTIME
 
-#define LIS2DH_RANGE_IDX_TO_VALUE(idx)		(1 << ((idx) + 1))
+#define LIS2DH_RANGE_IDX_TO_VALUE(idx)		BIT(((idx) + 1))
 #define LIS2DH_NUM_RANGES			4
 
 static int lis2dh_range_to_reg_val(uint16_t range)
@@ -339,7 +339,7 @@ int lis2dh_init(const struct device *dev
 #endif
 
 	LOG_INF("bus=%s fs=%d, odr=0x%x lp_en=0x%x scale=%d",
-		    LIS2DH_BUS_DEV_NAME, 1 << (LIS2DH_FS_IDX + 1),
+		    LIS2DH_BUS_DEV_NAME, BIT((LIS2DH_FS_IDX + 1)),
 		    LIS2DH_ODR_IDX, (uint8_t)LIS2DH_LP_EN_BIT, lis2dh->scale);
 
 	/* enable accel measurements and set power mode and data rate */
diff -u -p a/drivers/sensor/iis2dlpc/iis2dlpc_spi.c b/drivers/sensor/iis2dlpc/iis2dlpc_spi.c
--- a/drivers/sensor/iis2dlpc/iis2dlpc_spi.c
+++ b/drivers/sensor/iis2dlpc/iis2dlpc_spi.c
@@ -17,7 +17,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define IIS2DLPC_SPI_READ		(1 << 7)
+#define IIS2DLPC_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(IIS2DLPC, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/lps25hb/lps25hb.c b/drivers/sensor/lps25hb/lps25hb.c
--- a/drivers/sensor/lps25hb/lps25hb.c
+++ b/drivers/sensor/lps25hb/lps25hb.c
@@ -148,7 +148,7 @@ static int lps25hb_init_chip(const struc
 	if (i2c_reg_update_byte(data->i2c_master, config->i2c_slave_addr,
 				LPS25HB_REG_CTRL_REG1,
 				LPS25HB_MASK_CTRL_REG1_BDU,
-				(1 << LPS25HB_SHIFT_CTRL_REG1_BDU)) < 0) {
+				BIT(LPS25HB_SHIFT_CTRL_REG1_BDU)) < 0) {
 		LOG_DBG("failed to set BDU");
 		goto err_poweroff;
 	}
diff -u -p a/drivers/sensor/lis2dw12/lis2dw12_spi.c b/drivers/sensor/lis2dw12/lis2dw12_spi.c
--- a/drivers/sensor/lis2dw12/lis2dw12_spi.c
+++ b/drivers/sensor/lis2dw12/lis2dw12_spi.c
@@ -17,7 +17,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define LIS2DW12_SPI_READ		(1 << 7)
+#define LIS2DW12_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(LIS2DW12, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/lis2mdl/lis2mdl_spi.c b/drivers/sensor/lis2mdl/lis2mdl_spi.c
--- a/drivers/sensor/lis2mdl/lis2mdl_spi.c
+++ b/drivers/sensor/lis2mdl/lis2mdl_spi.c
@@ -16,7 +16,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define LIS2MDL_SPI_READ		(1 << 7)
+#define LIS2MDL_SPI_READ		BIT(7)
 
 #define LOG_LEVEL CONFIG_SENSOR_LOG_LEVEL
 LOG_MODULE_DECLARE(LIS2MDL);
diff -u -p a/drivers/modem/hl7800.c b/drivers/modem/hl7800.c
--- a/drivers/modem/hl7800.c
+++ b/drivers/modem/hl7800.c
@@ -3789,64 +3789,64 @@ reboot:
 	/* Configure LTE bands */
 #if CONFIG_MODEM_HL7800_CONFIGURE_BANDS
 #if CONFIG_MODEM_HL7800_BAND_1
-	bands_bottom |= 1 << 0;
+	bands_bottom |= BIT(0);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_2
-	bands_bottom |= 1 << 1;
+	bands_bottom |= BIT(1);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_3
-	bands_bottom |= 1 << 2;
+	bands_bottom |= BIT(2);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_4
-	bands_bottom |= 1 << 3;
+	bands_bottom |= BIT(3);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_5
-	bands_bottom |= 1 << 4;
+	bands_bottom |= BIT(4);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_8
-	bands_bottom |= 1 << 7;
+	bands_bottom |= BIT(7);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_9
-	bands_bottom |= 1 << 8;
+	bands_bottom |= BIT(8);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_10
-	bands_bottom |= 1 << 9;
+	bands_bottom |= BIT(9);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_12
-	bands_bottom |= 1 << 11;
+	bands_bottom |= BIT(11);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_13
-	bands_bottom |= 1 << 12;
+	bands_bottom |= BIT(12);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_14
-	bands_bottom |= 1 << 13;
+	bands_bottom |= BIT(13);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_17
-	bands_bottom |= 1 << 16;
+	bands_bottom |= BIT(16);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_18
-	bands_bottom |= 1 << 17;
+	bands_bottom |= BIT(17);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_19
-	bands_bottom |= 1 << 18;
+	bands_bottom |= BIT(18);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_20
-	bands_bottom |= 1 << 19;
+	bands_bottom |= BIT(19);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_25
-	bands_bottom |= 1 << 24;
+	bands_bottom |= BIT(24);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_26
-	bands_bottom |= 1 << 25;
+	bands_bottom |= BIT(25);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_27
-	bands_bottom |= 1 << 26;
+	bands_bottom |= BIT(26);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_28
-	bands_bottom |= 1 << 27;
+	bands_bottom |= BIT(27);
 #endif
 #if CONFIG_MODEM_HL7800_BAND_66
-	bands_top |= 1 << 1;
+	bands_top |= BIT(1);
 #endif
 
 	/* Check if bands are configured correctly */
diff -u -p a/drivers/dac/dac_dacx0508.c b/drivers/dac/dac_dacx0508.c
--- a/drivers/dac/dac_dacx0508.c
+++ b/drivers/dac/dac_dacx0508.c
@@ -193,7 +193,7 @@ static int dacx0508_write_value(const st
 		return -EINVAL;
 	}
 
-	if (value >= (1 << config->resolution)) {
+	if (value >= BIT(config->resolution)) {
 		LOG_ERR("Value %d out of range", value);
 		return -EINVAL;
 	}
diff -u -p a/drivers/gpio/gpio_mmio32.c b/drivers/gpio/gpio_mmio32.c
--- a/drivers/gpio/gpio_mmio32.c
+++ b/drivers/gpio/gpio_mmio32.c
@@ -35,7 +35,7 @@ static int gpio_mmio32_config(const stru
 	struct gpio_mmio32_context *context = dev->data;
 	const struct gpio_mmio32_config *config = context->config;
 
-	if ((config->mask & (1 << pin)) == 0) {
+	if ((config->mask & BIT(pin)) == 0) {
 		return -EINVAL; /* Pin not in our validity mask */
 	}
 
@@ -52,9 +52,9 @@ static int gpio_mmio32_config(const stru
 
 		key = irq_lock();
 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
-			*reg = (*reg | (1 << pin));
+			*reg = (*reg | BIT(pin));
 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
-			*reg = (*reg & (config->mask & ~(1 << pin)));
+			*reg = (*reg & (config->mask & ~BIT(pin)));
 		}
 		irq_unlock(key);
 	}
diff -u -p a/drivers/gpio/gpio_sx1509b.c b/drivers/gpio/gpio_sx1509b.c
--- a/drivers/gpio/gpio_sx1509b.c
+++ b/drivers/gpio/gpio_sx1509b.c
@@ -106,7 +106,7 @@ enum {
 /* Register bits for SX1509B_REG_CLOCK */
 enum {
 	SX1509B_REG_CLOCK_FOSC_OFF      = 0 << 5,
-	SX1509B_REG_CLOCK_FOSC_EXT      = 1 << 5,
+	SX1509B_REG_CLOCK_FOSC_EXT      = BIT(5),
 	SX1509B_REG_CLOCK_FOSC_INT_2MHZ = 2 << 5,
 };
 
diff -u -p a/drivers/serial/uart_liteuart.c b/drivers/serial/uart_liteuart.c
--- a/drivers/serial/uart_liteuart.c
+++ b/drivers/serial/uart_liteuart.c
@@ -14,8 +14,8 @@
 #include <drivers/uart.h>
 #include <zephyr/types.h>
 
-#define UART_EV_TX	(1 << 0)
-#define UART_EV_RX	(1 << 1)
+#define UART_EV_TX	BIT(0)
+#define UART_EV_RX	BIT(1)
 #define UART_BASE_ADDR	DT_INST_REG_ADDR(0)
 #define UART_RXTX	((UART_BASE_ADDR) + 0x00)
 #define UART_TXFULL	((UART_BASE_ADDR) + 0x04)
diff -u -p a/soc/arc/snps_nsim/soc.c b/soc/arc/snps_nsim/soc.c
--- a/soc/arc/snps_nsim/soc.c
+++ b/soc/arc/snps_nsim/soc.c
@@ -32,7 +32,7 @@ static int arc_nsim_init(const struct de
 	for (i = 0; i < (CONFIG_NUM_IRQS - ARC_CONNECT_IDU_IRQ_START); i++) {
 		z_arc_connect_idu_set_mode(i, ARC_CONNECT_INTRPT_TRIGGER_LEVEL,
 			ARC_CONNECT_DISTRI_MODE_ROUND_ROBIN);
-		z_arc_connect_idu_set_dest(i, 1 << core);
+		z_arc_connect_idu_set_dest(i, BIT(core));
 		z_arc_connect_idu_set_mask(i, 0x0);
 	}
 
diff -u -p a/subsys/power/device_pm.c b/subsys/power/device_pm.c
--- a/subsys/power/device_pm.c
+++ b/subsys/power/device_pm.c
@@ -15,7 +15,7 @@ LOG_MODULE_DECLARE(power);
 
 /* Device PM request type */
 #define DEVICE_PM_SYNC			(0 << 0)
-#define DEVICE_PM_ASYNC			(1 << 0)
+#define DEVICE_PM_ASYNC			BIT(0)
 
 static void device_pm_callback(const struct device *dev,
 			       int retval, void *context, void *arg)
diff -u -p a/subsys/power/policy/policy_residency_cc13x2_cc26x2.c b/subsys/power/policy/policy_residency_cc13x2_cc26x2.c
--- a/subsys/power/policy/policy_residency_cc13x2_cc26x2.c
+++ b/subsys/power/policy/policy_residency_cc13x2_cc26x2.c
@@ -67,14 +67,12 @@ enum power_states sys_pm_policy_next_sta
 			 */
 			switch (i) {
 			case 0: /* Idle mode */
-				if ((constraints & (1 <<
-				    PowerCC26XX_DISALLOW_IDLE)) != 0) {
+				if ((constraints & BIT(PowerCC26XX_DISALLOW_IDLE)) != 0) {
 					disallowed = true;
 				}
 				break;
 			case 1: /* Standby mode */
-				if ((constraints & (1 <<
-				    PowerCC26XX_DISALLOW_STANDBY)) != 0) {
+				if ((constraints & BIT(PowerCC26XX_DISALLOW_STANDBY)) != 0) {
 					disallowed = true;
 				}
 				/* Set timeout for wakeup event */
diff -u -p a/subsys/net/lib/sockets/sockets_select.c b/subsys/net/lib/sockets/sockets_select.c
--- a/subsys/net/lib/sockets/sockets_select.c
+++ b/subsys/net/lib/sockets/sockets_select.c
@@ -13,7 +13,7 @@
 #define FD_SET_CALC_OFFSETS(set, word_idx, bit_mask) { \
 	unsigned int b_idx = fd % (sizeof(set->bitset[0]) * 8); \
 	word_idx = fd / (sizeof(set->bitset[0]) * 8); \
-	bit_mask = 1 << b_idx; \
+	bit_mask = BIT(b_idx); \
 	}
 
 void ZSOCK_FD_ZERO(zsock_fd_set *set)
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_engine.c b/subsys/net/lib/lwm2m/lwm2m_engine.c
--- a/subsys/net/lib/lwm2m/lwm2m_engine.c
+++ b/subsys/net/lib/lwm2m/lwm2m_engine.c
@@ -4419,7 +4419,7 @@ int lwm2m_parse_peerinfo(char *url, stru
 #endif /* CONFIG_LWM2M_DTLS_SUPPORT */
 	}
 
-	if (!(parser.field_set & (1 << UF_PORT))) {
+	if (!(parser.field_set & BIT(UF_PORT))) {
 		/* Set to default port of CoAP */
 		parser.port = CONFIG_LWM2M_PEER_PORT;
 	}
diff -u -p a/subsys/usb/usb_descriptor.c b/subsys/usb/usb_descriptor.c
--- a/subsys/usb/usb_descriptor.c
+++ b/subsys/usb/usb_descriptor.c
@@ -246,13 +246,13 @@ static int usb_validate_ep_cfg_data(stru
 			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
 			ep_cfg.ep_addr = ep_descr->bEndpointAddress;
 			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
-				if ((*requested_ep & (1 << (idx + 16)))) {
+				if ((*requested_ep & BIT((idx + 16)))) {
 					continue;
 				}
 
 				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
 			} else {
-				if ((*requested_ep & (1 << (idx)))) {
+				if ((*requested_ep & BIT((idx)))) {
 					continue;
 				}
 
@@ -265,9 +265,9 @@ static int usb_validate_ep_cfg_data(stru
 				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
 				ep_data[i].ep_addr = ep_cfg.ep_addr;
 				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
-					*requested_ep |= (1 << (idx + 16));
+					*requested_ep |= BIT((idx + 16));
 				} else {
-					*requested_ep |= (1 << idx);
+					*requested_ep |= BIT(idx);
 				}
 				LOG_DBG("endpoint 0x%x", ep_data[i].ep_addr);
 				return 0;
diff -u -p a/subsys/disk/disk_access_stm32_sdmmc.c b/subsys/disk/disk_access_stm32_sdmmc.c
--- a/subsys/disk/disk_access_stm32_sdmmc.c
+++ b/subsys/disk/disk_access_stm32_sdmmc.c
@@ -276,7 +276,7 @@ static int stm32_sdmmc_card_detect_init(
 	}
 
 	gpio_init_callback(&priv->cd_cb, stm32_sdmmc_cd_callback,
-			   1 << priv->cd.pin);
+			   BIT(priv->cd.pin));
 
 	err = gpio_add_callback(priv->cd.port, &priv->cd_cb);
 	if (err) {
diff -u -p a/subsys/fs/nvs/nvs.c b/subsys/fs/nvs/nvs.c
--- a/subsys/fs/nvs/nvs.c
+++ b/subsys/fs/nvs/nvs.c
@@ -390,7 +390,7 @@ static int nvs_prev_ate(struct nvs_fs *f
 	if (((*addr) >> ADDR_SECT_SHIFT) == 0U) {
 		*addr += ((fs->sector_count - 1) << ADDR_SECT_SHIFT);
 	} else {
-		*addr -= (1 << ADDR_SECT_SHIFT);
+		*addr -= BIT(ADDR_SECT_SHIFT);
 	}
 
 	rc = nvs_flash_ate_rd(fs, *addr, &close_ate);
@@ -430,7 +430,7 @@ static int nvs_prev_ate(struct nvs_fs *f
 
 static void nvs_sector_advance(struct nvs_fs *fs, uint32_t *addr)
 {
-	*addr += (1 << ADDR_SECT_SHIFT);
+	*addr += BIT(ADDR_SECT_SHIFT);
 	if ((*addr >> ADDR_SECT_SHIFT) == fs->sector_count) {
 		*addr -= (fs->sector_count << ADDR_SECT_SHIFT);
 	}
diff -u -p a/tests/lib/cmsis_dsp/statistics/src/q31.c b/tests/lib/cmsis_dsp/statistics/src/q31.c
--- a/tests/lib/cmsis_dsp/statistics/src/q31.c
+++ b/tests/lib/cmsis_dsp/statistics/src/q31.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)100)
 #define ABS_ERROR_THRESH_Q15	((q31_t)100)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 18))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(18)))
 
 static void test_arm_max_q31(
 	const q31_t *input1, int ref_index, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/complexmath/src/q15.c b/tests/lib/cmsis_dsp/complexmath/src/q15.c
--- a/tests/lib/cmsis_dsp/complexmath/src/q15.c
+++ b/tests/lib/cmsis_dsp/complexmath/src/q15.c
@@ -16,7 +16,7 @@
 #define SNR_ERROR_THRESH	((float32_t)25)
 #define SNR_ERROR_THRESH_HIGH	((float32_t)60)
 #define ABS_ERROR_THRESH_Q15	((q15_t)50)
-#define ABS_ERROR_THRESH_Q31	((q31_t)(1 << 15))
+#define ABS_ERROR_THRESH_Q31	((q31_t)(BIT(15)))
 
 static void test_arm_cmplx_conj_q15(
 	const q15_t *input1, const q15_t *ref, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/basicmath/src/q31.c b/tests/lib/cmsis_dsp/basicmath/src/q31.c
--- a/tests/lib/cmsis_dsp/basicmath/src/q31.c
+++ b/tests/lib/cmsis_dsp/basicmath/src/q31.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)100)
 #define ABS_ERROR_THRESH_Q31	((q31_t)4)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 17))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(17)))
 
 static void test_arm_add_q31(
 	const q31_t *input1, const q31_t *input2, const q31_t *ref, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/binary_q31.c b/tests/lib/cmsis_dsp/matrix/src/binary_q31.c
--- a/tests/lib/cmsis_dsp/matrix/src/binary_q31.c
+++ b/tests/lib/cmsis_dsp/matrix/src/binary_q31.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)100)
 #define ABS_ERROR_THRESH_Q31	((q31_t)5)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 16))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(16)))
 
 #define NUM_MATRICES		(ARRAY_SIZE(in_dims) / 3)
 #define MAX_MATRIX_DIM		(40)
diff -u -p a/tests/kernel/tickless/tickless/src/timestamps.c b/tests/kernel/tickless/tickless/src/timestamps.c
--- a/tests/kernel/tickless/tickless/src/timestamps.c
+++ b/tests/kernel/tickless/tickless/src/timestamps.c
@@ -26,7 +26,7 @@
 #define _TIMESTAMP_NUM 0  /* set to timer # for use by timestamp (0-3) */
 
 #define _CLKGATECTRL (*((volatile uint32_t *)0x400FE104))
-#define _CLKGATECTRL_TIMESTAMP_EN (1 << (16 + _TIMESTAMP_NUM))
+#define _CLKGATECTRL_TIMESTAMP_EN BIT((16 + _TIMESTAMP_NUM))
 
 #define _TIMESTAMP_BASE 0x40030000
 #define _TIMESTAMP_OFFSET (0x1000 * _TIMESTAMP_NUM)
@@ -138,10 +138,10 @@ void _timestamp_close(void)
 #define _COUNTDOWN_TIMER false
 
 #define _CLKGATECTRL (*((volatile uint32_t *)0x4004803C))
-#define _CLKGATECTRL_TIMESTAMP_EN (1 << 29)
+#define _CLKGATECTRL_TIMESTAMP_EN BIT(29)
 
 #define _SYSOPTCTRL2 (*((volatile uint32_t *)0x40048004))
-#define _SYSOPTCTRL2_32KHZRTCCLK (1 << 4)
+#define _SYSOPTCTRL2_32KHZRTCCLK BIT(4)
 
 #define _TIMESTAMP_ADDR (0x4003D000)
 
diff -u -p a/samples/boards/up_squared/gpio_counter/src/main.c b/samples/boards/up_squared/gpio_counter/src/main.c
--- a/samples/boards/up_squared/gpio_counter/src/main.c
+++ b/samples/boards/up_squared/gpio_counter/src/main.c
@@ -139,7 +139,7 @@ void main(void)
 
 
 	/* Callback uses pin_mask, so need bit shifting */
-	gpio_init_callback(&gpio_cb, button_cb, (1 << intr_pin.pin));
+	gpio_init_callback(&gpio_cb, button_cb, BIT(intr_pin.pin));
 	gpio_add_callback(intr_pin.gpio_dev, &gpio_cb);
 
 	/* Setup input pin for interrupt */
diff -u -p a/boards/posix/native_posix/irq_ctrl.c b/boards/posix/native_posix/irq_ctrl.c
--- a/boards/posix/native_posix/irq_ctrl.c
+++ b/boards/posix/native_posix/irq_ctrl.c
@@ -192,7 +192,7 @@ static inline void hw_irq_ctrl_irq_raise
 	if (irq < N_IRQS) {
 		irq_premask |= ((uint64_t)1<<irq);
 
-		if (irq_mask & (1 << irq)) {
+		if (irq_mask & BIT(irq)) {
 			irq_status |= ((uint64_t)1<<irq);
 		}
 	} else if (irq == PHONY_HARD_IRQ) {
diff -u -p a/boards/arm/mps2_an521/pinmux.c b/boards/arm/mps2_an521/pinmux.c
--- a/boards/arm/mps2_an521/pinmux.c
+++ b/boards/arm/mps2_an521/pinmux.c
@@ -123,34 +123,34 @@ static void arm_mps2_pinmux_defaults(voi
 
 	/* Set GPIO Alternate Functions */
 
-	gpio_0 = (1<<0)   /* Shield 0 UART 3 RXD */
-	       | (1<<4)   /* Shield 0 UART 3 TXD */
-	       | (1<<5)   /* Shield 0 I2C SCL SBCON2 */
-	       | (1<<15)  /* Shield 0 I2C SDA SBCON2 */
-	       | (1<<11)  /* Shield 0 SPI 3 SCK */
-	       | (1<<12)  /* Shield 0 SPI 3 SS */
-	       | (1<<13)  /* Shield 0 SPI 3 MOSI */
-	       | (1<<14); /* Shield 0 SPI 3 MISO */
+	gpio_0 = BIT(0)   /* Shield 0 UART 3 RXD */
+	       | BIT(4)   /* Shield 0 UART 3 TXD */
+	       | BIT(5)   /* Shield 0 I2C SCL SBCON2 */
+	       | BIT(15)  /* Shield 0 I2C SDA SBCON2 */
+	       | BIT(11)  /* Shield 0 SPI 3 SCK */
+	       | BIT(12)  /* Shield 0 SPI 3 SS */
+	       | BIT(13)  /* Shield 0 SPI 3 MOSI */
+	       | BIT(14); /* Shield 0 SPI 3 MISO */
 
 	CMSDK_AHB_GPIO0_DEV->altfuncset = gpio_0;
 
-	gpio_1 = (1<<10) /* Shield 1 UART 4 RXD */
-	       | (1<<14) /* Shield 1 UART 4 TXD */
-	       | (1<<15) /* Shield 1 I2C SCL SBCON3 */
-	       | (1<<0)  /* ADC SPI 2 SS */
-	       | (1<<1)  /* ADC SPI 2 MISO */
-	       | (1<<2)  /* ADC SPI 2 MOSI */
-	       | (1<<3)  /* ADC SPI 2 SCK */
-	       | (1<<5)  /* USER BUTTON 0 */
-	       | (1<<6); /* USER BUTTON 1 */
+	gpio_1 = BIT(10) /* Shield 1 UART 4 RXD */
+	       | BIT(14) /* Shield 1 UART 4 TXD */
+	       | BIT(15) /* Shield 1 I2C SCL SBCON3 */
+	       | BIT(0)  /* ADC SPI 2 SS */
+	       | BIT(1)  /* ADC SPI 2 MISO */
+	       | BIT(2)  /* ADC SPI 2 MOSI */
+	       | BIT(3)  /* ADC SPI 2 SCK */
+	       | BIT(5)  /* USER BUTTON 0 */
+	       | BIT(6); /* USER BUTTON 1 */
 
 	CMSDK_AHB_GPIO1_DEV->altfuncset = gpio_1;
 
-	gpio_2 = (1<<9)   /* Shield 1 I2C SDA SBCON3 */
-	       | (1<<6)   /* Shield 1 SPI 4 SS */
-	       | (1<<7)   /* Shield 1 SPI 4 MOSI */
-	       | (1<<8)   /* Shield 1 SPI 4 MISO */
-	       | (1<<12); /* Shield 1 SPI 4 SCK */
+	gpio_2 = BIT(9)   /* Shield 1 I2C SDA SBCON3 */
+	       | BIT(6)   /* Shield 1 SPI 4 SS */
+	       | BIT(7)   /* Shield 1 SPI 4 MOSI */
+	       | BIT(8)   /* Shield 1 SPI 4 MISO */
+	       | BIT(12); /* Shield 1 SPI 4 SCK */
 
 	CMSDK_AHB_GPIO2_DEV->altfuncset = gpio_2;
 }
diff -u -p a/boards/arc/em_starterkit/pmodmux.c b/boards/arc/em_starterkit/pmodmux.c
--- a/boards/arc/em_starterkit/pmodmux.c
+++ b/boards/arc/em_starterkit/pmodmux.c
@@ -66,19 +66,19 @@
 /* Pmod1[4:1] are connected to DW GPIO Port C[11:8] */
 #define PM1_UR_GPIO_C		((0 << BIT0) << PM1_OFFSET)
 /* Pmod1[4:1] are connected to DW UART0 signals */
-#define PM1_UR_UART_0		((1 << BIT0) << PM1_OFFSET)
+#define PM1_UR_UART_0		(BIT(BIT0) << PM1_OFFSET)
 
 /* Pmod1[10:7] are connected to DW GPIO Port A[11:8] */
 #define PM1_LR_GPIO_A		((0 << BIT2) << PM1_OFFSET)
 /* Pmod1[10:7] are connected to DW SPI Slave signals */
-#define PM1_LR_SPI_S		((1 << BIT2) << PM1_OFFSET)
+#define PM1_LR_SPI_S		(BIT(BIT2) << PM1_OFFSET)
 /*
  * Pmod2[4:1]	 are connected to DW GPIO Port C[15:12],
  * Pmod2[10:7] are connected to DW GPIO Port A[15:12]
  */
 #define PM2_GPIO_AC		((0 << BIT0) << PM2_OFFSET)
 /* connect I2C to Pmod2[4:1] and halt/run interface to Pmod2[10:7] */
-#define PM2_I2C_HRI		((1 << BIT0) << PM2_OFFSET)
+#define PM2_I2C_HRI		(BIT(BIT0) << PM2_OFFSET)
 /*
  * Pmod3[4:1]  are connected to DW GPIO Port C[19:16],
  * Pmod3[10:7] are connected to DW GPIO Port A[19:16]
@@ -89,7 +89,7 @@
  * Pmod3[2:1]  are connected to DW GPIO Port D[1:0],
  * Pmod3[10:7] are connected to DW GPIO Port D[3:2]
  */
-#define PM3_I2C_GPIO_D		((1 << BIT0) << PM3_OFFSET)
+#define PM3_I2C_GPIO_D		(BIT(BIT0) << PM3_OFFSET)
 /*
  * Pmod4[4:1]  are connected to DW GPIO Port C[23:20],
  * Pmod4[10:7] are connected to DW GPIO Port A[23:20]
@@ -100,28 +100,28 @@
  * Pmod4[2:1]  are connected to DW GPIO Port D[5:4],
  * Pmod4[10:7] are connected to DW GPIO Port D[7:6]
  */
-#define PM4_I2C_GPIO_D		((1 << BIT0) << PM4_OFFSET)
+#define PM4_I2C_GPIO_D		(BIT(BIT0) << PM4_OFFSET)
 
 /* Pmod5[4:1] are connected to DW GPIO Port C[27:24] */
 #define PM5_UR_GPIO_C		((0 << BIT0) << PM5_OFFSET)
 /* Pmod5[4:1] are connected to DW SPI Master signals using CS1_N */
-#define PM5_UR_SPI_M1		((1 << BIT0) << PM5_OFFSET)
+#define PM5_UR_SPI_M1		(BIT(BIT0) << PM5_OFFSET)
 /* Pmod5[10:7] are connected to DW GPIO Port A[27:24] */
 #define PM5_LR_GPIO_A		((0 << BIT2) << PM5_OFFSET)
 /* Pmod5[10:7] are connected to DW SPI Master signals using CS2_N */
-#define PM5_LR_SPI_M2		((1 << BIT2) << PM5_OFFSET)
+#define PM5_LR_SPI_M2		(BIT(BIT2) << PM5_OFFSET)
 
 /* Pmod6[4:1] are connected to DW GPIO Port C[31:28] */
 #define PM6_UR_GPIO_C		((0 << BIT0) << PM6_OFFSET)
 /* Pmod6[4:1] are connected to DW SPI Master signals using CS0_N */
-#define PM6_UR_SPI_M0		((1 << BIT0) << PM6_OFFSET)
+#define PM6_UR_SPI_M0		(BIT(BIT0) << PM6_OFFSET)
 /* Pmod6[10:7] are connected to DW GPIO Port A[31:28] */
 #define PM6_LR_GPIO_A		((0 << BIT2) << PM6_OFFSET)
 /*
  * Pmod6[8:7] are connected to the DW SPI Master chip select signals CS1_N and
  * CS2_N, Pmod6[6:5] are connected to the ARC EM halt and sleep status signals
  */
-#define PM6_LR_CSS_STAT		((1 << BIT2) << PM6_OFFSET)
+#define PM6_LR_CSS_STAT		(BIT(BIT2) << PM6_OFFSET)
 
 
 static int pmod_mux_init(const struct device *device)
diff -u -p a/lib/os/heap.c b/lib/os/heap.c
--- a/lib/os/heap.c
+++ b/lib/os/heap.c
@@ -23,11 +23,11 @@ static void free_list_remove_bidx(struct
 
 	CHECK(!chunk_used(h, c));
 	CHECK(b->next != 0);
-	CHECK(h->avail_buckets & (1 << bidx));
+	CHECK(h->avail_buckets & BIT(bidx));
 
 	if (next_free_chunk(h, c) == c) {
 		/* this is the last chunk */
-		h->avail_buckets &= ~(1 << bidx);
+		h->avail_buckets &= ~BIT(bidx);
 		b->next = 0;
 	} else {
 		chunkid_t first = prev_free_chunk(h, c),
@@ -52,15 +52,15 @@ static void free_list_add_bidx(struct z_
 	struct z_heap_bucket *b = &h->buckets[bidx];
 
 	if (b->next == 0) {
-		CHECK((h->avail_buckets & (1 << bidx)) == 0);
+		CHECK((h->avail_buckets & BIT(bidx)) == 0);
 
 		/* Empty list, first item */
-		h->avail_buckets |= (1 << bidx);
+		h->avail_buckets |= BIT(bidx);
 		b->next = c;
 		set_prev_free_chunk(h, c, c);
 		set_next_free_chunk(h, c, c);
 	} else {
-		CHECK(h->avail_buckets & (1 << bidx));
+		CHECK(h->avail_buckets & BIT(bidx));
 
 		/* Insert before (!) the "next" pointer */
 		chunkid_t second = b->next;
@@ -206,7 +206,7 @@ static chunkid_t alloc_chunk(struct z_he
 	/* Otherwise pick the smallest non-empty bucket guaranteed to
 	 * fit and use that unconditionally.
 	 */
-	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
+	size_t bmask = h->avail_buckets & ~(BIT((bi + 1)) - 1);
 
 	if ((bmask & h->avail_buckets) != 0) {
 		int minbucket = __builtin_ctz(bmask & h->avail_buckets);
diff -u -p a/drivers/ieee802154/ieee802154_nrf5.c b/drivers/ieee802154/ieee802154_nrf5.c
--- a/drivers/ieee802154/ieee802154_nrf5.c
+++ b/drivers/ieee802154/ieee802154_nrf5.c
@@ -49,9 +49,9 @@ struct nrf5_802154_config {
 static struct nrf5_802154_data nrf5_data;
 
 #define ACK_REQUEST_BYTE 1
-#define ACK_REQUEST_BIT (1 << 5)
+#define ACK_REQUEST_BIT BIT(5)
 #define FRAME_PENDING_BYTE 1
-#define FRAME_PENDING_BIT (1 << 4)
+#define FRAME_PENDING_BIT BIT(4)
 
 /* Convenience defines for RADIO */
 #define NRF5_802154_DATA(dev) \
diff -u -p a/drivers/can/can_mcp2515.c b/drivers/can/can_mcp2515.c
--- a/drivers/can/can_mcp2515.c
+++ b/drivers/can/can_mcp2515.c
@@ -314,7 +314,7 @@ static int mcp2515_configure(const struc
 	uint8_t cnf1 = sjw | brp;
 
 	/* CNF2; BTLMODE<7>|SAM<6>|PHSEG1<5:3>|PRSEG<2:0> */
-	const uint8_t btlmode = 1 << 7;
+	const uint8_t btlmode = BIT(7);
 	const uint8_t sam = 0 << 6;
 	const uint8_t phseg1 = (dev_cfg->tq_bs1 - 1) << 3;
 	const uint8_t prseg = (dev_cfg->tq_prop - 1);
diff -u -p a/drivers/pwm/pwm_sifive.c b/drivers/pwm/pwm_sifive.c
--- a/drivers/pwm/pwm_sifive.c
+++ b/drivers/pwm/pwm_sifive.c
@@ -134,7 +134,7 @@ static int pwm_sifive_pin_set(const stru
 	}
 
 	/* We can't support periods greater than we can store in pwmcount */
-	count_max = (1 << (config->cmpwidth + SF_PWMCOUNT_MIN_WIDTH)) - 1;
+	count_max = BIT((config->cmpwidth + SF_PWMCOUNT_MIN_WIDTH)) - 1;
 
 	if (period_cycles > count_max) {
 		LOG_ERR("Requested period is %d but maximum is %d\n",
@@ -143,7 +143,7 @@ static int pwm_sifive_pin_set(const stru
 	}
 
 	/* Calculate the maximum value that pwmcmpX can be set to */
-	max_cmp_val = ((1 << config->cmpwidth) - 1);
+	max_cmp_val = (BIT(config->cmpwidth) - 1);
 
 	/*
 	 * Find the minimum value of pwmscale that will allow us to set the
diff -u -p a/drivers/interrupt_controller/intc_dw.c b/drivers/interrupt_controller/intc_dw.c
--- a/drivers/interrupt_controller/intc_dw.c
+++ b/drivers/interrupt_controller/intc_dw.c
@@ -26,7 +26,7 @@ static ALWAYS_INLINE void dw_ictl_dispat
 	/* Dispatch lower level ISRs depending upon the bit set */
 	while (intr_status) {
 		intr_bitpos = find_lsb_set(intr_status) - 1;
-		intr_status &= ~(1 << intr_bitpos);
+		intr_status &= ~BIT(intr_bitpos);
 		intr_offset = isr_base_offset + intr_bitpos;
 		_sw_isr_table[intr_offset].isr(
 			_sw_isr_table[intr_offset].arg);
@@ -69,9 +69,9 @@ static inline void dw_ictl_intr_enable(c
 		(struct dw_ictl_registers *)config->base_addr;
 
 	if (irq < 32) {
-		regs->irq_inten_l |= (1 << irq);
+		regs->irq_inten_l |= BIT(irq);
 	} else {
-		regs->irq_inten_h |= (1 << (irq - 32));
+		regs->irq_inten_h |= BIT((irq - 32));
 	}
 }
 
@@ -83,9 +83,9 @@ static inline void dw_ictl_intr_disable(
 		(struct dw_ictl_registers *)config->base_addr;
 
 	if (irq < 32) {
-		regs->irq_inten_l &= ~(1 << irq);
+		regs->irq_inten_l &= ~BIT(irq);
 	} else {
-		regs->irq_inten_h &= ~(1 << (irq - 32));
+		regs->irq_inten_h &= ~BIT((irq - 32));
 	}
 }
 
diff -u -p a/drivers/interrupt_controller/intc_gic.c b/drivers/interrupt_controller/intc_gic.c
--- a/drivers/interrupt_controller/intc_gic.c
+++ b/drivers/interrupt_controller/intc_gic.c
@@ -21,7 +21,7 @@ void arm_gic_irq_enable(unsigned int irq
 	int_grp = irq / 32;
 	int_off = irq % 32;
 
-	sys_write32((1 << int_off), (GICD_ISENABLERn + int_grp * 4));
+	sys_write32(BIT(int_off), (GICD_ISENABLERn + int_grp * 4));
 }
 
 void arm_gic_irq_disable(unsigned int irq)
@@ -31,7 +31,7 @@ void arm_gic_irq_disable(unsigned int ir
 	int_grp = irq / 32;
 	int_off = irq % 32;
 
-	sys_write32((1 << int_off), (GICD_ICENABLERn + int_grp * 4));
+	sys_write32(BIT(int_off), (GICD_ICENABLERn + int_grp * 4));
 }
 
 bool arm_gic_irq_is_enabled(unsigned int irq)
@@ -44,7 +44,7 @@ bool arm_gic_irq_is_enabled(unsigned int
 
 	enabler = sys_read32(GICD_ISENABLERn + int_grp * 4);
 
-	return (enabler & (1 << int_off)) != 0;
+	return (enabler & BIT(int_off)) != 0;
 }
 
 void arm_gic_irq_set_priority(
diff -u -p a/drivers/clock_control/beetle_clock_control.c b/drivers/clock_control/beetle_clock_control.c
--- a/drivers/clock_control/beetle_clock_control.c
+++ b/drivers/clock_control/beetle_clock_control.c
@@ -37,13 +37,13 @@ static inline void beetle_set_clock(vola
 
 	switch (state) {
 	case SOC_ACTIVE:
-		base[0] |= (1 << bit);
+		base[0] |= BIT(bit);
 		break;
 	case SOC_SLEEP:
-		base[2] |= (1 << bit);
+		base[2] |= BIT(bit);
 		break;
 	case SOC_DEEPSLEEP:
-		base[4] |= (1 << bit);
+		base[4] |= BIT(bit);
 		break;
 	default:
 		break;
diff -u -p a/drivers/i2c/i2c_ll_stm32_v1.c b/drivers/i2c/i2c_ll_stm32_v1.c
--- a/drivers/i2c/i2c_ll_stm32_v1.c
+++ b/drivers/i2c/i2c_ll_stm32_v1.c
@@ -103,7 +103,7 @@ static void stm32_i2c_reset(const struct
 	LL_I2C_WriteReg(i2c, CR2, cr2);
 
 	/* bit 14 of OAR1 must always be 1 */
-	oar1 |= (1 << 14);
+	oar1 |= BIT(14);
 	LL_I2C_WriteReg(i2c, OAR1, oar1);
 	LL_I2C_WriteReg(i2c, OAR2, oar2);
 	LL_I2C_WriteReg(i2c, CCR, ccr);
diff -u -p a/drivers/usb/device/usb_dc_sam0.c b/drivers/usb/device/usb_dc_sam0.c
--- a/drivers/usb/device/usb_dc_sam0.c
+++ b/drivers/usb/device/usb_dc_sam0.c
@@ -161,7 +161,7 @@ static void usb_sam0_load_padcal(void)
 	pad_transn = (*((uint32_t *)(NVMCTRL_OTP4) +
 			(NVM_USB_PAD_TRANSN_POS / 32)) >>
 		      (NVM_USB_PAD_TRANSN_POS % 32)) &
-		     ((1 << NVM_USB_PAD_TRANSN_SIZE) - 1);
+		     (BIT(NVM_USB_PAD_TRANSN_SIZE) - 1);
 
 	if (pad_transn == 0x1F) {
 		pad_transn = 5U;
@@ -176,7 +176,7 @@ static void usb_sam0_load_padcal(void)
 	pad_transp = (*((uint32_t *)(NVMCTRL_OTP4) +
 			(NVM_USB_PAD_TRANSP_POS / 32)) >>
 		      (NVM_USB_PAD_TRANSP_POS % 32)) &
-		     ((1 << NVM_USB_PAD_TRANSP_SIZE) - 1);
+		     (BIT(NVM_USB_PAD_TRANSP_SIZE) - 1);
 
 	if (pad_transp == 0x1F) {
 		pad_transp = 29U;
@@ -191,7 +191,7 @@ static void usb_sam0_load_padcal(void)
 	pad_trim = (*((uint32_t *)(NVMCTRL_OTP4) +
 		      (NVM_USB_PAD_TRIM_POS / 32)) >>
 		    (NVM_USB_PAD_TRIM_POS % 32)) &
-		   ((1 << NVM_USB_PAD_TRIM_SIZE) - 1);
+		   (BIT(NVM_USB_PAD_TRIM_SIZE) - 1);
 
 	if (pad_trim == 0x7) {
 		pad_trim = 3U;
diff -u -p a/drivers/spi/spi_oc_simple.c b/drivers/spi/spi_oc_simple.c
--- a/drivers/spi/spi_oc_simple.c
+++ b/drivers/spi/spi_oc_simple.c
@@ -108,7 +108,7 @@ int spi_oc_simple_transceive(const struc
 	if (config->cs) {
 		spi_context_cs_control(&spi->ctx, true);
 	} else {
-		sys_write8(1 << config->slave, SPI_OC_SIMPLE_SPSS(info));
+		sys_write8(BIT(config->slave), SPI_OC_SIMPLE_SPSS(info));
 	}
 
 	spi_context_buffers_setup(ctx, tx_bufs, rx_bufs, 1);
diff -u -p a/drivers/watchdog/wdt_cmsdk_apb.c b/drivers/watchdog/wdt_cmsdk_apb.c
--- a/drivers/watchdog/wdt_cmsdk_apb.c
+++ b/drivers/watchdog/wdt_cmsdk_apb.c
@@ -42,14 +42,14 @@ struct wdog_cmsdk_apb {
 #define CMSDK_APB_WDOG_LOAD		(0xFFFFFFFF << 0)
 #define CMSDK_APB_WDOG_RELOAD		(0xE4E1C00 << 0)
 #define CMSDK_APB_WDOG_VALUE		(0xFFFFFFFF << 0)
-#define CMSDK_APB_WDOG_CTRL_RESEN	(0x1 << 1)
-#define CMSDK_APB_WDOG_CTRL_INTEN	(0x1 << 0)
-#define CMSDK_APB_WDOG_INTCLR		(0x1 << 0)
-#define CMSDK_APB_WDOG_RAWINTSTAT	(0x1 << 0)
-#define CMSDK_APB_WDOG_MASKINTSTAT	(0x1 << 0)
-#define CMSDK_APB_WDOG_LOCK		(0x1 << 0)
-#define CMSDK_APB_WDOG_INTEGTESTEN	(0x1 << 0)
-#define CMSDK_APB_WDOG_INTEGTESTOUTSET	(0x1 << 1)
+#define CMSDK_APB_WDOG_CTRL_RESEN	BIT(1)
+#define CMSDK_APB_WDOG_CTRL_INTEN	BIT(0)
+#define CMSDK_APB_WDOG_INTCLR		BIT(0)
+#define CMSDK_APB_WDOG_RAWINTSTAT	BIT(0)
+#define CMSDK_APB_WDOG_MASKINTSTAT	BIT(0)
+#define CMSDK_APB_WDOG_LOCK		BIT(0)
+#define CMSDK_APB_WDOG_INTEGTESTEN	BIT(0)
+#define CMSDK_APB_WDOG_INTEGTESTOUTSET	BIT(1)
 
 /*
  * Value written to the LOCK register to lock or unlock the write access
diff -u -p a/drivers/adc/adc_sam_afec.c b/drivers/adc/adc_sam_afec.c
--- a/drivers/adc/adc_sam_afec.c
+++ b/drivers/adc/adc_sam_afec.c
@@ -84,7 +84,7 @@ static int adc_sam_channel_setup(const s
 		/* A value of 0 in this register is a gain of 1. */
 		break;
 	case ADC_GAIN_1_2:
-		afec->AFEC_CGR |= (1 << (channel_id * 2U));
+		afec->AFEC_CGR |= BIT((channel_id * 2U));
 		break;
 	case ADC_GAIN_1_4:
 		afec->AFEC_CGR |= (2 << (channel_id * 2U));
@@ -135,10 +135,10 @@ static void adc_sam_start_conversion(con
 	/* Enable the ADC channel. This also enables/selects the channel pin as
 	 * an input to the AFEC (50.5.1 SAM E70 datasheet).
 	 */
-	afec->AFEC_CHER = (1 << data->channel_id);
+	afec->AFEC_CHER = BIT(data->channel_id);
 
 	/* Enable the interrupt for the channel. */
-	afec->AFEC_IER = (1 << data->channel_id);
+	afec->AFEC_IER = BIT(data->channel_id);
 
 	/* Start the conversions. */
 	afec->AFEC_CR = AFEC_CR_START;
diff -u -p a/drivers/sensor/iis2dh/iis2dh_spi.c b/drivers/sensor/iis2dh/iis2dh_spi.c
--- a/drivers/sensor/iis2dh/iis2dh_spi.c
+++ b/drivers/sensor/iis2dh/iis2dh_spi.c
@@ -17,7 +17,7 @@
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
 #define IIS2DH_SPI_READM	(3 << 6)	/* 0xC0 */
-#define IIS2DH_SPI_WRITEM	(1 << 6)	/* 0x40 */
+#define IIS2DH_SPI_WRITEM	BIT(6)	/* 0x40 */
 
 LOG_MODULE_DECLARE(IIS2DH, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/wsen_itds/itds.c b/drivers/sensor/wsen_itds/itds.c
--- a/drivers/sensor/wsen_itds/itds.c
+++ b/drivers/sensor/wsen_itds/itds.c
@@ -348,13 +348,13 @@ static int itds_init(const struct device
 	}
 
 	ret = i2c_reg_update_byte(ddata->i2c, cfg->i2c_addr, ITDS_REG_CTRL1,
-				  ITDS_MASK_MODE, 1 << cfg->def_op_mode);
+				  ITDS_MASK_MODE, BIT(cfg->def_op_mode));
 	if (ret) {
 		LOG_ERR("set operating mode fail %d", ret);
 		return ret;
 	}
 
-	ddata->op_mode = 1 << cfg->def_op_mode;
+	ddata->op_mode = BIT(cfg->def_op_mode);
 
 	ret = itds_get_odr_for_index(dev, cfg->def_odr, &freq, &mfreq);
 	if (ret) {
diff -u -p a/drivers/sensor/bma280/bma280_trigger.c b/drivers/sensor/bma280/bma280_trigger.c
--- a/drivers/sensor/bma280/bma280_trigger.c
+++ b/drivers/sensor/bma280/bma280_trigger.c
@@ -44,7 +44,7 @@ int bma280_attr_set(const struct device 
 	if (attr == SENSOR_ATTR_SLOPE_TH) {
 		/* slope_th = (val * 10^6 * 2^10) / BMA280_PMU_FULL_RAGE */
 		slope_th = (uint64_t)val->val1 * 1000000U + (uint64_t)val->val2;
-		slope_th = (slope_th * (1 << 10)) / BMA280_PMU_FULL_RANGE;
+		slope_th = (slope_th * BIT(10)) / BMA280_PMU_FULL_RANGE;
 		if (i2c_reg_write_byte(drv_data->i2c, BMA280_I2C_ADDRESS,
 				       BMA280_REG_SLOPE_TH, (uint8_t)slope_th)
 				       < 0) {
diff -u -p a/drivers/sensor/bmc150_magn/bmc150_magn.c b/drivers/sensor/bmc150_magn/bmc150_magn.c
--- a/drivers/sensor/bmc150_magn/bmc150_magn.c
+++ b/drivers/sensor/bmc150_magn/bmc150_magn.c
@@ -283,7 +283,7 @@ static int32_t bmc150_magn_compensate_z(
 	val = (((((int32_t)(z - tregs->z4)) << 15) - ((((int32_t)tregs->z3) *
 	      ((int32_t)(((int16_t)rhall) - ((int16_t)tregs->xyz1)))) >> 2)) /
 	      (tregs->z2 + ((int16_t)(((((int32_t)tregs->z1) *
-	      ((((int16_t)rhall) << 1))) + (1 << 15)) >> 16))));
+	      ((((int16_t)rhall) << 1))) + BIT(15)) >> 16))));
 
 	return val;
 }
diff -u -p a/drivers/sensor/lsm6ds0/lsm6ds0.c b/drivers/sensor/lsm6ds0/lsm6ds0.c
--- a/drivers/sensor/lsm6ds0/lsm6ds0.c
+++ b/drivers/sensor/lsm6ds0/lsm6ds0.c
@@ -30,7 +30,7 @@ static inline int lsm6ds0_reboot(const s
 	if (i2c_reg_update_byte(data->i2c_master, config->i2c_slave_addr,
 				LSM6DS0_REG_CTRL_REG8,
 				LSM6DS0_MASK_CTRL_REG8_BOOT,
-				1 << LSM6DS0_SHIFT_CTRL_REG8_BOOT) < 0) {
+				BIT(LSM6DS0_SHIFT_CTRL_REG8_BOOT)) < 0) {
 		return -EIO;
 	}
 
@@ -471,9 +471,9 @@ static int lsm6ds0_init_chip(const struc
 				LSM6DS0_MASK_CTRL_REG8_BDU |
 				LSM6DS0_MASK_CTRL_REG8_BLE |
 				LSM6DS0_MASK_CTRL_REG8_IF_ADD_INC,
-				(1 << LSM6DS0_SHIFT_CTRL_REG8_BDU) |
+				BIT(LSM6DS0_SHIFT_CTRL_REG8_BDU) |
 				(0 << LSM6DS0_SHIFT_CTRL_REG8_BLE) |
-				(1 << LSM6DS0_SHIFT_CTRL_REG8_IF_ADD_INC))
+				BIT(LSM6DS0_SHIFT_CTRL_REG8_IF_ADD_INC))
 				< 0) {
 		LOG_DBG("failed to set BDU, BLE and burst");
 		return -EIO;
diff -u -p a/drivers/sensor/ism330dhcx/ism330dhcx_spi.c b/drivers/sensor/ism330dhcx/ism330dhcx_spi.c
--- a/drivers/sensor/ism330dhcx/ism330dhcx_spi.c
+++ b/drivers/sensor/ism330dhcx/ism330dhcx_spi.c
@@ -16,7 +16,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define ISM330DHCX_SPI_READ		(1 << 7)
+#define ISM330DHCX_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(ISM330DHCX, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/lsm9ds0_gyro/lsm9ds0_gyro.c b/drivers/sensor/lsm9ds0_gyro/lsm9ds0_gyro.c
--- a/drivers/sensor/lsm9ds0_gyro/lsm9ds0_gyro.c
+++ b/drivers/sensor/lsm9ds0_gyro/lsm9ds0_gyro.c
@@ -302,7 +302,7 @@ static int lsm9ds0_gyro_init_chip(const 
 				LSM9DS0_GYRO_REG_CTRL_REG4_G,
 				LSM9DS0_GYRO_MASK_CTRL_REG4_G_BDU |
 				LSM9DS0_GYRO_MASK_CTRL_REG4_G_BLE,
-				(1 << LSM9DS0_GYRO_SHIFT_CTRL_REG4_G_BDU) |
+				BIT(LSM9DS0_GYRO_SHIFT_CTRL_REG4_G_BDU) |
 				(0 << LSM9DS0_GYRO_SHIFT_CTRL_REG4_G_BLE))
 				< 0) {
 		LOG_DBG("failed to set BDU and BLE");
diff -u -p a/drivers/bluetooth/hci/h5.c b/drivers/bluetooth/hci/h5.c
--- a/drivers/bluetooth/hci/h5.c
+++ b/drivers/bluetooth/hci/h5.c
@@ -81,7 +81,7 @@ static bool reliable_packet(uint8_t type
 
 #define H5_SET_SEQ(hdr, seq)	((hdr)[0] |= (seq))
 #define H5_SET_ACK(hdr, ack)	((hdr)[0] |= (ack) << 3)
-#define H5_SET_RELIABLE(hdr)	((hdr)[0] |= 1 << 7)
+#define H5_SET_RELIABLE(hdr)	((hdr)[0] |= BIT(7))
 #define H5_SET_TYPE(hdr, type)	((hdr)[1] |= type)
 #define H5_SET_LEN(hdr, len)	(((hdr)[1] |= ((len) & 0x0f) << 4), \
 				 ((hdr)[2] |= (len) >> 4))
diff -u -p a/drivers/dma/dma_sam_xdmac.c b/drivers/dma/dma_sam_xdmac.c
--- a/drivers/dma/dma_sam_xdmac.c
+++ b/drivers/dma/dma_sam_xdmac.c
@@ -64,7 +64,7 @@ static void sam_xdmac_isr(const struct d
 	isr_status = xdmac->XDMAC_GIS;
 
 	for (int channel = 0; channel < DMA_CHANNELS_NO; channel++) {
-		if (!(isr_status & (1 << channel))) {
+		if (!(isr_status & BIT(channel))) {
 			continue;
 		}
 
diff -u -p a/drivers/dma/dma_pl330.c b/drivers/dma/dma_pl330.c
--- a/drivers/dma/dma_pl330.c
+++ b/drivers/dma/dma_pl330.c
@@ -24,7 +24,7 @@ LOG_MODULE_REGISTER(dma_pl330);
 #define DEV_DATA(dev) \
 	((struct dma_pl330_dev_data *const)(dev)->data)
 
-#define BYTE_WIDTH(burst_size) (1 << (burst_size))
+#define BYTE_WIDTH(burst_size) BIT((burst_size))
 
 static int dma_pl330_submit(const struct device *dev, uint64_t dst,
 			    uint64_t src, uint32_t channel, uint32_t size);
@@ -337,7 +337,7 @@ static int dma_pl330_xfer(const struct d
 
 	dma_pl330_calc_burstsz_len(ch_handle, dst, src, size);
 
-	max_size = GET_MAX_DMA_SIZE((1 << ch_handle->src_burst_sz),
+	max_size = GET_MAX_DMA_SIZE(BIT(ch_handle->src_burst_sz),
 				    ch_handle->src_burst_len);
 
 	if (size > max_size) {
diff -u -p a/drivers/gpio/gpio_mcux_lpc.c b/drivers/gpio/gpio_mcux_lpc.c
--- a/drivers/gpio/gpio_mcux_lpc.c
+++ b/drivers/gpio/gpio_mcux_lpc.c
@@ -31,7 +31,7 @@
 #define PIN_TO_INPUT_MUX_CONNECTION(port, pin) \
 	((PINTSEL_PMUX_ID << PMUX_SHIFT) + (32 * port) + (pin))
 
-#define NO_PINT_INT ((1 << sizeof(pint_pin_int_t)) - 1)
+#define NO_PINT_INT (BIT(sizeof(pint_pin_int_t)) - 1)
 
 struct gpio_mcux_lpc_config {
 	/* gpio_driver_config needs to be first */
diff -u -p a/drivers/gpio/gpio_stellaris.c b/drivers/gpio/gpio_stellaris.c
--- a/drivers/gpio/gpio_stellaris.c
+++ b/drivers/gpio/gpio_stellaris.c
@@ -40,7 +40,7 @@ struct gpio_stellaris_runtime {
 #define GPIO_REG_ADDR(base, offset) (base + offset)
 
 #define GPIO_RW_ADDR(base, offset, p)			 \
-	(GPIO_REG_ADDR(base, offset) | (1 << (p + 2)))
+	(GPIO_REG_ADDR(base, offset) | BIT((p + 2)))
 
 #define GPIO_RW_MASK_ADDR(base, offset, mask)		 \
 	(GPIO_REG_ADDR(base, offset) | (mask << 2))
diff -u -p a/drivers/serial/uart_cmsdk_apb.c b/drivers/serial/uart_cmsdk_apb.c
--- a/drivers/serial/uart_cmsdk_apb.c
+++ b/drivers/serial/uart_cmsdk_apb.c
@@ -40,25 +40,25 @@ struct uart_cmsdk_apb {
 
 /* UART Bits */
 /* CTRL Register */
-#define UART_TX_EN	(1 << 0)
-#define UART_RX_EN	(1 << 1)
-#define UART_TX_IN_EN	(1 << 2)
-#define UART_RX_IN_EN	(1 << 3)
-#define UART_TX_OV_EN	(1 << 4)
-#define UART_RX_OV_EN	(1 << 5)
-#define UART_HS_TM_TX	(1 << 6)
+#define UART_TX_EN	BIT(0)
+#define UART_RX_EN	BIT(1)
+#define UART_TX_IN_EN	BIT(2)
+#define UART_RX_IN_EN	BIT(3)
+#define UART_TX_OV_EN	BIT(4)
+#define UART_RX_OV_EN	BIT(5)
+#define UART_HS_TM_TX	BIT(6)
 
 /* STATE Register */
-#define UART_TX_BF	(1 << 0)
-#define UART_RX_BF	(1 << 1)
-#define UART_TX_B_OV	(1 << 2)
-#define UART_RX_B_OV	(1 << 3)
+#define UART_TX_BF	BIT(0)
+#define UART_RX_BF	BIT(1)
+#define UART_TX_B_OV	BIT(2)
+#define UART_RX_B_OV	BIT(3)
 
 /* INTSTATUS Register */
-#define UART_TX_IN	(1 << 0)
-#define UART_RX_IN	(1 << 1)
-#define UART_TX_OV_IN	(1 << 2)
-#define UART_RX_OV_IN	(1 << 3)
+#define UART_TX_IN	BIT(0)
+#define UART_RX_IN	BIT(1)
+#define UART_TX_OV_IN	BIT(2)
+#define UART_RX_OV_IN	BIT(3)
 
 /* Device data structure */
 struct uart_cmsdk_apb_dev_data {
diff -u -p a/soc/arm/nordic_nrf/timing.c b/soc/arm/nordic_nrf/timing.c
--- a/soc/arm/nordic_nrf/timing.c
+++ b/soc/arm/nordic_nrf/timing.c
@@ -12,7 +12,7 @@
 
 #if defined(CONFIG_NRF_RTC_TIMER)
 
-#define CYCLES_PER_SEC (16000000 / (1 << NRF_TIMER2->PRESCALER))
+#define CYCLES_PER_SEC (16000000 / BIT(NRF_TIMER2->PRESCALER))
 
 void timing_init(void)
 {
diff -u -p a/soc/riscv/riscv-privilege/common/soc_common_irq.c b/soc/riscv/riscv-privilege/common/soc_common_irq.c
--- a/soc/riscv/riscv-privilege/common/soc_common_irq.c
+++ b/soc/riscv/riscv-privilege/common/soc_common_irq.c
@@ -31,7 +31,7 @@ void arch_irq_enable(unsigned int irq)
 	 */
 	__asm__ volatile ("csrrs %0, mie, %1\n"
 			  : "=r" (mie)
-			  : "r" (1 << irq));
+			  : "r" (BIT(irq)));
 }
 
 void arch_irq_disable(unsigned int irq)
@@ -54,7 +54,7 @@ void arch_irq_disable(unsigned int irq)
 	 */
 	__asm__ volatile ("csrrc %0, mie, %1\n"
 			  : "=r" (mie)
-			  : "r" (1 << irq));
+			  : "r" (BIT(irq)));
 };
 
 void arch_irq_priority_set(unsigned int irq, unsigned int prio)
@@ -86,7 +86,7 @@ int arch_irq_is_enabled(unsigned int irq
 
 	__asm__ volatile ("csrr %0, mie" : "=r" (mie));
 
-	return !!(mie & (1 << irq));
+	return !!(mie & BIT(irq));
 }
 
 #if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
diff -u -p a/subsys/net/lib/sockets/socketpair.c b/subsys/net/lib/sockets/socketpair.c
--- a/subsys/net/lib/sockets/socketpair.c
+++ b/subsys/net/lib/sockets/socketpair.c
@@ -24,7 +24,7 @@ enum {
 };
 
 enum {
-	SPAIR_FLAG_NONBLOCK = (1 << 0), /**< socket is non-blocking */
+	SPAIR_FLAG_NONBLOCK = BIT(0), /**< socket is non-blocking */
 };
 
 #define SPAIR_FLAGS_DEFAULT 0
diff -u -p a/subsys/net/lib/http/http_parser_url.c b/subsys/net/lib/http/http_parser_url.c
--- a/subsys/net/lib/http/http_parser_url.c
+++ b/subsys/net/lib/http/http_parser_url.c
@@ -33,7 +33,7 @@
 #ifndef BIT_AT
 # define BIT_AT(a, i)                                                \
 	(!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \
-	 (1 << ((unsigned int) (i) & 7))))
+	 BIT(((unsigned int)(i) & 7))))
 #endif
 
 /* Set the mark FOR; non-destructive if mark is already set */
@@ -385,7 +385,7 @@ int http_parse_host(const char *buf, str
 	const char *p;
 
 	buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;
-	assert(u->field_set & (1 << UF_HOST));
+	assert(u->field_set & BIT(UF_HOST));
 
 	u->field_data[UF_HOST].len = 0U;
 
@@ -422,7 +422,7 @@ int http_parse_host(const char *buf, str
 			if (s != s_http_host_port) {
 				u->field_data[UF_PORT].off = p - buf;
 				u->field_data[UF_PORT].len = 0U;
-				u->field_set |= (1 << UF_PORT);
+				u->field_set |= BIT(UF_PORT);
 			}
 			u->field_data[UF_PORT].len++;
 			break;
@@ -431,7 +431,7 @@ int http_parse_host(const char *buf, str
 			if (s != s_http_userinfo) {
 				u->field_data[UF_USERINFO].off = p - buf;
 				u->field_data[UF_USERINFO].len = 0U;
-				u->field_set |= (1 << UF_USERINFO);
+				u->field_set |= BIT(UF_USERINFO);
 			}
 			u->field_data[UF_USERINFO].len++;
 			break;
@@ -534,29 +534,29 @@ http_parser_parse_url(const char *buf, s
 		u->field_data[uf].off = p - buf;
 		u->field_data[uf].len = 1U;
 
-		u->field_set |= (1 << uf);
+		u->field_set |= BIT(uf);
 		old_uf = uf;
 	}
 
 	/* host must be present if there is a schema */
 	/* parsing http:///toto will fail */
-	if ((u->field_set & (1 << UF_SCHEMA)) &&
-			(u->field_set & (1 << UF_HOST)) == 0U) {
+	if ((u->field_set & BIT(UF_SCHEMA)) &&
+			(u->field_set & BIT(UF_HOST)) == 0U) {
 		return 1;
 	}
 
-	if (u->field_set & (1 << UF_HOST)) {
+	if (u->field_set & BIT(UF_HOST)) {
 		if (http_parse_host(buf, u, found_at) != 0) {
 			return 1;
 		}
 	}
 
 	/* CONNECT requests can only contain "hostname:port" */
-	if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
+	if (is_connect && u->field_set != (BIT(UF_HOST)|BIT(UF_PORT))) {
 		return 1;
 	}
 
-	if (u->field_set & (1 << UF_PORT)) {
+	if (u->field_set & BIT(UF_PORT)) {
 		/* Don't bother with endp; we've already validated the string */
 		unsigned long v;
 
diff -u -p a/subsys/net/ip/tcp.c b/subsys/net/ip/tcp.c
--- a/subsys/net/ip/tcp.c
+++ b/subsys/net/ip/tcp.c
@@ -1264,41 +1264,41 @@ static void validate_state_transition(en
 				      enum net_tcp_state new)
 {
 	static const uint16_t valid_transitions[] = {
-		[NET_TCP_CLOSED] = 1 << NET_TCP_LISTEN |
-			1 << NET_TCP_SYN_SENT |
-			/* Initial transition from closed->established when
+		[NET_TCP_CLOSED] = BIT(NET_TCP_LISTEN) |
+		BIT(NET_TCP_SYN_SENT) |
+		/* Initial transition from closed->established when
 			 * socket is accepted.
 			 */
-			1 << NET_TCP_ESTABLISHED,
-		[NET_TCP_LISTEN] = 1 << NET_TCP_SYN_RCVD |
-			1 << NET_TCP_SYN_SENT |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_SYN_RCVD] = 1 << NET_TCP_FIN_WAIT_1 |
-			1 << NET_TCP_ESTABLISHED |
-			1 << NET_TCP_LISTEN |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_SYN_SENT] = 1 << NET_TCP_CLOSED |
-			1 << NET_TCP_ESTABLISHED |
-			1 << NET_TCP_SYN_RCVD |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_ESTABLISHED] = 1 << NET_TCP_CLOSE_WAIT |
-			1 << NET_TCP_FIN_WAIT_1 |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_CLOSE_WAIT] = 1 << NET_TCP_LAST_ACK |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_LAST_ACK] = 1 << NET_TCP_CLOSED,
-		[NET_TCP_FIN_WAIT_1] = 1 << NET_TCP_CLOSING |
-			1 << NET_TCP_FIN_WAIT_2 |
-			1 << NET_TCP_TIME_WAIT |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_FIN_WAIT_2] = 1 << NET_TCP_TIME_WAIT |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_CLOSING] = 1 << NET_TCP_TIME_WAIT |
-			1 << NET_TCP_CLOSED,
-		[NET_TCP_TIME_WAIT] = 1 << NET_TCP_CLOSED
+		BIT(NET_TCP_ESTABLISHED),
+		[NET_TCP_LISTEN] = BIT(NET_TCP_SYN_RCVD) |
+		BIT(NET_TCP_SYN_SENT) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_SYN_RCVD] = BIT(NET_TCP_FIN_WAIT_1) |
+		BIT(NET_TCP_ESTABLISHED) |
+		BIT(NET_TCP_LISTEN) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_SYN_SENT] = BIT(NET_TCP_CLOSED) |
+		BIT(NET_TCP_ESTABLISHED) |
+		BIT(NET_TCP_SYN_RCVD) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_ESTABLISHED] = BIT(NET_TCP_CLOSE_WAIT) |
+		BIT(NET_TCP_FIN_WAIT_1) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_CLOSE_WAIT] = BIT(NET_TCP_LAST_ACK) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_LAST_ACK] = BIT(NET_TCP_CLOSED),
+		[NET_TCP_FIN_WAIT_1] = BIT(NET_TCP_CLOSING) |
+		BIT(NET_TCP_FIN_WAIT_2) |
+		BIT(NET_TCP_TIME_WAIT) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_FIN_WAIT_2] = BIT(NET_TCP_TIME_WAIT) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_CLOSING] = BIT(NET_TCP_TIME_WAIT) |
+		BIT(NET_TCP_CLOSED),
+		[NET_TCP_TIME_WAIT] = BIT(NET_TCP_CLOSED)
 	};
 
-	if (!(valid_transitions[current] & 1 << new)) {
+	if (!(valid_transitions[current] & BIT(new))) {
 		NET_DBG("Invalid state transition: %s (%d) => %s (%d)",
 			net_tcp_state_str(current), current,
 			net_tcp_state_str(new), new);
diff -u -p a/subsys/bluetooth/mesh/pb_adv.c b/subsys/bluetooth/mesh/pb_adv.c
--- a/subsys/bluetooth/mesh/pb_adv.c
+++ b/subsys/bluetooth/mesh/pb_adv.c
@@ -41,7 +41,7 @@
 #define LINK_CLOSE      0x02
 
 #define XACT_SEG_DATA(_seg) (&link.rx.buf->data[20 + ((_seg - 1) * 23)])
-#define XACT_SEG_RECV(_seg) (link.rx.seg &= ~(1 << (_seg)))
+#define XACT_SEG_RECV(_seg) (link.rx.seg &= ~BIT((_seg)))
 
 #define XACT_ID_MAX  0x7f
 #define XACT_ID_NVAL 0xff
@@ -471,7 +471,7 @@ static void gen_prov_start(struct prov_r
 		seg = link.rx.seg;
 	}
 
-	link.rx.seg = seg & ((1 << (START_LAST_SEG(rx->gpc) + 1)) - 1);
+	link.rx.seg = seg & (BIT((START_LAST_SEG(rx->gpc) + 1)) - 1);
 	memcpy(link.rx.buf->data, buf->data, buf->len);
 	XACT_SEG_RECV(0);
 
diff -u -p a/subsys/bluetooth/controller/ll_sw/lll_chan.c b/subsys/bluetooth/controller/ll_sw/lll_chan.c
--- a/subsys/bluetooth/controller/ll_sw/lll_chan.c
+++ b/subsys/bluetooth/controller/ll_sw/lll_chan.c
@@ -29,7 +29,7 @@ uint8_t lll_chan_sel_1(uint8_t *chan_use
 	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
 	*chan_use = chan_next;
 
-	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
+	if ((chan_map[chan_next >> 3] & BIT((chan_next % 8))) == 0U) {
 		uint8_t chan_index;
 
 		chan_index = chan_next % chan_count;
@@ -53,7 +53,7 @@ uint8_t lll_chan_sel_2(uint16_t counter,
 	prn_e = chan_prn(counter, chan_id);
 	chan_next = prn_e % 37;
 
-	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
+	if ((chan_map[chan_next >> 3] & BIT((chan_next % 8))) == 0U) {
 		uint8_t chan_index;
 
 		chan_index = ((uint32_t)chan_count * prn_e) >> 16;
diff -u -p a/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c b/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c
--- a/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c
+++ b/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c
@@ -687,8 +687,8 @@ void radio_aa_set(uint8_t *aa)
 	GENFSK->NTW_ADR_CTRL |= GENFSK_NTW_ADR_CTRL_NTW_ADR0_SZ(3) |
 				GENFSK_NTW_ADR_CTRL_NTW_ADR_THR0(0);
 
-	GENFSK->NTW_ADR_CTRL |= (uint32_t) ((1 << 0) <<
-			GENFSK_NTW_ADR_CTRL_NTW_ADR_EN_SHIFT);
+	GENFSK->NTW_ADR_CTRL |= (uint32_t) (BIT(0) <<
+					    GENFSK_NTW_ADR_CTRL_NTW_ADR_EN_SHIFT);
 
 	/*
 	 * The Access Address must be written in the packet buffer
diff -u -p a/subsys/disk/disk_access_spi_sdhc.c b/subsys/disk/disk_access_spi_sdhc.c
--- a/subsys/disk/disk_access_spi_sdhc.c
+++ b/subsys/disk/disk_access_spi_sdhc.c
@@ -590,7 +590,7 @@ static int sdhc_spi_detect(struct sdhc_s
 		 * lengths greater than 512 bytes, but forces 512 byte block transfers
 		 * instead.
 		 */
-		readbllen = buf[5] & ((1 << 4) - 1);
+		readbllen = buf[5] & (BIT(4) - 1);
 		if ((readbllen < 9) || (readbllen > 11)) {
 			/* Invalid maximum read data block length (cf. section 5.3.2) */
 			return -ENOTSUP;
@@ -599,14 +599,14 @@ static int sdhc_spi_detect(struct sdhc_s
 		 * by bits 47..49 plus 2 raised to the power of 2 in maximum read data
 		 * blocks.
 		 */
-		csize = (sys_get_be32(&buf[6]) >> 14) & ((1 << 12) - 1);
-		csizemult = (uint8_t) ((sys_get_be16(&buf[9]) >> 7) & ((1 << 3) - 1));
+		csize = (sys_get_be32(&buf[6]) >> 14) & (BIT(12) - 1);
+		csizemult = (uint8_t) ((sys_get_be16(&buf[9]) >> 7) & (BIT(3) - 1));
 		data->sector_count = ((csize + 1) << (csizemult + 2 + readbllen - 9));
 		break;
 	case SDHC_CSD_V2:
 		/* Bits 48..69 are the capacity of the card in 512 KiB units, minus 1.
 		 */
-		csize = sys_get_be32(&buf[6]) & ((1 << 22) - 1);
+		csize = sys_get_be32(&buf[6]) & (BIT(22) - 1);
 		if (csize < 4112) {
 			/* Invalid capacity (cf. section 5.3.3) */
 			return -ENOTSUP;
diff -u -p a/subsys/logging/log_backend_swo.c b/subsys/logging/log_backend_swo.c
--- a/subsys/logging/log_backend_swo.c
+++ b/subsys/logging/log_backend_swo.c
@@ -97,7 +97,7 @@ static void log_backend_swo_init(void)
 	/* Enable ITM, set TraceBusID=1, no local timestamp generation */
 	ITM->TCR  = 0x0001000D;
 	/* Enable stimulus port used by the logger */
-	ITM->TER  = 1 << ITM_PORT_LOGGER;
+	ITM->TER  = BIT(ITM_PORT_LOGGER);
 }
 
 static void log_backend_swo_panic(struct log_backend const *const backend)
diff -u -p a/tests/arch/xtensa_asm2/src/main.c b/tests/arch/xtensa_asm2/src/main.c
--- a/tests/arch/xtensa_asm2/src/main.c
+++ b/tests/arch/xtensa_asm2/src/main.c
@@ -149,7 +149,7 @@ int test_reg_spill(void)
 			continue;
 		}
 
-		if (spill_ws1 != 1 << spill_wb1) {
+		if (spill_ws1 != BIT(spill_wb1)) {
 			printk("WINDOWSTART should show exactly one frame at WINDOWBASE\n");
 			ok = 0;
 		}
@@ -204,7 +204,7 @@ int test_highreg_save(void)
 
 	fill_window(testfw);
 	printk("testfw wb %d ws 0x%x\n", testfw_wb, testfw_ws);
-	ok = ok && (testfw_ws == ((1 << (XCHAL_NUM_AREGS / 4)) - 1));
+	ok = ok && (testfw_ws == (BIT((XCHAL_NUM_AREGS / 4)) - 1));
 
 	for (int i = 0; i < ARRAY_SIZE(highreg_tests); i++) {
 		printk("\nHighreg test %d\n", i);
@@ -365,7 +365,7 @@ void disable_timer(void)
 	int ie;
 
 	__asm__ volatile("rsr.intenable %0" : "=r"(ie));
-	ie &= ~(1<<TIMER_INT);
+	ie &= ~BIT(TIMER_INT);
 	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(ie));
 }
 
@@ -374,7 +374,7 @@ void enable_timer(void)
 	int ie;
 
 	__asm__ volatile("rsr.intenable %0" : "=r"(ie));
-	ie |= (1<<TIMER_INT);
+	ie |= BIT(TIMER_INT);
 	__asm__ volatile("wsr.intenable %0; rsync" : : "r"(ie));
 }
 
diff -u -p a/tests/lib/cmsis_dsp/statistics/src/q7.c b/tests/lib/cmsis_dsp/statistics/src/q7.c
--- a/tests/lib/cmsis_dsp/statistics/src/q7.c
+++ b/tests/lib/cmsis_dsp/statistics/src/q7.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)20)
 #define ABS_ERROR_THRESH_Q7	((q7_t)20)
-#define ABS_ERROR_THRESH_Q31	((q31_t)(1 << 15))
+#define ABS_ERROR_THRESH_Q31	((q31_t)(BIT(15)))
 
 static void test_arm_max_q7(
 	const q7_t *input1, int ref_index, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/support/src/q7.c b/tests/lib/cmsis_dsp/support/src/q7.c
--- a/tests/lib/cmsis_dsp/support/src/q7.c
+++ b/tests/lib/cmsis_dsp/support/src/q7.c
@@ -15,8 +15,8 @@
 
 #define REL_ERROR_THRESH	(1.0e-5)
 #define ABS_ERROR_THRESH_Q7	((q7_t)10)
-#define ABS_ERROR_THRESH_Q15	((q15_t)(1 << 8))
-#define ABS_ERROR_THRESH_Q31	((q31_t)(1 << 24))
+#define ABS_ERROR_THRESH_Q15	((q15_t)(BIT(8)))
+#define ABS_ERROR_THRESH_Q31	((q31_t)(BIT(24)))
 
 static void test_arm_copy_q7(const q7_t *input1, size_t length)
 {
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/unary_q15.c b/tests/lib/cmsis_dsp/matrix/src/unary_q15.c
--- a/tests/lib/cmsis_dsp/matrix/src/unary_q15.c
+++ b/tests/lib/cmsis_dsp/matrix/src/unary_q15.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)70)
 #define ABS_ERROR_THRESH_Q15	((q15_t)2)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 16))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(16)))
 
 #define NUM_MATRICES		(ARRAY_SIZE(in_dims) / 2)
 #define MAX_MATRIX_DIM		(40)
diff -u -p a/tests/portability/cmsis_rtos_v1/src/signal.c b/tests/portability/cmsis_rtos_v1/src/signal.c
--- a/tests/portability/cmsis_rtos_v1/src/signal.c
+++ b/tests/portability/cmsis_rtos_v1/src/signal.c
@@ -19,8 +19,8 @@
 #define SIGNAL_FLAG 0x00000001
 #define ISR_SIGNAL 0x50
 
-#define SIGNAL_ALL_FLAGS ((1 << osFeature_Signals) - 1)
-#define SIGNAL_OUTOFLIMIT_FLAG ((1 << (osFeature_Signals + 1))-1)
+#define SIGNAL_ALL_FLAGS (BIT(osFeature_Signals) - 1)
+#define SIGNAL_OUTOFLIMIT_FLAG (BIT((osFeature_Signals + 1))-1)
 
 void Thread_1(void const *arg)
 {
diff -u -p a/samples/subsys/ipc/openamp/remote/src/main.c b/samples/subsys/ipc/openamp/remote/src/main.c
--- a/samples/subsys/ipc/openamp/remote/src/main.c
+++ b/samples/subsys/ipc/openamp/remote/src/main.c
@@ -68,7 +68,7 @@ static unsigned char virtio_get_status(s
 
 static uint32_t virtio_get_features(struct virtio_device *vdev)
 {
-	return 1 << VIRTIO_RPMSG_F_NS;
+	return BIT(VIRTIO_RPMSG_F_NS);
 }
 
 static void virtio_notify(struct virtqueue *vq)
diff -u -p a/arch/xtensa/core/fatal.c b/arch/xtensa/core/fatal.c
--- a/arch/xtensa/core/fatal.c
+++ b/arch/xtensa/core/fatal.c
@@ -104,7 +104,7 @@ XTENSA_ERR_NORET void FatalErrorHandler(
 XTENSA_ERR_NORET void ReservedInterruptHandler(unsigned int intNo)
 {
 	LOG_ERR("INTENABLE = 0x%x INTERRUPT = 0x%x (%x)",
-		get_sreg(INTENABLE), (1 << intNo), intNo);
+		get_sreg(INTENABLE), BIT(intNo), intNo);
 	z_xtensa_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 }
 
diff -u -p a/boards/arm/v2m_beetle/pinmux.c b/boards/arm/v2m_beetle/pinmux.c
--- a/boards/arm/v2m_beetle/pinmux.c
+++ b/boards/arm/v2m_beetle/pinmux.c
@@ -99,40 +99,40 @@ static void arm_v2m_beetle_pinmux_defaul
 
 	/* Set GPIO Alternate Functions */
 
-	gpio_0 = (1<<0); /* Shield 0 UART 0 RXD */
-	gpio_0 |= (1<<1); /* Shield 0 UART 0 TXD */
-	gpio_0 |= (1<<14); /* Shield 0 I2C SDA SBCON2 */
-	gpio_0 |= (1<<15); /* Shield 0 I2C SCL SBCON2 */
-	gpio_0 |= (1<<10); /* Shield 0 SPI_3 nCS */
-	gpio_0 |= (1<<11); /* Shield 0 SPI_3 MOSI */
-	gpio_0 |= (1<<12); /* Shield 0 SPI_3 MISO */
-	gpio_0 |= (1<<13); /* Shield 0 SPI_3 SCK */
+	gpio_0 = BIT(0); /* Shield 0 UART 0 RXD */
+	gpio_0 |= BIT(1); /* Shield 0 UART 0 TXD */
+	gpio_0 |= BIT(14); /* Shield 0 I2C SDA SBCON2 */
+	gpio_0 |= BIT(15); /* Shield 0 I2C SCL SBCON2 */
+	gpio_0 |= BIT(10); /* Shield 0 SPI_3 nCS */
+	gpio_0 |= BIT(11); /* Shield 0 SPI_3 MOSI */
+	gpio_0 |= BIT(12); /* Shield 0 SPI_3 MISO */
+	gpio_0 |= BIT(13); /* Shield 0 SPI_3 SCK */
 
 	CMSDK_AHB_GPIO0_DEV->altfuncset = gpio_0;
 
-	gpio_1 = (1<<0); /* UART 1 RXD */
-	gpio_1 |= (1<<1); /* UART 1 TXD */
-	gpio_1 |= (1<<6); /* Shield 1 I2C SDA */
-	gpio_1 |= (1<<7); /* Shield 1 I2C SCL */
-	gpio_1 |= (1<<2); /* ADC SPI_1 nCS */
-	gpio_1 |= (1<<3); /* ADC SPI_1 MOSI */
-	gpio_1 |= (1<<4); /* ADC SPI_1 MISO */
-	gpio_1 |= (1<<5); /* ADC SPI_1 SCK */
-
-	gpio_1 |= (1<<8); /* QSPI CS 2 */
-	gpio_1 |= (1<<9); /* QSPI CS 1 */
-	gpio_1 |= (1<<10); /* QSPI IO 0 */
-	gpio_1 |= (1<<11); /* QSPI IO 1 */
-	gpio_1 |= (1<<12); /* QSPI IO 2 */
-	gpio_1 |= (1<<13); /* QSPI IO 3 */
-	gpio_1 |= (1<<14); /* QSPI SCK */
+	gpio_1 = BIT(0); /* UART 1 RXD */
+	gpio_1 |= BIT(1); /* UART 1 TXD */
+	gpio_1 |= BIT(6); /* Shield 1 I2C SDA */
+	gpio_1 |= BIT(7); /* Shield 1 I2C SCL */
+	gpio_1 |= BIT(2); /* ADC SPI_1 nCS */
+	gpio_1 |= BIT(3); /* ADC SPI_1 MOSI */
+	gpio_1 |= BIT(4); /* ADC SPI_1 MISO */
+	gpio_1 |= BIT(5); /* ADC SPI_1 SCK */
+
+	gpio_1 |= BIT(8); /* QSPI CS 2 */
+	gpio_1 |= BIT(9); /* QSPI CS 1 */
+	gpio_1 |= BIT(10); /* QSPI IO 0 */
+	gpio_1 |= BIT(11); /* QSPI IO 1 */
+	gpio_1 |= BIT(12); /* QSPI IO 2 */
+	gpio_1 |= BIT(13); /* QSPI IO 3 */
+	gpio_1 |= BIT(14); /* QSPI SCK */
 
 	CMSDK_AHB_GPIO1_DEV->altfuncset = gpio_1;
 
 	/* Set the ARD_PWR_EN GPIO1[15] as an output */
-	CMSDK_AHB_GPIO1_DEV->outenableset |= (0x1 << 15);
+	CMSDK_AHB_GPIO1_DEV->outenableset |= BIT(15);
 	/* Set on 3v3 (for ARDUINO HDR compliancy) */
-	CMSDK_AHB_GPIO1_DEV->data |= (0x1 << 15);
+	CMSDK_AHB_GPIO1_DEV->data |= BIT(15);
 }
 
 static int arm_v2m_beetle_pinmux_init(const struct device *port)
diff -u -p a/boards/arm/mimxrt1010_evk/pinmux.c b/boards/arm/mimxrt1010_evk/pinmux.c
--- a/boards/arm/mimxrt1010_evk/pinmux.c
+++ b/boards/arm/mimxrt1010_evk/pinmux.c
@@ -23,7 +23,7 @@ static int mimxrt1010_evk_init(const str
 				IOMUXC_SW_PAD_CTL_PAD_PUS(2) |
 				IOMUXC_SW_PAD_CTL_PAD_SPEED(2) |
 				IOMUXC_SW_PAD_CTL_PAD_DSE(4));
-	IOMUXC_GPR->GPR26 &= ~(IOMUXC_GPR_GPR26_GPIO_SEL(1 << 11));
+	IOMUXC_GPR->GPR26 &= ~(IOMUXC_GPR_GPR26_GPIO_SEL(BIT(11)));
 #endif
 
 #if DT_NODE_HAS_STATUS(DT_NODELABEL(gpio2), okay)
diff -u -p a/lib/os/json.c b/lib/os/json.c
--- a/lib/os/json.c
+++ b/lib/os/json.c
@@ -493,7 +493,7 @@ static ptrdiff_t get_elem_size(const str
 		for (i = 0; i < descr->object.sub_descr_len; i++) {
 			ptrdiff_t s = get_elem_size(&descr->object.sub_descr[i]);
 
-			total += ROUND_UP(s, 1 << descr->align_shift);
+			total += ROUND_UP(s, BIT(descr->align_shift));
 		}
 
 		return total;
@@ -553,7 +553,7 @@ static int obj_parse(struct json_obj *ob
 			void *decode_field = (char *)val + descr[i].offset;
 
 			/* Field has been decoded already, skip */
-			if (decoded_fields & (1 << i)) {
+			if (decoded_fields & BIT(i)) {
 				continue;
 			}
 
@@ -574,7 +574,7 @@ static int obj_parse(struct json_obj *ob
 				return ret;
 			}
 
-			decoded_fields |= 1<<i;
+			decoded_fields |= BIT(i);
 			break;
 		}
 	}
diff -u -p a/drivers/ieee802154/ieee802154_rf2xx.c b/drivers/ieee802154/ieee802154_rf2xx.c
--- a/drivers/ieee802154/ieee802154_rf2xx.c
+++ b/drivers/ieee802154/ieee802154_rf2xx.c
@@ -49,8 +49,8 @@ LOG_MODULE_REGISTER(LOG_MODULE_NAME);
 
 #define RF2XX_ACK_FRAME_LEN               3
 #define RF2XX_ACK_FRAME_TYPE              (2 << 0)
-#define RF2XX_ACK_FRAME_PENDING_BIT       (1 << 4)
-#define RF2XX_FRAME_CTRL_ACK_REQUEST_BIT  (1 << 5)
+#define RF2XX_ACK_FRAME_PENDING_BIT       BIT(4)
+#define RF2XX_FRAME_CTRL_ACK_REQUEST_BIT  BIT(5)
 
 static uint8_t rf2xx_ack_psdu[RF2XX_ACK_FRAME_LEN] = { 0 };
 static struct net_buf rf2xx_ack_frame = {
@@ -337,12 +337,12 @@ static void rf2xx_thread_main(void *arg)
 		 *    PA is turned off immediately. 9.7.5
 		 *  IRQ_0 (PLL_LOCK) Indicates PLL lock.
 		 */
-		if (isr_status & (1 << RF2XX_RX_START)) {
+		if (isr_status & BIT(RF2XX_RX_START)) {
 			if (ctx->trx_model != RF2XX_TRX_MODEL_231) {
 				rf2xx_iface_sram_read(ctx->dev, 0,
 						      &ctx->rx_phr, 1);
 			}
-		} else if (isr_status & (1 << RF2XX_TRX_END)) {
+		} else if (isr_status & BIT(RF2XX_TRX_END)) {
 			rf2xx_process_trx_end(ctx->dev);
 		}
 	}
@@ -671,20 +671,20 @@ static int power_on_and_setup(const stru
 	}
 
 	/* Configure PHY behaviour */
-	config = (1 << RF2XX_TX_AUTO_CRC_ON) |
+	config = BIT(RF2XX_TX_AUTO_CRC_ON) |
 		 (3 << RF2XX_SPI_CMD_MODE) |
-		 (1 << RF2XX_IRQ_MASK_MODE);
+		 BIT(RF2XX_IRQ_MASK_MODE);
 	rf2xx_iface_reg_write(dev, RF2XX_TRX_CTRL_1_REG, config);
 
-	config = (1 << RF2XX_RX_SAFE_MODE);
+	config = BIT(RF2XX_RX_SAFE_MODE);
 	if (ctx->trx_model != RF2XX_TRX_MODEL_232) {
-		config |= (1 << RF2XX_OQPSK_SCRAM_EN);
+		config |= BIT(RF2XX_OQPSK_SCRAM_EN);
 	}
 	rf2xx_iface_reg_write(dev, RF2XX_TRX_CTRL_2_REG, config);
 
 	/* Configure INT behaviour */
-	config = (1 << RF2XX_RX_START) |
-		 (1 << RF2XX_TRX_END);
+	config = BIT(RF2XX_RX_START) |
+		 BIT(RF2XX_TRX_END);
 	rf2xx_iface_reg_write(dev, RF2XX_IRQ_MASK_REG, config);
 
 	gpio_init_callback(&ctx->irq_cb, trx_isr_handler, BIT(conf->irq.pin));
diff -u -p a/drivers/can/can_stm32.c b/drivers/can/can_stm32.c
--- a/drivers/can/can_stm32.c
+++ b/drivers/can/can_stm32.c
@@ -773,10 +773,10 @@ static inline void can_stm32_set_mode_sc
 	uint32_t mode_reg_bit  = (filter_type & 0x01) << bank_nr;
 	uint32_t scale_reg_bit = (filter_type >>   1) << bank_nr;
 
-	*mode_reg &= ~(1 << bank_nr);
+	*mode_reg &= ~BIT(bank_nr);
 	*mode_reg |= mode_reg_bit;
 
-	*scale_reg &= ~(1 << bank_nr);
+	*scale_reg &= ~BIT(bank_nr);
 	*scale_reg |= scale_reg_bit;
 }
 
@@ -1005,7 +1005,7 @@ void can_stm32_detach(const struct devic
 		    filter_index,
 		    type);
 
-	reset_mask = ((1 << (reg_demand[type])) - 1) << filter_nr;
+	reset_mask = (BIT((reg_demand[type])) - 1) << filter_nr;
 	data->filter_usage |= reset_mask;
 	can->FMR |= CAN_FMR_FINIT;
 	can->FA1R &= ~bank_bit;
diff -u -p a/drivers/pwm/pwm_led_esp32.c b/drivers/pwm/pwm_led_esp32.c
--- a/drivers/pwm/pwm_led_esp32.c
+++ b/drivers/pwm/pwm_led_esp32.c
@@ -256,7 +256,7 @@ static int pwm_led_esp32_timer_set(int s
 	uint32_t timer_addr;
 	uint64_t div_num;
 	int tick_sel = PWM_LED_ESP32_APB_CLK_FREQ;
-	uint32_t precision = (0x1 << bit_num);
+	uint32_t precision = BIT(bit_num);
 
 	assert(frequency > 0);
 
diff -u -p a/drivers/interrupt_controller/intc_swerv_pic.c b/drivers/interrupt_controller/intc_swerv_pic.c
--- a/drivers/interrupt_controller/intc_swerv_pic.c
+++ b/drivers/interrupt_controller/intc_swerv_pic.c
@@ -202,7 +202,7 @@ void arch_irq_enable(unsigned int irq)
 	 */
 	__asm__ volatile ("csrrs %0, mie, %1\n"
 			  : "=r" (mie)
-			  : "r" (1 << irq));
+			  : "r" (BIT(irq)));
 }
 
 void arch_irq_disable(unsigned int irq)
@@ -220,7 +220,7 @@ void arch_irq_disable(unsigned int irq)
 	 */
 	__asm__ volatile ("csrrc %0, mie, %1\n"
 			  : "=r" (mie)
-			  : "r" (1 << irq));
+			  : "r" (BIT(irq)));
 };
 
 int arch_irq_is_enabled(unsigned int irq)
@@ -232,7 +232,7 @@ int arch_irq_is_enabled(unsigned int irq
 
 	__asm__ volatile ("csrr %0, mie" : "=r" (mie));
 
-	return !!(mie & (1 << irq));
+	return !!(mie & BIT(irq));
 }
 
 SYS_INIT(swerv_pic_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);
diff -u -p a/drivers/interrupt_controller/intc_cavs.c b/drivers/interrupt_controller/intc_cavs.c
--- a/drivers/interrupt_controller/intc_cavs.c
+++ b/drivers/interrupt_controller/intc_cavs.c
@@ -41,7 +41,7 @@ static ALWAYS_INLINE void cavs_ictl_disp
 	/* Dispatch lower level ISRs depending upon the bit set */
 	while (intr_status) {
 		intr_bitpos = find_lsb_set(intr_status) - 1;
-		intr_status &= ~(1 << intr_bitpos);
+		intr_status &= ~BIT(intr_bitpos);
 		intr_offset = isr_base_offset + intr_bitpos;
 		_sw_isr_table[intr_offset].isr(
 			_sw_isr_table[intr_offset].arg);
@@ -69,7 +69,7 @@ static inline void cavs_ictl_irq_enable(
 	volatile struct cavs_registers * const regs =
 			(struct cavs_registers *)context->base_addr;
 
-	regs->enable_il = (1 << irq);
+	regs->enable_il = BIT(irq);
 }
 
 static inline void cavs_ictl_irq_disable(const struct device *dev,
@@ -80,7 +80,7 @@ static inline void cavs_ictl_irq_disable
 	volatile struct cavs_registers * const regs =
 			(struct cavs_registers *)context->base_addr;
 
-	regs->disable_il = (1 << irq);
+	regs->disable_il = BIT(irq);
 }
 
 static inline unsigned int cavs_ictl_irq_get_state(const struct device *dev)
diff -u -p a/drivers/pinmux/pinmux_sifive.c b/drivers/pinmux/pinmux_sifive.c
--- a/drivers/pinmux/pinmux_sifive.c
+++ b/drivers/pinmux/pinmux_sifive.c
@@ -44,7 +44,7 @@ static int pinmux_sifive_set(const struc
 		pinmux->iof_sel &= ~(SIFIVE_PINMUX_IOF1 << pin);
 
 	/* Enable IO function for this pin */
-	pinmux->iof_en |= (1 << pin);
+	pinmux->iof_en |= BIT(pin);
 
 	return 0;
 }
diff -u -p a/drivers/i2c/i2c_bitbang.c b/drivers/i2c/i2c_bitbang.c
--- a/drivers/i2c/i2c_bitbang.c
+++ b/drivers/i2c/i2c_bitbang.c
@@ -158,7 +158,7 @@ static bool i2c_read_bit(struct i2c_bitb
 
 static bool i2c_write_byte(struct i2c_bitbang *context, uint8_t byte)
 {
-	uint8_t mask = 1 << 7;
+	uint8_t mask = BIT(7);
 
 	do {
 		i2c_write_bit(context, byte & mask);
@@ -175,7 +175,7 @@ static uint8_t i2c_read_byte(struct i2c_
 	do {
 		byte <<= 1;
 		byte |= i2c_read_bit(context);
-	} while (!(byte & (1 << 8)));
+	} while (!(byte & BIT(8)));
 
 	return byte;
 }
diff -u -p a/drivers/ethernet/eth_smsc911x.c b/drivers/ethernet/eth_smsc911x.c
--- a/drivers/ethernet/eth_smsc911x.c
+++ b/drivers/ethernet/eth_smsc911x.c
@@ -277,7 +277,7 @@ int smsc_reset_phy(void)
 		return -1;
 	}
 
-	val |= 1 << 15;
+	val |= BIT(15);
 
 	if (smsc_phy_regwrite(SMSC9220_PHY_BCONTROL, val)) {
 		return -1;
@@ -306,13 +306,13 @@ void smsc_establish_link(void)
 	uint32_t hw_cfg = 0U;
 
 	smsc_phy_regread(SMSC9220_PHY_BCONTROL, &bcr);
-	bcr |= (1 << 12) | (1 << 9);
+	bcr |= BIT(12) | BIT(9);
 	smsc_phy_regwrite(SMSC9220_PHY_BCONTROL, bcr);
 	smsc_phy_regread(SMSC9220_PHY_BCONTROL, &bcr);
 
 	hw_cfg = SMSC9220->HW_CFG;
 	hw_cfg &= 0xF0000;
-	hw_cfg |= (1 << 20);
+	hw_cfg |= BIT(20);
 	SMSC9220->HW_CFG = hw_cfg;
 }
 
@@ -327,8 +327,8 @@ void smsc_enable_mac_xmit(void)
 
 	smsc_mac_regread(SMSC9220_MAC_CR, &mac_cr);
 
-	mac_cr |= (1 << 3);     /* xmit enable */
-	mac_cr |= (1 << 28);    /* Heartbeat disable */
+	mac_cr |= BIT(3);     /* xmit enable */
+	mac_cr |= BIT(28);    /* Heartbeat disable */
 
 	smsc_mac_regwrite(SMSC9220_MAC_CR, mac_cr);
 }
@@ -338,7 +338,7 @@ void smsc_enable_mac_recv(void)
 	uint32_t mac_cr = 0U;
 
 	smsc_mac_regread(SMSC9220_MAC_CR, &mac_cr);
-	mac_cr |= (1 << 2);     /* Recv enable */
+	mac_cr |= BIT(2);     /* Recv enable */
 	smsc_mac_regwrite(SMSC9220_MAC_CR, mac_cr);
 }
 
@@ -383,7 +383,7 @@ int smsc_init(void)
 		return 1;
 	}
 
-	if (phyreset & (1 << 15)) {
+	if (phyreset & BIT(15)) {
 		return 1;
 	}
 
@@ -479,7 +479,7 @@ static int eth_tx(const struct device *d
 	uint32_t tx_stat;
 	int res;
 
-	txcmd_a = (1/*is_first_segment*/ << 13) | (1/*is_last_segment*/ << 12)
+	txcmd_a = BIT(13) | BIT(12)
 		  | total_len;
 	/* Use len as a tag */
 	txcmd_b = total_len << 16 | total_len;
diff -u -p a/drivers/usb/device/usb_dc_kinetis.c b/drivers/usb/device/usb_dc_kinetis.c
--- a/drivers/usb/device/usb_dc_kinetis.c
+++ b/drivers/usb/device/usb_dc_kinetis.c
@@ -22,12 +22,12 @@ LOG_MODULE_REGISTER(usb_dc_kinetis);
 
 #define NUM_OF_EP_MAX		DT_INST_PROP(0, num_bidir_endpoints)
 
-#define BD_OWN_MASK		(1 << 5)
-#define BD_DATA01_MASK		(1 << 4)
-#define BD_KEEP_MASK		(1 << 3)
-#define BD_NINC_MASK		(1 << 2)
-#define BD_DTS_MASK		(1 << 1)
-#define BD_STALL_MASK		(1 << 0)
+#define BD_OWN_MASK		BIT(5)
+#define BD_DATA01_MASK		BIT(4)
+#define BD_KEEP_MASK		BIT(3)
+#define BD_NINC_MASK		BIT(2)
+#define BD_DTS_MASK		BIT(1)
+#define BD_STALL_MASK		BIT(0)
 
 #define KINETIS_SETUP_TOKEN	0x0d
 #define KINETIS_IN_TOKEN	0x09
diff -u -p a/drivers/spi/spi_dw.c b/drivers/spi/spi_dw.c
--- a/drivers/spi/spi_dw.c
+++ b/drivers/spi/spi_dw.c
@@ -256,7 +256,7 @@ static int spi_dw_configure(const struct
 		/* Baud rate and Slave select, for master only */
 		write_baudr(SPI_DW_CLK_DIVIDER(info->clock_frequency,
 					       config->frequency), info->regs);
-		write_ser(1 << config->slave, info->regs);
+		write_ser(BIT(config->slave), info->regs);
 	}
 
 	spi_context_cs_configure(&spi->ctx);
diff -u -p a/drivers/adc/adc_mchp_xec.c b/drivers/adc/adc_mchp_xec.c
--- a/drivers/adc/adc_mchp_xec.c
+++ b/drivers/adc/adc_mchp_xec.c
@@ -171,7 +171,7 @@ static int adc_xec_start_read(const stru
 	/* Setup ADC resolution */
 	reg = adc_regs->sar_control_reg;
 	reg &= ~(MCHP_ADC_SAR_CTRL_RES_MASK |
-		 (1 << MCHP_ADC_SAR_CTRL_SHIFTD_POS));
+		 BIT(MCHP_ADC_SAR_CTRL_SHIFTD_POS));
 
 	if (sequence->resolution == 12) {
 		reg |= MCHP_ADC_SAR_CTRL_RES_12_BITS;
diff -u -p a/drivers/sensor/sx9500/sx9500.c b/drivers/sensor/sx9500/sx9500.c
--- a/drivers/sensor/sx9500/sx9500.c
+++ b/drivers/sensor/sx9500/sx9500.c
@@ -65,7 +65,7 @@ static int sx9500_channel_get(const stru
 	__ASSERT_NO_MSG(chan == SENSOR_CHAN_PROX);
 
 	val->val1 = !!(data->prox_stat &
-		       (1 << (4 + CONFIG_SX9500_PROX_CHANNEL)));
+		       BIT((4 + CONFIG_SX9500_PROX_CHANNEL)));
 	val->val2 = 0;
 
 	return 0;
@@ -106,7 +106,7 @@ static int sx9500_init_chip(const struct
 
 	return i2c_reg_write_byte(data->i2c_master, data->i2c_slave_addr,
 				  SX9500_REG_PROX_CTRL0,
-				  1 << CONFIG_SX9500_PROX_CHANNEL);
+				  BIT(CONFIG_SX9500_PROX_CHANNEL));
 }
 
 int sx9500_init(const struct device *dev)
diff -u -p a/drivers/sensor/lsm6dsl/lsm6dsl_shub.c b/drivers/sensor/lsm6dsl/lsm6dsl_shub.c
--- a/drivers/sensor/lsm6dsl/lsm6dsl_shub.c
+++ b/drivers/sensor/lsm6dsl/lsm6dsl_shub.c
@@ -204,7 +204,7 @@ static void lsm6dsl_shub_enable(struct l
 	/* Enable Digital Func */
 	data->hw_tf->update_reg(data, LSM6DSL_REG_CTRL10_C,
 				LSM6DSL_MASK_CTRL10_C_FUNC_EN,
-				1 << LSM6DSL_SHIFT_CTRL10_C_FUNC_EN);
+				BIT(LSM6DSL_SHIFT_CTRL10_C_FUNC_EN));
 
 	/* Enable Accel @26hz */
 	if (!data->accel_freq) {
@@ -217,7 +217,7 @@ static void lsm6dsl_shub_enable(struct l
 	/* Enable Sensor Hub */
 	data->hw_tf->update_reg(data, LSM6DSL_REG_MASTER_CONFIG,
 				LSM6DSL_MASK_MASTER_CONFIG_MASTER_ON,
-				1 << LSM6DSL_SHIFT_MASTER_CONFIG_MASTER_ON);
+				BIT(LSM6DSL_SHIFT_MASTER_CONFIG_MASTER_ON));
 }
 
 static void lsm6dsl_shub_disable(struct lsm6dsl_data *data)
diff -u -p a/drivers/sensor/lsm9ds0_mfd/lsm9ds0_mfd.c b/drivers/sensor/lsm9ds0_mfd/lsm9ds0_mfd.c
--- a/drivers/sensor/lsm9ds0_mfd/lsm9ds0_mfd.c
+++ b/drivers/sensor/lsm9ds0_mfd/lsm9ds0_mfd.c
@@ -31,7 +31,7 @@ static inline int lsm9ds0_mfd_reboot_mem
 	if (i2c_reg_update_byte(data->i2c_master, config->i2c_slave_addr,
 				LSM9DS0_MFD_REG_CTRL_REG0_XM,
 				LSM9DS0_MFD_MASK_CTRL_REG0_XM_BOOT,
-				1 << LSM9DS0_MFD_SHIFT_CTRL_REG0_XM_BOOT)
+				BIT(LSM9DS0_MFD_SHIFT_CTRL_REG0_XM_BOOT))
 				< 0) {
 		return -EIO;
 	}
@@ -698,7 +698,7 @@ static int lsm9ds0_mfd_init_chip(const s
 				LSM9DS0_MFD_REG_CTRL_REG1_XM,
 				LSM9DS0_MFD_MASK_CTRL_REG1_XM_BDU |
 				LSM9DS0_MFD_MASK_CTRL_REG1_XM_AODR,
-				(1 << LSM9DS0_MFD_SHIFT_CTRL_REG1_XM_BDU) |
+				BIT(LSM9DS0_MFD_SHIFT_CTRL_REG1_XM_BDU) |
 				(LSM9DS0_MFD_ACCEL_DEFAULT_AODR <<
 				LSM9DS0_MFD_SHIFT_CTRL_REG1_XM_AODR))) {
 		LOG_DBG("failed to set AODR and BDU");
@@ -729,7 +729,7 @@ static int lsm9ds0_mfd_init_chip(const s
 	if (i2c_reg_update_byte(data->i2c_master, config->i2c_slave_addr,
 				LSM9DS0_MFD_REG_CTRL_REG1_XM,
 				LSM9DS0_MFD_MASK_CTRL_REG1_XM_BDU,
-				1 << LSM9DS0_MFD_SHIFT_CTRL_REG1_XM_BDU)
+				BIT(LSM9DS0_MFD_SHIFT_CTRL_REG1_XM_BDU))
 				< 0) {
 		LOG_DBG("failed to set BDU\n");
 		return -EIO;
@@ -761,7 +761,7 @@ static int lsm9ds0_mfd_init_chip(const s
 	if (i2c_reg_update_byte(data->i2c_master, config->i2c_slave_addr,
 				LSM9DS0_MFD_REG_CTRL_REG5_XM,
 				LSM9DS0_MFD_MASK_CTRL_REG5_XM_TEMP_EN,
-				1 << LSM9DS0_MFD_SHIFT_CTRL_REG5_XM_TEMP_EN)
+				BIT(LSM9DS0_MFD_SHIFT_CTRL_REG5_XM_TEMP_EN))
 				< 0) {
 		LOG_DBG("failed to power on temperature sensor");
 		return -EIO;
diff -u -p a/drivers/sensor/iis2mdc/iis2mdc_spi.c b/drivers/sensor/iis2mdc/iis2mdc_spi.c
--- a/drivers/sensor/iis2mdc/iis2mdc_spi.c
+++ b/drivers/sensor/iis2mdc/iis2mdc_spi.c
@@ -16,7 +16,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define IIS2MDC_SPI_READ		(1 << 7)
+#define IIS2MDC_SPI_READ		BIT(7)
 
 #define LOG_LEVEL CONFIG_SENSOR_LOG_LEVEL
 LOG_MODULE_DECLARE(IIS2MDC);
diff -u -p a/drivers/sensor/lps22hb/lps22hb.c b/drivers/sensor/lps22hb/lps22hb.c
--- a/drivers/sensor/lps22hb/lps22hb.c
+++ b/drivers/sensor/lps22hb/lps22hb.c
@@ -120,7 +120,7 @@ static int lps22hb_init_chip(const struc
 	if (i2c_reg_update_byte(data->i2c_master, config->i2c_slave_addr,
 				LPS22HB_REG_CTRL_REG1,
 				LPS22HB_MASK_CTRL_REG1_BDU,
-				(1 << LPS22HB_SHIFT_CTRL_REG1_BDU)) < 0) {
+				BIT(LPS22HB_SHIFT_CTRL_REG1_BDU)) < 0) {
 		LOG_DBG("Failed to set BDU");
 		goto err_poweroff;
 	}
diff -u -p a/drivers/sensor/lsm6dso/lsm6dso_spi.c b/drivers/sensor/lsm6dso/lsm6dso_spi.c
--- a/drivers/sensor/lsm6dso/lsm6dso_spi.c
+++ b/drivers/sensor/lsm6dso/lsm6dso_spi.c
@@ -16,7 +16,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define LSM6DSO_SPI_READ		(1 << 7)
+#define LSM6DSO_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(LSM6DSO, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/bmi160/bmi160.c b/drivers/sensor/bmi160/bmi160.c
--- a/drivers/sensor/bmi160/bmi160.c
+++ b/drivers/sensor/bmi160/bmi160.c
@@ -633,10 +633,10 @@ static int bmi160_attr_set(const struct 
 
 #if defined(CONFIG_BMI160_GYRO_PMU_SUSPEND)
 #	define BMI160_SAMPLE_BURST_READ_ADDR	BMI160_REG_DATA_ACC_X
-#	define BMI160_DATA_READY_BIT_MASK	(1 << 7)
+#	define BMI160_DATA_READY_BIT_MASK	BIT(7)
 #else
 #	define BMI160_SAMPLE_BURST_READ_ADDR	BMI160_REG_DATA_GYR_X
-#	define BMI160_DATA_READY_BIT_MASK	(1 << 6)
+#	define BMI160_DATA_READY_BIT_MASK	BIT(6)
 #endif
 static int bmi160_sample_fetch(const struct device *dev,
 			       enum sensor_channel chan)
@@ -649,13 +649,13 @@ static int bmi160_sample_fetch(const str
 	bmi160->sample.raw[0] = 0U;
 
 	while ((bmi160->sample.raw[0] & BMI160_DATA_READY_BIT_MASK) == 0U) {
-		if (bmi160_transceive(dev, BMI160_REG_STATUS | (1 << 7), false,
+		if (bmi160_transceive(dev, BMI160_REG_STATUS | BIT(7), false,
 				      bmi160->sample.raw, 1) < 0) {
 			return -EIO;
 		}
 	}
 
-	if (bmi160_transceive(dev, BMI160_SAMPLE_BURST_READ_ADDR | (1 << 7),
+	if (bmi160_transceive(dev, BMI160_SAMPLE_BURST_READ_ADDR | BIT(7),
 			      false, bmi160->sample.raw, BMI160_BUF_SIZE) < 0) {
 		return -EIO;
 	}
diff -u -p a/drivers/sensor/lis2ds12/lis2ds12_spi.c b/drivers/sensor/lis2ds12/lis2ds12_spi.c
--- a/drivers/sensor/lis2ds12/lis2ds12_spi.c
+++ b/drivers/sensor/lis2ds12/lis2ds12_spi.c
@@ -18,7 +18,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define LIS2DS12_SPI_READ		(1 << 7)
+#define LIS2DS12_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(LIS2DS12, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/ipm/ipm_stm32_ipcc.c b/drivers/ipm/ipm_stm32_ipcc.c
--- a/drivers/ipm/ipm_stm32_ipcc.c
+++ b/drivers/ipm/ipm_stm32_ipcc.c
@@ -38,19 +38,19 @@ LOG_MODULE_REGISTER(ipm_stm32_ipcc, CONF
 #define IPCC_DisableIT_RXO(hipcc)  LL_C1_IPCC_DisableIT_RXO(hipcc)
 
 #define IPCC_EnableReceiveChannel(hipcc, ch)	\
-			LL_C1_IPCC_EnableReceiveChannel(hipcc, 1 << ch)
+			LL_C1_IPCC_EnableReceiveChannel(hipcc, BIT(ch))
 #define IPCC_EnableTransmitChannel(hipcc, ch)	\
-			LL_C1_IPCC_EnableTransmitChannel(hipcc, 1 << ch)
+			LL_C1_IPCC_EnableTransmitChannel(hipcc, BIT(ch))
 #define IPCC_DisableReceiveChannel(hipcc, ch)	\
-			LL_C2_IPCC_DisableReceiveChannel(hipcc, 1 << ch)
+			LL_C2_IPCC_DisableReceiveChannel(hipcc, BIT(ch))
 #define IPCC_DisableTransmitChannel(hipcc, ch)	\
-			LL_C1_IPCC_DisableTransmitChannel(hipcc, 1 << ch)
+			LL_C1_IPCC_DisableTransmitChannel(hipcc, BIT(ch))
 
-#define IPCC_ClearFlag_CHx(hipcc, ch)	LL_C1_IPCC_ClearFlag_CHx(hipcc, 1 << ch)
-#define IPCC_SetFlag_CHx(hipcc, ch)	LL_C1_IPCC_SetFlag_CHx(hipcc, 1 << ch)
+#define IPCC_ClearFlag_CHx(hipcc, ch)	LL_C1_IPCC_ClearFlag_CHx(hipcc, BIT(ch))
+#define IPCC_SetFlag_CHx(hipcc, ch)	LL_C1_IPCC_SetFlag_CHx(hipcc, BIT(ch))
 
 #define IPCC_IsActiveFlag_CHx(hipcc, ch)	\
-			LL_C1_IPCC_IsActiveFlag_CHx(hipcc, 1 << ch)
+			LL_C1_IPCC_IsActiveFlag_CHx(hipcc, BIT(ch))
 
 #define IPCC_ReadReg(hipcc, reg) READ_REG(hipcc->C1##reg)
 
@@ -66,19 +66,19 @@ LOG_MODULE_REGISTER(ipm_stm32_ipcc, CONF
 #define IPCC_DisableIT_RXO(hipcc)  LL_C2_IPCC_DisableIT_RXO(hipcc)
 
 #define IPCC_EnableReceiveChannel(hipcc, ch)	\
-			LL_C2_IPCC_EnableReceiveChannel(hipcc, 1 << ch)
+			LL_C2_IPCC_EnableReceiveChannel(hipcc, BIT(ch))
 #define IPCC_EnableTransmitChannel(hipcc, ch)	\
-			LL_C2_IPCC_EnableTransmitChannel(hipcc, 1 << ch)
+			LL_C2_IPCC_EnableTransmitChannel(hipcc, BIT(ch))
 #define IPCC_DisableReceiveChannel(hipcc, ch)	\
-			LL_C2_IPCC_DisableReceiveChannel(hipcc, 1 << ch)
+			LL_C2_IPCC_DisableReceiveChannel(hipcc, BIT(ch))
 #define IPCC_DisableTransmitChannel(hipcc, ch)	\
-			LL_C2_IPCC_DisableTransmitChannel(hipcc, 1 << ch)
+			LL_C2_IPCC_DisableTransmitChannel(hipcc, BIT(ch))
 
-#define IPCC_ClearFlag_CHx(hipcc, ch)	LL_C2_IPCC_ClearFlag_CHx(hipcc, 1 << ch)
-#define IPCC_SetFlag_CHx(hipcc, ch)	LL_C2_IPCC_SetFlag_CHx(hipcc, 1 << ch)
+#define IPCC_ClearFlag_CHx(hipcc, ch)	LL_C2_IPCC_ClearFlag_CHx(hipcc, BIT(ch))
+#define IPCC_SetFlag_CHx(hipcc, ch)	LL_C2_IPCC_SetFlag_CHx(hipcc, BIT(ch))
 
 #define IPCC_IsActiveFlag_CHx(hipcc, ch)	\
-			LL_C2_IPCC_IsActiveFlag_CHx(hipcc, 1 << ch)
+			LL_C2_IPCC_IsActiveFlag_CHx(hipcc, BIT(ch))
 
 #define IPCC_ReadReg(hipcc, reg) READ_REG(hipcc->C2##reg)
 
@@ -112,7 +112,7 @@ static void stm32_ipcc_mailbox_rx_isr(co
 	mask &= IPCC_ReadOtherInstReg_SR(cfg->ipcc) & IPCC_ALL_SR_CH_MASK;
 
 	for (i = 0; i < data->num_ch; i++) {
-		if (!((1 << i) & mask)) {
+		if (!(BIT(i) & mask)) {
 			continue;
 		}
 		LOG_DBG("%s channel = %x\r\n", __func__, i);
@@ -141,7 +141,7 @@ static void stm32_ipcc_mailbox_tx_isr(co
 	mask &= IPCC_ReadReg_SR(cfg->ipcc) & IPCC_ALL_SR_CH_MASK;
 
 	for (i = 0; i <  data->num_ch; i++) {
-		if (!((1 << i) & mask)) {
+		if (!(BIT(i) & mask)) {
 			continue;
 		}
 		LOG_DBG("%s channel = %x\r\n", __func__, i);
diff -u -p a/drivers/display/grove_lcd_rgb.c b/drivers/display/grove_lcd_rgb.c
--- a/drivers/display/grove_lcd_rgb.c
+++ b/drivers/display/grove_lcd_rgb.c
@@ -51,18 +51,18 @@ struct glcd_driver {
 /* GLCD_CMD_CURSOR_RETURN has no options */
 
 /* Defines for the GLCD_CMD_CURSOR_SHIFT */
-#define GLCD_CS_DISPLAY_SHIFT		(1 << 3)
-#define GLCD_CS_RIGHT_SHIFT		(1 << 2)
+#define GLCD_CS_DISPLAY_SHIFT		BIT(3)
+#define GLCD_CS_RIGHT_SHIFT		BIT(2)
 
 /* LCD Display Commands */
-#define GLCD_CMD_SCREEN_CLEAR		(1 << 0)
-#define GLCD_CMD_CURSOR_RETURN		(1 << 1)
-#define GLCD_CMD_INPUT_SET		(1 << 2)
-#define GLCD_CMD_DISPLAY_SWITCH		(1 << 3)
-#define GLCD_CMD_CURSOR_SHIFT		(1 << 4)
-#define GLCD_CMD_FUNCTION_SET		(1 << 5)
-#define GLCD_CMD_SET_CGRAM_ADDR		(1 << 6)
-#define GLCD_CMD_SET_DDRAM_ADDR		(1 << 7)
+#define GLCD_CMD_SCREEN_CLEAR		BIT(0)
+#define GLCD_CMD_CURSOR_RETURN		BIT(1)
+#define GLCD_CMD_INPUT_SET		BIT(2)
+#define GLCD_CMD_DISPLAY_SWITCH		BIT(3)
+#define GLCD_CMD_CURSOR_SHIFT		BIT(4)
+#define GLCD_CMD_FUNCTION_SET		BIT(5)
+#define GLCD_CMD_SET_CGRAM_ADDR		BIT(6)
+#define GLCD_CMD_SET_DDRAM_ADDR		BIT(7)
 
 
 /********************************************
diff -u -p a/drivers/i2s/i2s_sam_ssc.c b/drivers/i2s/i2s_sam_ssc.c
--- a/drivers/i2s/i2s_sam_ssc.c
+++ b/drivers/i2s/i2s_sam_ssc.c
@@ -503,7 +503,7 @@ static int bit_clock_set(Ssc *const ssc,
 {
 	uint32_t clk_div = SOC_ATMEL_SAM_MCK_FREQ_HZ / bit_clk_freq / 2U;
 
-	if (clk_div == 0U || clk_div >= (1 << 12)) {
+	if (clk_div == 0U || clk_div >= BIT(12)) {
 		LOG_ERR("Invalid bit clock frequency");
 		return -EINVAL;
 	}
diff -u -p a/drivers/gpio/gpio_cc32xx.c b/drivers/gpio/gpio_cc32xx.c
--- a/drivers/gpio/gpio_cc32xx.c
+++ b/drivers/gpio/gpio_cc32xx.c
@@ -91,14 +91,14 @@ static inline int gpio_cc32xx_config(con
 	MAP_PinTypeGPIO(pinTable[gpio_config->port_num * 8 + pin],
 		PIN_MODE_0, false);
 	if (flags & GPIO_OUTPUT) {
-		MAP_GPIODirModeSet(port_base, (1 << pin), GPIO_DIR_MODE_OUT);
+		MAP_GPIODirModeSet(port_base, BIT(pin), GPIO_DIR_MODE_OUT);
 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 			gpio_cc32xx_port_set_bits_raw(port, BIT(pin));
 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 			gpio_cc32xx_port_clear_bits_raw(port, BIT(pin));
 		}
 	} else {
-		MAP_GPIODirModeSet(port_base, (1 << pin), GPIO_DIR_MODE_IN);
+		MAP_GPIODirModeSet(port_base, BIT(pin), GPIO_DIR_MODE_IN);
 	}
 
 	return 0;
@@ -181,7 +181,7 @@ static int gpio_cc32xx_pin_interrupt_con
 	 * prevent spurious interrupts observed when switching
 	 * to level-based
 	 */
-	MAP_GPIOIntDisable(port_base, (1 << pin));
+	MAP_GPIOIntDisable(port_base, BIT(pin));
 
 	if (mode != GPIO_INT_MODE_DISABLED) {
 		if (mode == GPIO_INT_MODE_EDGE) {
@@ -200,9 +200,9 @@ static int gpio_cc32xx_pin_interrupt_con
 			}
 		}
 
-		MAP_GPIOIntTypeSet(port_base, (1 << pin), int_type);
-		MAP_GPIOIntClear(port_base, (1 << pin));
-		MAP_GPIOIntEnable(port_base, (1 << pin));
+		MAP_GPIOIntTypeSet(port_base, BIT(pin), int_type);
+		MAP_GPIOIntClear(port_base, BIT(pin));
+		MAP_GPIOIntEnable(port_base, BIT(pin));
 	}
 
 	return 0;
diff -u -p a/drivers/serial/uart_sifive.c b/drivers/serial/uart_sifive.c
--- a/drivers/serial/uart_sifive.c
+++ b/drivers/serial/uart_sifive.c
@@ -14,17 +14,17 @@
 #include <arch/cpu.h>
 #include <drivers/uart.h>
 
-#define RXDATA_EMPTY   (1 << 31)   /* Receive FIFO Empty */
+#define RXDATA_EMPTY   BIT(31)   /* Receive FIFO Empty */
 #define RXDATA_MASK    0xFF        /* Receive Data Mask */
 
-#define TXDATA_FULL    (1 << 31)   /* Transmit FIFO Full */
+#define TXDATA_FULL    BIT(31)   /* Transmit FIFO Full */
 
-#define TXCTRL_TXEN    (1 << 0)    /* Activate Tx Channel */
+#define TXCTRL_TXEN    BIT(0)    /* Activate Tx Channel */
 
-#define RXCTRL_RXEN    (1 << 0)    /* Activate Rx Channel */
+#define RXCTRL_RXEN    BIT(0)    /* Activate Rx Channel */
 
-#define IE_TXWM        (1 << 0)    /* TX Interrupt Enable/Pending */
-#define IE_RXWM        (1 << 1)    /* RX Interrupt Enable/Pending */
+#define IE_TXWM        BIT(0)    /* TX Interrupt Enable/Pending */
+#define IE_RXWM        BIT(1)    /* RX Interrupt Enable/Pending */
 
 /*
  * RX/TX Threshold count to generate TX/RX Interrupts.
diff -u -p a/drivers/console/gsm_mux.c b/drivers/console/gsm_mux.c
--- a/drivers/console/gsm_mux.c
+++ b/drivers/console/gsm_mux.c
@@ -1181,23 +1181,23 @@ static void validate_state_transition(en
 				      enum gsm_mux_state new)
 {
 	static const uint8_t valid_transitions[] = {
-		[GSM_MUX_SOF] = 1 << GSM_MUX_ADDRESS,
-		[GSM_MUX_ADDRESS] = 1 << GSM_MUX_CONTROL,
-		[GSM_MUX_CONTROL] = 1 << GSM_MUX_LEN_0,
-		[GSM_MUX_LEN_0] = 1 << GSM_MUX_LEN_1 |
-				1 << GSM_MUX_DATA |
-				1 << GSM_MUX_FCS |
-				1 << GSM_MUX_SOF,
-		[GSM_MUX_LEN_1] = 1 << GSM_MUX_DATA |
-				1 << GSM_MUX_FCS |
-				1 << GSM_MUX_SOF,
-		[GSM_MUX_DATA] = 1 << GSM_MUX_FCS |
-				1 << GSM_MUX_SOF,
-		[GSM_MUX_FCS] = 1 << GSM_MUX_EOF,
-		[GSM_MUX_EOF] = 1 << GSM_MUX_SOF
+		[GSM_MUX_SOF] = BIT(GSM_MUX_ADDRESS),
+		[GSM_MUX_ADDRESS] = BIT(GSM_MUX_CONTROL),
+		[GSM_MUX_CONTROL] = BIT(GSM_MUX_LEN_0),
+		[GSM_MUX_LEN_0] = BIT(GSM_MUX_LEN_1) |
+		BIT(GSM_MUX_DATA) |
+		BIT(GSM_MUX_FCS) |
+		BIT(GSM_MUX_SOF),
+		[GSM_MUX_LEN_1] = BIT(GSM_MUX_DATA) |
+		BIT(GSM_MUX_FCS) |
+		BIT(GSM_MUX_SOF),
+		[GSM_MUX_DATA] = BIT(GSM_MUX_FCS) |
+		BIT(GSM_MUX_SOF),
+		[GSM_MUX_FCS] = BIT(GSM_MUX_EOF),
+		[GSM_MUX_EOF] = BIT(GSM_MUX_SOF)
 	};
 
-	if (!(valid_transitions[current] & 1 << new)) {
+	if (!(valid_transitions[current] & BIT(new))) {
 		LOG_DBG("Invalid state transition: %s (%d) => %s (%d)",
 			gsm_mux_state_str(current), current,
 			gsm_mux_state_str(new), new);
diff -u -p a/soc/arc/snps_arc_hsdk/soc.c b/soc/arc/snps_arc_hsdk/soc.c
--- a/soc/arc/snps_arc_hsdk/soc.c
+++ b/soc/arc/snps_arc_hsdk/soc.c
@@ -27,7 +27,7 @@ static int arc_hsdk_init(const struct de
 	for (i = 0; i < (CONFIG_NUM_IRQS - ARC_CONNECT_IDU_IRQ_START); i++) {
 		z_arc_connect_idu_set_mode(i, ARC_CONNECT_INTRPT_TRIGGER_LEVEL,
 			ARC_CONNECT_DISTRI_MODE_ROUND_ROBIN);
-		z_arc_connect_idu_set_dest(i, 1 << core);
+		z_arc_connect_idu_set_dest(i, BIT(core));
 		z_arc_connect_idu_set_mask(i, 0x0);
 	}
 
diff -u -p a/subsys/net/l2/ieee802154/ieee802154_radio_csma_ca.c b/subsys/net/l2/ieee802154/ieee802154_radio_csma_ca.c
--- a/subsys/net/l2/ieee802154/ieee802154_radio_csma_ca.c
+++ b/subsys/net/l2/ieee802154/ieee802154_radio_csma_ca.c
@@ -40,7 +40,7 @@ loop:
 		retries--;
 
 		if (be) {
-			uint8_t bo_n = sys_rand32_get() & ((1 << be) - 1);
+			uint8_t bo_n = sys_rand32_get() & (BIT(be) - 1);
 
 			k_busy_wait(bo_n * 20U);
 		}
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_util.c b/subsys/net/lib/lwm2m/lwm2m_util.c
--- a/subsys/net/lib/lwm2m/lwm2m_util.c
+++ b/subsys/net/lib/lwm2m/lwm2m_util.c
@@ -35,7 +35,7 @@ int lwm2m_f32_to_b32(float32_value_t *f3
 		f >>= 1;
 
 		if (v & 1) {
-			f |= (1 << 23);
+			f |= BIT(23);
 		}
 
 		v >>= 1;
@@ -55,7 +55,7 @@ int lwm2m_f32_to_b32(float32_value_t *f3
 			continue;
 		} else if (v >= LWM2M_FLOAT32_DEC_MAX) {
 			v -= LWM2M_FLOAT32_DEC_MAX;
-			f |= 1 << (22 - i);
+			f |= BIT((22 - i));
 		}
 
 		if (v == 0) {
@@ -224,7 +224,7 @@ int lwm2m_b32_to_f32(uint8_t *b32, size_
 
 	for (i = 22 - e; i >= 0; i--) {
 		k /= 2;
-		if (f & (1 << i)) {
+		if (f & BIT(i)) {
 			f32->val2 += k;
 
 		}
diff -u -p a/subsys/net/lib/http/http_parser.c b/subsys/net/lib/http/http_parser.c
--- a/subsys/net/lib/http/http_parser.c
+++ b/subsys/net/lib/http/http_parser.c
@@ -45,7 +45,7 @@
 #ifndef BIT_AT
 # define BIT_AT(a, i)                                                \
 	(!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \
-	 (1 << ((unsigned int) (i) & 7))))
+	 BIT(((unsigned int)(i) & 7))))
 #endif
 
 #ifndef ELEM_AT
@@ -1173,22 +1173,22 @@ reexecute:
 				uint64_t sw_option = parser->method << 16 |
 						     parser->index << 8 | ch;
 				switch (sw_option) {
-				case (HTTP_POST << 16 | 1 << 8 | 'U'):
+				case (HTTP_POST << 16 | BIT(8) | 'U'):
 					parser->method = HTTP_PUT;
 					break;
-				case (HTTP_POST << 16 | 1 << 8 | 'A'):
+				case (HTTP_POST << 16 | BIT(8) | 'A'):
 					parser->method = HTTP_PATCH;
 					break;
-				case (HTTP_CONNECT << 16 | 1 << 8 | 'H'):
+				case (HTTP_CONNECT << 16 | BIT(8) | 'H'):
 					parser->method = HTTP_CHECKOUT;
 					break;
 				case (HTTP_CONNECT << 16 | 2 << 8 | 'P'):
 					parser->method = HTTP_COPY;
 					break;
-				case (HTTP_MKCOL << 16 | 1 << 8 | 'O'):
+				case (HTTP_MKCOL << 16 | BIT(8) | 'O'):
 					parser->method = HTTP_MOVE;
 					break;
-				case (HTTP_MKCOL << 16 | 1 << 8 | 'E'):
+				case (HTTP_MKCOL << 16 | BIT(8) | 'E'):
 					parser->method = HTTP_MERGE;
 					break;
 				case (HTTP_MKCOL << 16 | 2 << 8 | 'A'):
@@ -1197,13 +1197,13 @@ reexecute:
 				case (HTTP_MKCOL << 16 | 3 << 8 | 'A'):
 					parser->method = HTTP_MKCALENDAR;
 					break;
-				case (HTTP_SUBSCRIBE << 16 | 1 << 8 | 'E'):
+				case (HTTP_SUBSCRIBE << 16 | BIT(8) | 'E'):
 					parser->method = HTTP_SEARCH;
 					break;
 				case (HTTP_REPORT << 16 | 2 << 8 | 'B'):
 					parser->method = HTTP_REBIND;
 					break;
-				case (HTTP_POST << 16 | 1 << 8 | 'R'):
+				case (HTTP_POST << 16 | BIT(8) | 'R'):
 					parser->method = HTTP_PROPFIND;
 					break;
 				case (HTTP_PROPFIND << 16 | 4 << 8 | 'P'):
@@ -1212,7 +1212,7 @@ reexecute:
 				case (HTTP_PUT << 16 | 2 << 8 | 'R'):
 					parser->method = HTTP_PURGE;
 					break;
-				case (HTTP_LOCK << 16 | 1 << 8 | 'I'):
+				case (HTTP_LOCK << 16 | BIT(8) | 'I'):
 					parser->method = HTTP_LINK;
 					break;
 				case (HTTP_UNLOCK << 16 | 2 << 8 | 'S'):
diff -u -p a/subsys/bluetooth/controller/hci/hci.c b/subsys/bluetooth/controller/hci/hci.c
--- a/subsys/bluetooth/controller/hci/hci.c
+++ b/subsys/bluetooth/controller/hci/hci.c
@@ -706,7 +706,7 @@ static void read_local_features(struct n
 	rp->status = 0x00;
 	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 	/* BR/EDR not supported and LE supported */
-	rp->features[4] = (1 << 5) | (1 << 6);
+	rp->features[4] = BIT(5) | BIT(6);
 }
 
 static void read_bd_addr(struct net_buf *buf, struct net_buf **evt)
diff -u -p a/subsys/logging/log_output.c b/subsys/logging/log_output.c
--- a/subsys/logging/log_output.c
+++ b/subsys/logging/log_output.c
@@ -259,7 +259,7 @@ static int ids_print(const struct log_ou
 
 	total += print_formatted(log_output,
 				(func_on &&
-				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
+				(BIT(level) & LOG_FUNCTION_PREFIX_MASK)) ?
 				"%s." : "%s: ",
 				log_source_name_get(domain_id, source_id));
 
diff -u -p a/tests/net/lib/http_header_fields/src/main.c b/tests/net/lib/http_header_fields/src/main.c
--- a/tests/net/lib/http_header_fields/src/main.c
+++ b/tests/net/lib/http_header_fields/src/main.c
@@ -53,7 +53,7 @@ const struct url_test url_tests[] = {
 	.name = "proxy request",
 	.url = "http://hostname/",
 	.is_connect = 0,
-	.u = {	.field_set = (1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PATH),
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH),
 		.port = 0,
 		.field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
@@ -70,10 +70,10 @@ const struct url_test url_tests[] = {
 	.name = "proxy request with port",
 	.url = "http://hostname:444/",
 	.is_connect = 0,
-	.u = {	.field_set = (1 << UF_SCHEMA) | (1 << UF_HOST) |
-			     (1 << UF_PORT) | (1 << UF_PATH),
-		.port = 444,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) |
+			     BIT(UF_PORT) | BIT(UF_PATH),
+			     .port = 444,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{  7,  8 },	/* UF_HOST */
 			{ 16,  3 },	/* UF_PORT */
@@ -88,7 +88,7 @@ const struct url_test url_tests[] = {
 	.name = "CONNECT request",
 	.url = "hostname:443",
 	.is_connect = 1,
-	.u = {	.field_set = (1 << UF_HOST) | (1 << UF_PORT),
+	.u = {	.field_set = BIT(UF_HOST) | BIT(UF_PORT),
 		.port = 443,
 		.field_data = {
 			{  0,  0 },	/* UF_SCHEMA */
@@ -112,7 +112,7 @@ const struct url_test url_tests[] = {
 	.name = "proxy ipv6 request",
 	.url = "http://[1:2::3:4]/",
 	.is_connect = 0,
-	.u = {	.field_set = (1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PATH),
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH),
 		.port = 0,
 		.field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
@@ -129,10 +129,10 @@ const struct url_test url_tests[] = {
 	.name = "proxy ipv6 request with port",
 	.url = "http://[1:2::3:4]:67/",
 	.is_connect = 0,
-	.u = {	.field_set = (1 << UF_SCHEMA) | (1 << UF_HOST) |
-			     (1 << UF_PORT) | (1 << UF_PATH),
-		.port = 67,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) |
+			     BIT(UF_PORT) | BIT(UF_PATH),
+			     .port = 67,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{  8,  8 },	/* UF_HOST */
 			{ 18,  2 },	/* UF_PORT */
@@ -147,7 +147,7 @@ const struct url_test url_tests[] = {
 	.name = "CONNECT ipv6 address",
 	.url = "[1:2::3:4]:443",
 	.is_connect = 1,
-	.u = {	.field_set = (1 << UF_HOST) | (1 << UF_PORT),
+	.u = {	.field_set = BIT(UF_HOST) | BIT(UF_PORT),
 		.port = 443,
 		.field_data = {
 			{  0,  0 },	/* UF_SCHEMA */
@@ -164,7 +164,7 @@ const struct url_test url_tests[] = {
 	.name = "ipv4 in ipv6 address",
 	.url = "http://[2001:0000:0000:0000:0000:0000:1.9.1.1]/",
 	.is_connect = 0,
-	.u = {	.field_set = (1 << UF_SCHEMA) | (1 << UF_HOST) | (1 << UF_PATH),
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH),
 		.port = 0,
 		.field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
@@ -184,10 +184,10 @@ const struct url_test url_tests[] = {
 	       "min.css,fp-category-min.css,fp-sub-min.css,fp-gdp4p-min.css,"
 	       "fp-css3-min.css,fp-misc-min.css?t=20101022.css",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) |
-			     (1<<UF_QUERY),
-		.port = 0,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH) |
+			     BIT(UF_QUERY),
+			     .port = 0,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{  7, 10 },	/* UF_HOST */
 			{  0,  0 },	/* UF_PORT */
@@ -202,7 +202,7 @@ const struct url_test url_tests[] = {
 	.name = "space URL encoded",
 	.url = "/toto.html?toto=a%20b",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_PATH) | (1<<UF_QUERY),
+	.u = {	.field_set = BIT(UF_PATH) | BIT(UF_QUERY),
 		.port = 0,
 		.field_data = {
 			{  0,  0 },	/* UF_SCHEMA */
@@ -219,7 +219,7 @@ const struct url_test url_tests[] = {
 	.name = "URL fragment",
 	.url = "/toto.html#titi",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_PATH) | (1<<UF_FRAGMENT),
+	.u = {	.field_set = BIT(UF_PATH) | BIT(UF_FRAGMENT),
 		.port = 0,
 		.field_data = {
 			{  0,  0 },	/* UF_SCHEMA */
@@ -237,10 +237,10 @@ const struct url_test url_tests[] = {
 	.url = "http://www.webmasterworld.com/r.cgi?f=21&d=8405&url="
 		"http://www.example.com/index.html?foo=bar&hello=world#midpage",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) |
-			     (1<<UF_QUERY) | (1<<UF_FRAGMENT),
-		.port = 0,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH) |
+			     BIT(UF_QUERY) | BIT(UF_FRAGMENT),
+			     .port = 0,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{  7, 22 },	/* UF_HOST */
 			{  0,  0 },	/* UF_PORT */
@@ -255,10 +255,10 @@ const struct url_test url_tests[] = {
 	.name = "complex URL from node js url parser doc",
 	.url = "http://host.com:8080/p/a/t/h?query=string#hash",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PORT) |
-			     (1<<UF_PATH) | (1<<UF_QUERY) | (1<<UF_FRAGMENT),
-		.port = 8080,
-		.field_data =  {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PORT) |
+			     BIT(UF_PATH) | BIT(UF_QUERY) | BIT(UF_FRAGMENT),
+			     .port = 8080,
+			     .field_data =  {
 			{  0,  4 },	/* UF_SCHEMA */
 			{  7,  8 },	/* UF_HOST */
 			{ 16,  4 },	/* UF_PORT */
@@ -273,11 +273,11 @@ const struct url_test url_tests[] = {
 	.name = "complex URL with basic auth from node js url parser doc",
 	.url = "http://a:b@host.com:8080/p/a/t/h?query=string#hash",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PORT) |
-			     (1<<UF_PATH) | (1<<UF_QUERY) | (1<<UF_FRAGMENT) |
-			     (1<<UF_USERINFO),
-	.port = 8080,
-	.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PORT) |
+			     BIT(UF_PATH) | BIT(UF_QUERY) | BIT(UF_FRAGMENT) |
+			     BIT(UF_USERINFO),
+			     .port = 8080,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{ 11,  8 },	/* UF_HOST */
 			{ 20,  4 },	/* UF_PORT */
@@ -347,10 +347,10 @@ const struct url_test url_tests[] = {
 	.name = "proxy basic auth with space url encoded",
 	.url = "http://a%20:b@host.com/",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) |
-			     (1<<UF_USERINFO),
-		.port = 0,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH) |
+			     BIT(UF_USERINFO),
+			     .port = 0,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{ 14,  8 },	/* UF_HOST */
 			{  0,  0 },	/* UF_PORT */
@@ -377,10 +377,10 @@ const struct url_test url_tests[] = {
 	.name = "proxy basic auth with double :",
 	.url = "http://a::b@host.com/",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) |
-			     (1<<UF_USERINFO),
-		.port = 0,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH) |
+			     BIT(UF_USERINFO),
+			     .port = 0,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{ 12,  8 },	/* UF_HOST */
 			{  0,  0 },	/* UF_PORT */
@@ -400,7 +400,7 @@ const struct url_test url_tests[] = {
 	{
 	.name = "proxy empty basic auth",
 	.url = "http://@hostname/fo",
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH),
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH),
 		.port = 0,
 		.field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
@@ -435,10 +435,10 @@ const struct url_test url_tests[] = {
 	.name = "proxy basic auth with unreservedchars",
 	.url = "http://a!;-_!=+$@host.com/",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH) |
-			     (1<<UF_USERINFO),
-		.port = 0,
-		.field_data = {
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH) |
+			     BIT(UF_USERINFO),
+			     .port = 0,
+			     .field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
 			{ 17,  8 },	/* UF_HOST */
 			{  0,  0 },	/* UF_PORT */
@@ -477,7 +477,7 @@ const struct url_test url_tests[] = {
 	.name = "ipv6 address with Zone ID",
 	.url = "http://[fe80::a%25eth0]/",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH),
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH),
 		.port = 0,
 		.field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
@@ -494,7 +494,7 @@ const struct url_test url_tests[] = {
 	.name = "ipv6 address with Zone ID, but '%' is not percent-encoded",
 	.url = "http://[fe80::a%eth0]/",
 	.is_connect = 0,
-	.u = {	.field_set = (1<<UF_SCHEMA) | (1<<UF_HOST) | (1<<UF_PATH),
+	.u = {	.field_set = BIT(UF_SCHEMA) | BIT(UF_HOST) | BIT(UF_PATH),
 		.port = 0,
 		.field_data = {
 			{  0,  4 },	/* UF_SCHEMA */
@@ -543,7 +543,7 @@ const struct url_test url_tests[] = {
 	{
 	.name = "tab in URL",
 	.url = "/foo\tbar/",
-	.u = {	.field_set = (1 << UF_PATH),
+	.u = {	.field_set = BIT(UF_PATH),
 		.field_data = {
 			{  0,  0 },	/* UF_SCHEMA */
 			{  0,  0 },	/* UF_HOST */
@@ -558,7 +558,7 @@ const struct url_test url_tests[] = {
 	{
 	.name = "form feed in URL",
 	.url = "/foo\fbar/",
-	.u = {	.field_set = (1 << UF_PATH),
+	.u = {	.field_set = BIT(UF_PATH),
 		.field_data = {
 			{  0,  0 },	/* UF_SCHEMA */
 			{  0,  0 },	/* UF_HOST */
diff -u -p a/tests/lib/ringbuffer/src/main.c b/tests/lib/ringbuffer/src/main.c
--- a/tests/lib/ringbuffer/src/main.c
+++ b/tests/lib/ringbuffer/src/main.c
@@ -176,7 +176,7 @@ void test_ringbuffer_init(void)
 void test_ringbuffer_declare_pow2(void)
 {
 	zassert_true(ring_buf_is_empty(&ringbuf_pow2), NULL);
-	zassert_equal(ring_buf_space_get(&ringbuf_pow2), (1 << POW) - 1, NULL);
+	zassert_equal(ring_buf_space_get(&ringbuf_pow2), BIT(POW) - 1, NULL);
 }
 
 void test_ringbuffer_declare_size(void)
diff -u -p a/tests/lib/cmsis_dsp/complexmath/src/q31.c b/tests/lib/cmsis_dsp/complexmath/src/q31.c
--- a/tests/lib/cmsis_dsp/complexmath/src/q31.c
+++ b/tests/lib/cmsis_dsp/complexmath/src/q31.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)100)
 #define ABS_ERROR_THRESH_Q31	((q31_t)100)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 18))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(18)))
 
 static void test_arm_cmplx_conj_q31(
 	const q31_t *input1, const q31_t *ref, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/basicmath/src/q7.c b/tests/lib/cmsis_dsp/basicmath/src/q7.c
--- a/tests/lib/cmsis_dsp/basicmath/src/q7.c
+++ b/tests/lib/cmsis_dsp/basicmath/src/q7.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)20)
 #define ABS_ERROR_THRESH_Q7	((q7_t)2)
-#define ABS_ERROR_THRESH_Q31	((q31_t)(1 << 15))
+#define ABS_ERROR_THRESH_Q31	((q31_t)(BIT(15)))
 
 static void test_arm_add_q7(
 	const q7_t *input1, const q7_t *input2, const q7_t *ref, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/unary_q31.c b/tests/lib/cmsis_dsp/matrix/src/unary_q31.c
--- a/tests/lib/cmsis_dsp/matrix/src/unary_q31.c
+++ b/tests/lib/cmsis_dsp/matrix/src/unary_q31.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)100)
 #define ABS_ERROR_THRESH_Q31	((q31_t)2)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 16))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(16)))
 
 #define NUM_MATRICES		(ARRAY_SIZE(in_dims) / 2)
 #define MAX_MATRIX_DIM		(40)
diff -u -p a/tests/kernel/gen_isr_table/src/main.c b/tests/kernel/gen_isr_table/src/main.c
--- a/tests/kernel/gen_isr_table/src/main.c
+++ b/tests/kernel/gen_isr_table/src/main.c
@@ -95,7 +95,7 @@ void trigger_irq(int irq)
 
 	__asm__ volatile ("csrrs %0, mip, %1\n"
 			  : "=r" (mip)
-			  : "r" (1 << irq));
+			  : "r" (BIT(irq)));
 }
 #elif defined(CONFIG_CPU_ARCV2)
 void trigger_irq(int irq)
diff -u -p a/samples/subsys/ipc/openamp/src/main.c b/samples/subsys/ipc/openamp/src/main.c
--- a/samples/subsys/ipc/openamp/src/main.c
+++ b/samples/subsys/ipc/openamp/src/main.c
@@ -74,7 +74,7 @@ static void virtio_set_status(struct vir
 
 static uint32_t virtio_get_features(struct virtio_device *vdev)
 {
-	return 1 << VIRTIO_RPMSG_F_NS;
+	return BIT(VIRTIO_RPMSG_F_NS);
 }
 
 static void virtio_set_features(struct virtio_device *vdev,
diff -u -p a/arch/xtensa/core/xtensa-asm2.c b/arch/xtensa/core/xtensa-asm2.c
--- a/arch/xtensa/core/xtensa-asm2.c
+++ b/arch/xtensa/core/xtensa-asm2.c
@@ -214,5 +214,5 @@ int z_xtensa_irq_is_enabled(unsigned int
 
 	__asm__ volatile("rsr.intenable %0" : "=r"(ie));
 
-	return (ie & (1 << irq)) != 0;
+	return (ie & BIT(irq)) != 0;
 }
diff -u -p a/boards/arm/mps2_an385/pinmux.c b/boards/arm/mps2_an385/pinmux.c
--- a/boards/arm/mps2_an385/pinmux.c
+++ b/boards/arm/mps2_an385/pinmux.c
@@ -123,34 +123,34 @@ static void arm_mps2_pinmux_defaults(voi
 
 	/* Set GPIO Alternate Functions */
 
-	gpio_0 = (1<<0)   /* Shield 0 UART 3 RXD */
-	       | (1<<4)   /* Shield 0 UART 3 TXD */
-	       | (1<<5)   /* Shield 0 I2C SCL SBCON2 */
-	       | (1<<15)  /* Shield 0 I2C SDA SBCON2 */
-	       | (1<<11)  /* Shield 0 SPI 3 SCK */
-	       | (1<<12)  /* Shield 0 SPI 3 SS */
-	       | (1<<13)  /* Shield 0 SPI 3 MOSI */
-	       | (1<<14); /* Shield 0 SPI 3 MISO */
+	gpio_0 = BIT(0)   /* Shield 0 UART 3 RXD */
+	       | BIT(4)   /* Shield 0 UART 3 TXD */
+	       | BIT(5)   /* Shield 0 I2C SCL SBCON2 */
+	       | BIT(15)  /* Shield 0 I2C SDA SBCON2 */
+	       | BIT(11)  /* Shield 0 SPI 3 SCK */
+	       | BIT(12)  /* Shield 0 SPI 3 SS */
+	       | BIT(13)  /* Shield 0 SPI 3 MOSI */
+	       | BIT(14); /* Shield 0 SPI 3 MISO */
 
 	CMSDK_AHB_GPIO0_DEV->altfuncset = gpio_0;
 
-	gpio_1 = (1<<10) /* Shield 1 UART 4 RXD */
-	       | (1<<14) /* Shield 1 UART 4 TXD */
-	       | (1<<15) /* Shield 1 I2C SCL SBCON3 */
-	       | (1<<0)  /* ADC SPI 2 SS */
-	       | (1<<1)  /* ADC SPI 2 MISO */
-	       | (1<<2)  /* ADC SPI 2 MOSI */
-	       | (1<<3)  /* ADC SPI 2 SCK */
-	       | (1<<5)  /* USER BUTTON 0 */
-	       | (1<<6); /* USER BUTTON 1 */
+	gpio_1 = BIT(10) /* Shield 1 UART 4 RXD */
+	       | BIT(14) /* Shield 1 UART 4 TXD */
+	       | BIT(15) /* Shield 1 I2C SCL SBCON3 */
+	       | BIT(0)  /* ADC SPI 2 SS */
+	       | BIT(1)  /* ADC SPI 2 MISO */
+	       | BIT(2)  /* ADC SPI 2 MOSI */
+	       | BIT(3)  /* ADC SPI 2 SCK */
+	       | BIT(5)  /* USER BUTTON 0 */
+	       | BIT(6); /* USER BUTTON 1 */
 
 	CMSDK_AHB_GPIO1_DEV->altfuncset = gpio_1;
 
-	gpio_2 = (1<<9)   /* Shield 1 I2C SDA SBCON3 */
-	       | (1<<6)   /* Shield 1 SPI 4 SS */
-	       | (1<<7)   /* Shield 1 SPI 4 MOSI */
-	       | (1<<8)   /* Shield 1 SPI 4 MISO */
-	       | (1<<12); /* Shield 1 SPI 4 SCK */
+	gpio_2 = BIT(9)   /* Shield 1 I2C SDA SBCON3 */
+	       | BIT(6)   /* Shield 1 SPI 4 SS */
+	       | BIT(7)   /* Shield 1 SPI 4 MOSI */
+	       | BIT(8)   /* Shield 1 SPI 4 MISO */
+	       | BIT(12); /* Shield 1 SPI 4 SCK */
 
 	CMSDK_AHB_GPIO2_DEV->altfuncset = gpio_2;
 }
diff -u -p a/lib/cmsis_rtos_v1/cmsis_signal.c b/lib/cmsis_rtos_v1/cmsis_signal.c
--- a/lib/cmsis_rtos_v1/cmsis_signal.c
+++ b/lib/cmsis_rtos_v1/cmsis_signal.c
@@ -8,7 +8,7 @@
 #include <cmsis_os.h>
 
 #define NSEC_PER_MSEC		(NSEC_PER_USEC * USEC_PER_MSEC)
-#define MAX_VALID_SIGNAL_VAL	((1 << osFeature_Signals) - 1)
+#define MAX_VALID_SIGNAL_VAL	(BIT(osFeature_Signals) - 1)
 
 void *k_thread_other_custom_data_get(struct k_thread *thread_id)
 {
diff -u -p a/lib/os/heap-validate.c b/lib/os/heap-validate.c
--- a/lib/os/heap-validate.c
+++ b/lib/os/heap-validate.c
@@ -60,7 +60,7 @@ static inline void check_nexts(struct z_
 {
 	struct z_heap_bucket *b = &h->buckets[bidx];
 
-	bool emptybit = (h->avail_buckets & (1 << bidx)) == 0;
+	bool emptybit = (h->avail_buckets & BIT(bidx)) == 0;
 	bool emptylist = b->next == 0;
 	bool empties_match = emptybit == emptylist;
 
@@ -107,7 +107,7 @@ bool sys_heap_validate(struct sys_heap *
 			set_chunk_used(h, c, true);
 		}
 
-		bool empty = (h->avail_buckets & (1 << b)) == 0;
+		bool empty = (h->avail_buckets & BIT(b)) == 0;
 		bool zero = n == 0;
 
 		if (empty != zero) {
@@ -248,7 +248,7 @@ static size_t rand_alloc_size(struct z_h
 	 */
 	int scale = 4 + __builtin_clz(rand32());
 
-	return rand32() & ((1 << scale) - 1);
+	return rand32() & (BIT(scale) - 1);
 }
 
 /* Returns the index of a randomly chosen block to free */
@@ -335,7 +335,7 @@ void heap_dump(struct z_heap *h)
 		}
 
 		printk("bucket %d (min %d units): %d chunks\n", i,
-		       (1 << i) - 1 + min_chunk_size(h), count);
+		       BIT(i) - 1 + min_chunk_size(h), count);
 	}
 
 	for (chunkid_t c = 0; ; c = right_chunk(h, c)) {
diff -u -p a/drivers/wifi/simplelink/simplelink_support.c b/drivers/wifi/simplelink/simplelink_support.c
--- a/drivers/wifi/simplelink/simplelink_support.c
+++ b/drivers/wifi/simplelink/simplelink_support.c
@@ -19,9 +19,9 @@ LOG_MODULE_DECLARE(LOG_MODULE_NAME);
 
 #include "simplelink_support.h"
 
-#define SET_STATUS_BIT(status, bit) {status |= (1 << (bit)); }
-#define CLR_STATUS_BIT(status, bit) {status &= ~(1 << (bit)); }
-#define GET_STATUS_BIT(status, bit) (0 != (status & (1 << (bit))))
+#define SET_STATUS_BIT(status, bit) {status |= BIT((bit)); }
+#define CLR_STATUS_BIT(status, bit) {status &= ~BIT((bit)); }
+#define GET_STATUS_BIT(status, bit) (0 != (status & BIT((bit))))
 
 #define SL_STOP_TIMEOUT	 (200)
 
diff -u -p a/drivers/video/mt9m114.c b/drivers/video/mt9m114.c
--- a/drivers/video/mt9m114.c
+++ b/drivers/video/mt9m114.c
@@ -22,11 +22,11 @@ LOG_MODULE_REGISTER(mt9m114);
 /* Sysctl registers */
 #define MT9M114_CHIP_ID					0x0000
 #define MT9M114_COMMAND_REGISTER			0x0080
-#define MT9M114_COMMAND_REGISTER_APPLY_PATCH		(1 << 0)
-#define MT9M114_COMMAND_REGISTER_SET_STATE		(1 << 1)
-#define MT9M114_COMMAND_REGISTER_REFRESH		(1 << 2)
-#define MT9M114_COMMAND_REGISTER_WAIT_FOR_EVENT		(1 << 3)
-#define MT9M114_COMMAND_REGISTER_OK			(1 << 15)
+#define MT9M114_COMMAND_REGISTER_APPLY_PATCH		BIT(0)
+#define MT9M114_COMMAND_REGISTER_SET_STATE		BIT(1)
+#define MT9M114_COMMAND_REGISTER_REFRESH		BIT(2)
+#define MT9M114_COMMAND_REGISTER_WAIT_FOR_EVENT		BIT(3)
+#define MT9M114_COMMAND_REGISTER_OK			BIT(15)
 #define MT9M114_PAD_CONTROL				0x0032
 #define MT9M114_RST_AND_MISC_CONTROL			0x001A
 
diff -u -p a/drivers/pwm/pwm_sam0_tcc.c b/drivers/pwm/pwm_sam0_tcc.c
--- a/drivers/pwm/pwm_sam0_tcc.c
+++ b/drivers/pwm/pwm_sam0_tcc.c
@@ -62,8 +62,8 @@ static int pwm_sam0_pin_set(const struct
 {
 	const struct pwm_sam0_config *const cfg = DEV_CFG(dev);
 	Tcc *regs = cfg->regs;
-	uint32_t top = 1 << cfg->counter_size;
-	uint32_t invert_mask = 1 << ch;
+	uint32_t top = BIT(cfg->counter_size);
+	uint32_t invert_mask = BIT(ch);
 	bool invert = ((flags & PWM_POLARITY_INVERTED) != 0);
 	bool inverted = ((regs->DRVCTRL.vec.INVEN & invert_mask) != 0);
 
diff -u -p a/drivers/interrupt_controller/intc_plic.c b/drivers/interrupt_controller/intc_plic.c
--- a/drivers/interrupt_controller/intc_plic.c
+++ b/drivers/interrupt_controller/intc_plic.c
@@ -53,7 +53,7 @@ void riscv_plic_irq_enable(uint32_t irq)
 
 	key = irq_lock();
 	en += (irq >> 5);
-	*en |= (1 << (irq & 31));
+	*en |= BIT((irq & 31));
 	irq_unlock(key);
 }
 
@@ -76,7 +76,7 @@ void riscv_plic_irq_disable(uint32_t irq
 
 	key = irq_lock();
 	en += (irq >> 5);
-	*en &= ~(1 << (irq & 31));
+	*en &= ~BIT((irq & 31));
 	irq_unlock(key);
 }
 
@@ -94,7 +94,7 @@ int riscv_plic_irq_is_enabled(uint32_t i
 	volatile uint32_t *en = (volatile uint32_t *)PLIC_IRQ_EN;
 
 	en += (irq >> 5);
-	return !!(*en & (1 << (irq & 31)));
+	return !!(*en & BIT((irq & 31)));
 }
 
 /**
diff -u -p a/drivers/interrupt_controller/intc_vexriscv_litex.c b/drivers/interrupt_controller/intc_vexriscv_litex.c
--- a/drivers/interrupt_controller/intc_vexriscv_litex.c
+++ b/drivers/interrupt_controller/intc_vexriscv_litex.c
@@ -66,32 +66,32 @@ static void vexriscv_litex_irq_handler(c
 	irqs = pending & mask;
 
 #ifdef CONFIG_LITEX_TIMER
-	if (irqs & (1 << TIMER0_IRQ)) {
+	if (irqs & BIT(TIMER0_IRQ)) {
 		ite = &_sw_isr_table[TIMER0_IRQ];
 		ite->isr(ite->arg);
 	}
 #endif
 
 #ifdef CONFIG_UART_INTERRUPT_DRIVEN
-	if (irqs & (1 << UART0_IRQ)) {
+	if (irqs & BIT(UART0_IRQ)) {
 		ite = &_sw_isr_table[UART0_IRQ];
 		ite->isr(ite->arg);
 	}
 #endif
 
 #ifdef CONFIG_ETH_LITEETH
-	if (irqs & (1 << ETH0_IRQ)) {
+	if (irqs & BIT(ETH0_IRQ)) {
 		ite = &_sw_isr_table[ETH0_IRQ];
 		ite->isr(ite->arg);
 	}
 #endif
 
 #ifdef CONFIG_I2S
-	if (irqs & (1 << I2S_RX_IRQ)) {
+	if (irqs & BIT(I2S_RX_IRQ)) {
 		ite = &_sw_isr_table[I2S_RX_IRQ];
 		ite->isr(ite->arg);
 	}
-	if (irqs & (1 << I2S_TX_IRQ)) {
+	if (irqs & BIT(I2S_TX_IRQ)) {
 		ite = &_sw_isr_table[I2S_TX_IRQ];
 		ite->isr(ite->arg);
 	}
@@ -100,25 +100,25 @@ static void vexriscv_litex_irq_handler(c
 
 void arch_irq_enable(unsigned int irq)
 {
-	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() | (1 << irq));
+	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() | BIT(irq));
 }
 
 void arch_irq_disable(unsigned int irq)
 {
-	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() & ~(1 << irq));
+	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() & ~BIT(irq));
 }
 
 int arch_irq_is_enabled(unsigned int irq)
 {
-	return vexriscv_litex_irq_getmask() & (1 << irq);
+	return vexriscv_litex_irq_getmask() & BIT(irq);
 }
 
 static int vexriscv_litex_irq_init(const struct device *dev)
 {
 	ARG_UNUSED(dev);
 	__asm__ volatile ("csrrs x0, mie, %0"
-			:: "r"((1 << RISCV_MACHINE_TIMER_IRQ)
-				| (1 << RISCV_MACHINE_EXT_IRQ)));
+			:: "r"(BIT(RISCV_MACHINE_TIMER_IRQ)
+				| BIT(RISCV_MACHINE_EXT_IRQ)));
 	vexriscv_litex_irq_setie(1);
 	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ, 0, vexriscv_litex_irq_handler,
 			NULL, 0);
diff -u -p a/drivers/led/lp5562.c b/drivers/led/lp5562.c
--- a/drivers/led/lp5562.c
+++ b/drivers/led/lp5562.c
@@ -82,19 +82,19 @@ LOG_MODULE_REGISTER(lp5562);
 #define LP5562_MAX_BRIGHTNESS 100
 
 /* Values for ENABLE register. */
-#define LP5562_ENABLE_CHIP_EN (1 << 6)
-#define LP5562_ENABLE_LOG_EN  (1 << 7)
+#define LP5562_ENABLE_CHIP_EN BIT(6)
+#define LP5562_ENABLE_LOG_EN  BIT(7)
 
 /* Values for CONFIG register. */
 #define LP5562_CONFIG_EXTERNAL_CLOCK         0x00
 #define LP5562_CONFIG_INTERNAL_CLOCK         0x01
 #define LP5562_CONFIG_CLOCK_AUTOMATIC_SELECT 0x02
-#define LP5562_CONFIG_PWRSAVE_EN             (1 << 5)
+#define LP5562_CONFIG_PWRSAVE_EN             BIT(5)
 /* Enable 558 Hz frequency for PWM. Default is 256. */
-#define LP5562_CONFIG_PWM_HW_FREQ_558        (1 << 6)
+#define LP5562_CONFIG_PWM_HW_FREQ_558        BIT(6)
 
 /* Values for execution engine programs. */
-#define LP5562_PROG_COMMAND_SET_PWM (1 << 6)
+#define LP5562_PROG_COMMAND_SET_PWM BIT(6)
 #define LP5562_PROG_COMMAND_RAMP_TIME(prescale, step_time) \
 	(((prescale) << 6) | (step_time))
 #define LP5562_PROG_COMMAND_STEP_COUNT(fade_direction, count) \
diff -u -p a/drivers/i2c/i2c_sam_twi.c b/drivers/i2c/i2c_sam_twi.c
--- a/drivers/i2c/i2c_sam_twi.c
+++ b/drivers/i2c/i2c_sam_twi.c
@@ -83,7 +83,7 @@ static int i2c_clk_set(Twi *const twi, u
 	 */
 	while (!div_completed) {
 		cl_div =   ((SOC_ATMEL_SAM_MCK_FREQ_HZ / (speed * 2U)) - 4)
-			 / (1 << ck_div);
+			 / BIT(ck_div);
 
 		if (cl_div <= 255U) {
 			div_completed = true;
diff -u -p a/drivers/i2c/i2c_sam_twihs.c b/drivers/i2c/i2c_sam_twihs.c
--- a/drivers/i2c/i2c_sam_twihs.c
+++ b/drivers/i2c/i2c_sam_twihs.c
@@ -83,7 +83,7 @@ static int i2c_clk_set(Twihs *const twih
 	 */
 	while (!div_completed) {
 		cl_div =   ((SOC_ATMEL_SAM_MCK_FREQ_HZ / (speed * 2U)) - 3)
-			 / (1 << ck_div);
+			 / BIT(ck_div);
 
 		if (cl_div <= 255U) {
 			div_completed = true;
diff -u -p a/drivers/ethernet/eth_enc28j60.c b/drivers/ethernet/eth_enc28j60.c
--- a/drivers/ethernet/eth_enc28j60.c
+++ b/drivers/ethernet/eth_enc28j60.c
@@ -384,7 +384,7 @@ static void eth_enc28j60_init_mac(const 
 	} else {
 		eth_enc28j60_write_reg(dev, ENC28J60_REG_MABBIPG,
 				       ENC28J60_MAC_BBIPG_HD);
-		eth_enc28j60_write_reg(dev, ENC28J60_REG_MACON4, 1 << 6);
+		eth_enc28j60_write_reg(dev, ENC28J60_REG_MACON4, BIT(6));
 	}
 
 	/* Configure MAC address */
diff -u -p a/drivers/flash/soc_flash_nios2_qspi.c b/drivers/flash/soc_flash_nios2_qspi.c
--- a/drivers/flash/soc_flash_nios2_qspi.c
+++ b/drivers/flash/soc_flash_nios2_qspi.c
@@ -30,12 +30,12 @@ LOG_MODULE_REGISTER(flash_nios2_qspi);
  * supports the QSPI Controller v2 IP.
  */
 #define ALTERA_QSPI_CONTROLLER2_FLAG_STATUS_REG		0x0000001C
-#define FLAG_STATUS_PROTECTION_ERROR			(1 << 1)
-#define FLAG_STATUS_PROGRAM_SUSPENDED			(1 << 2)
-#define FLAG_STATUS_PROGRAM_ERROR			(1 << 4)
-#define FLAG_STATUS_ERASE_ERROR				(1 << 5)
-#define FLAG_STATUS_ERASE_SUSPENDED			(1 << 6)
-#define FLAG_STATUS_CONTROLLER_READY			(1 << 7)
+#define FLAG_STATUS_PROTECTION_ERROR			BIT(1)
+#define FLAG_STATUS_PROGRAM_SUSPENDED			BIT(2)
+#define FLAG_STATUS_PROGRAM_ERROR			BIT(4)
+#define FLAG_STATUS_ERASE_ERROR				BIT(5)
+#define FLAG_STATUS_ERASE_SUSPENDED			BIT(6)
+#define FLAG_STATUS_CONTROLLER_READY			BIT(7)
 
 /* ALTERA_QSPI_CONTROLLER2_STATUS_REG bits */
 #define STATUS_PROTECTION_POS				2
diff -u -p a/drivers/audio/intel_dmic.c b/drivers/audio/intel_dmic.c
--- a/drivers/audio/intel_dmic.c
+++ b/drivers/audio/intel_dmic.c
@@ -82,7 +82,7 @@ struct dmic_configuration {
 #define DMIC_HIGH_RATE_OSR_MIN	40
 
 /* Used for scaling FIR coeffcients for HW */
-#define DMIC_HW_FIR_COEF_MAX ((1 << (DMIC_HW_BITS_FIR_COEF - 1)) - 1)
+#define DMIC_HW_FIR_COEF_MAX (BIT((DMIC_HW_BITS_FIR_COEF - 1)) - 1)
 #define DMIC_HW_FIR_COEF_Q (DMIC_HW_BITS_FIR_COEF - 1)
 
 /* Internal precision in gains computation, e.g. Q4.28 in int32_t */
@@ -101,7 +101,7 @@ struct dmic_configuration {
 /* Macros to set bit(s) */
 #define SET_BIT(b, x)		(((x) & 1) << (b))
 #define SET_BITS(b_hi, b_lo, x)	\
-	(((x) & ((1 << ((b_hi) - (b_lo) + 1)) - 1)) << (b_lo))
+	(((x) & (BIT(((b_hi) - (b_lo) + 1)) - 1)) << (b_lo))
 
 #define MIN(a, b) (((a) < (b)) ? (a) : (b))
 #define MAX(a, b) (((a) > (b)) ? (a) : (b))
@@ -605,7 +605,7 @@ static int select_mode(struct dmic_confi
 	/* Calculate remaining gain to FIR in Q format used for gain
 	 * values.
 	 */
-	fir_in_max = (1 << (DMIC_HW_BITS_FIR_INPUT - 1));
+	fir_in_max = BIT((DMIC_HW_BITS_FIR_INPUT - 1));
 	if (cfg->cic_shift >= 0) {
 		cic_out_max = g_cic >> cfg->cic_shift;
 	} else {
diff -u -p a/drivers/sensor/lps22hh/lps22hh_spi.c b/drivers/sensor/lps22hh/lps22hh_spi.c
--- a/drivers/sensor/lps22hh/lps22hh_spi.c
+++ b/drivers/sensor/lps22hh/lps22hh_spi.c
@@ -17,7 +17,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define LPS22HH_SPI_READ		(1 << 7)
+#define LPS22HH_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(LPS22HH, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/lsm6dsl/lsm6dsl.c b/drivers/sensor/lsm6dsl/lsm6dsl.c
--- a/drivers/sensor/lsm6dsl/lsm6dsl.c
+++ b/drivers/sensor/lsm6dsl/lsm6dsl.c
@@ -94,7 +94,7 @@ static inline int lsm6dsl_reboot(const s
 
 	if (data->hw_tf->update_reg(data, LSM6DSL_REG_CTRL3_C,
 				    LSM6DSL_MASK_CTRL3_C_BOOT,
-				    1 << LSM6DSL_SHIFT_CTRL3_C_BOOT) < 0) {
+				    BIT(LSM6DSL_SHIFT_CTRL3_C_BOOT)) < 0) {
 		return -EIO;
 	}
 
@@ -144,7 +144,7 @@ static int lsm6dsl_gyro_set_fs_raw(const
 		if (data->hw_tf->update_reg(data,
 					LSM6DSL_REG_CTRL2_G,
 					LSM6DSL_MASK_CTRL2_FS125,
-					1 << LSM6DSL_SHIFT_CTRL2_FS125) < 0) {
+					BIT(LSM6DSL_SHIFT_CTRL2_FS125)) < 0) {
 			return -EIO;
 		}
 	} else {
@@ -767,9 +767,9 @@ static int lsm6dsl_init_chip(const struc
 				    LSM6DSL_MASK_CTRL3_C_BDU |
 				    LSM6DSL_MASK_CTRL3_C_BLE |
 				    LSM6DSL_MASK_CTRL3_C_IF_INC,
-				    (1 << LSM6DSL_SHIFT_CTRL3_C_BDU) |
+				    BIT(LSM6DSL_SHIFT_CTRL3_C_BDU) |
 				    (0 << LSM6DSL_SHIFT_CTRL3_C_BLE) |
-				    (1 << LSM6DSL_SHIFT_CTRL3_C_IF_INC)) < 0) {
+				    BIT(LSM6DSL_SHIFT_CTRL3_C_IF_INC)) < 0) {
 		LOG_DBG("failed to set BDU, BLE and burst");
 		return -EIO;
 	}
diff -u -p a/drivers/sensor/vcnl4040/vcnl4040_trigger.c b/drivers/sensor/vcnl4040/vcnl4040_trigger.c
--- a/drivers/sensor/vcnl4040/vcnl4040_trigger.c
+++ b/drivers/sensor/vcnl4040/vcnl4040_trigger.c
@@ -215,7 +215,7 @@ int vcnl4040_trigger_set(const struct de
 			}
 
 			/* Set interrupt enable bit 1 */
-			conf |= 1 << 1;
+			conf |= BIT(1);
 
 			if (vcnl4040_write(dev, VCNL4040_REG_ALS_CONF, conf)) {
 				ret = -EIO;
diff -u -p a/drivers/sensor/bma280/bma280.c b/drivers/sensor/bma280/bma280.c
--- a/drivers/sensor/bma280/bma280.c
+++ b/drivers/sensor/bma280/bma280.c
@@ -62,7 +62,7 @@ static void bma280_channel_accel_convert
 	 *             (2^data_width * 10^6)
 	 */
 	raw_val = (raw_val * BMA280_PMU_FULL_RANGE) /
-		  (1 << (8 + BMA280_ACCEL_LSB_BITS));
+		  BIT((8 + BMA280_ACCEL_LSB_BITS));
 	val->val1 = raw_val / 1000000;
 	val->val2 = raw_val % 1000000;
 
diff -u -p a/drivers/sensor/lis2dh/lis2dh_trigger.c b/drivers/sensor/lis2dh/lis2dh_trigger.c
--- a/drivers/sensor/lis2dh/lis2dh_trigger.c
+++ b/drivers/sensor/lis2dh/lis2dh_trigger.c
@@ -202,8 +202,7 @@ int lis2dh_acc_slope_config(const struct
 		}
 
 		/* fs reg value is in the range 0 (2g) - 3 (16g) */
-		range_g = 2 * (1 << ((LIS2DH_FS_MASK & reg_val)
-				      >> LIS2DH_FS_SHIFT));
+		range_g = 2 * BIT(((LIS2DH_FS_MASK & reg_val) >> LIS2DH_FS_SHIFT));
 
 		slope_th_ums2 = val->val1 * 1000000 + val->val2;
 
diff -u -p a/drivers/sensor/iis3dhhc/iis3dhhc_spi.c b/drivers/sensor/iis3dhhc/iis3dhhc_spi.c
--- a/drivers/sensor/iis3dhhc/iis3dhhc_spi.c
+++ b/drivers/sensor/iis3dhhc/iis3dhhc_spi.c
@@ -16,7 +16,7 @@
 
 #if DT_ANY_INST_ON_BUS_STATUS_OKAY(spi)
 
-#define IIS3DHHC_SPI_READ		(1 << 7)
+#define IIS3DHHC_SPI_READ		BIT(7)
 
 LOG_MODULE_DECLARE(IIS3DHHC, CONFIG_SENSOR_LOG_LEVEL);
 
diff -u -p a/drivers/sensor/bmm150/bmm150.c b/drivers/sensor/bmm150/bmm150.c
--- a/drivers/sensor/bmm150/bmm150.c
+++ b/drivers/sensor/bmm150/bmm150.c
@@ -281,7 +281,7 @@ static int32_t bmm150_compensate_z(struc
 		((int32_t)(((int16_t)rhall) - ((int16_t)tregs->xyz1)))) >> 2);
 
 	temp3 = ((int16_t)(((((int32_t)tregs->z1) *
-		((((int16_t)rhall) << 1))) + (1 << 15)) >> 16));
+		((((int16_t)rhall) << 1))) + BIT(15)) >> 16));
 
 	val = ((temp1 - temp2) / (tregs->z2 + temp3));
 
diff -u -p a/drivers/sensor/opt3001/opt3001.c b/drivers/sensor/opt3001/opt3001.c
--- a/drivers/sensor/opt3001/opt3001.c
+++ b/drivers/sensor/opt3001/opt3001.c
@@ -99,7 +99,7 @@ static int opt3001_channel_get(const str
 	 * lux is the integer obtained using the following formula:
 	 * (2^(exponent value)) * 0.01 * mantisa value
 	 */
-	uval = (1 << (drv_data->sample >> OPT3001_SAMPLE_EXPONENT_SHIFT))
+	uval = BIT((drv_data->sample >> OPT3001_SAMPLE_EXPONENT_SHIFT))
 		* (drv_data->sample & OPT3001_MANTISSA_MASK);
 	val->val1 = uval / 100;
 	val->val2 = (uval % 100) * 10000;
diff -u -p a/drivers/sensor/lis2ds12/lis2ds12_trigger.c b/drivers/sensor/lis2ds12/lis2ds12_trigger.c
--- a/drivers/sensor/lis2ds12/lis2ds12_trigger.c
+++ b/drivers/sensor/lis2ds12/lis2ds12_trigger.c
@@ -94,7 +94,7 @@ static int lis2ds12_init_interrupt(const
 	if (data->hw_tf->update_reg(data,
 				    LIS2DS12_REG_CTRL3,
 				    LIS2DS12_MASK_LIR,
-				    (1 << LIS2DS12_SHIFT_LIR)) < 0) {
+				    BIT(LIS2DS12_SHIFT_LIR)) < 0) {
 		LOG_ERR("Could not enable LIR mode.");
 		return -EIO;
 	}
@@ -103,7 +103,7 @@ static int lis2ds12_init_interrupt(const
 	if (data->hw_tf->update_reg(data,
 				    LIS2DS12_REG_CTRL4,
 				    LIS2DS12_MASK_INT1_DRDY,
-				    (1 << LIS2DS12_SHIFT_INT1_DRDY)) < 0) {
+				    BIT(LIS2DS12_SHIFT_INT1_DRDY)) < 0) {
 		LOG_ERR("Could not enable data-ready interrupt.");
 		return -EIO;
 	}
diff -u -p a/drivers/dma/dma_dw.c b/drivers/dma/dma_dw.c
--- a/drivers/dma/dma_dw.c
+++ b/drivers/dma/dma_dw.c
@@ -88,7 +88,7 @@ static void dw_dma_isr(const struct devi
 	/* Dispatch callbacks for channels depending upon the bit set */
 	while (status_block) {
 		channel = find_lsb_set(status_block) - 1;
-		status_block &= ~(1 << channel);
+		status_block &= ~BIT(channel);
 		chan_data = &dev_data->chan[channel];
 
 		if (chan_data->dma_blkcallback) {
@@ -105,7 +105,7 @@ static void dw_dma_isr(const struct devi
 
 	while (status_tfr) {
 		channel = find_lsb_set(status_tfr) - 1;
-		status_tfr &= ~(1 << channel);
+		status_tfr &= ~BIT(channel);
 		chan_data = &dev_data->chan[channel];
 		if (chan_data->dma_tfrcallback) {
 			chan_data->dma_tfrcallback(dev,
@@ -228,11 +228,11 @@ static int dw_dma_config(const struct de
 	/* write interrupt clear registers for the channel
 	 * ClearTfr, ClearBlock, ClearSrcTran, ClearDstTran, ClearErr
 	 */
-	dw_write(dev_cfg->base, DW_CLEAR_TFR, 0x1 << channel);
-	dw_write(dev_cfg->base, DW_CLEAR_BLOCK, 0x1 << channel);
-	dw_write(dev_cfg->base, DW_CLEAR_SRC_TRAN, 0x1 << channel);
-	dw_write(dev_cfg->base, DW_CLEAR_DST_TRAN, 0x1 << channel);
-	dw_write(dev_cfg->base, DW_CLEAR_ERR, 0x1 << channel);
+	dw_write(dev_cfg->base, DW_CLEAR_TFR, BIT(channel));
+	dw_write(dev_cfg->base, DW_CLEAR_BLOCK, BIT(channel));
+	dw_write(dev_cfg->base, DW_CLEAR_SRC_TRAN, BIT(channel));
+	dw_write(dev_cfg->base, DW_CLEAR_DST_TRAN, BIT(channel));
+	dw_write(dev_cfg->base, DW_CLEAR_ERR, BIT(channel));
 
 	/* single transfer, must set zero */
 	dw_write(dev_cfg->base, DW_LLP(channel), 0);
diff -u -p a/drivers/dac/dac_sam0.c b/drivers/dac/dac_sam0.c
--- a/drivers/dac/dac_sam0.c
+++ b/drivers/dac/dac_sam0.c
@@ -70,7 +70,7 @@ static int dac_sam0_init(const struct de
 			    GCLK_CLKCTRL_CLKEN;
 
 	/* Enable the clock in PM */
-	PM->APBCMASK.reg |= 1 << cfg->pm_apbc_bit;
+	PM->APBCMASK.reg |= BIT(cfg->pm_apbc_bit);
 
 	/* Reset then configure the DAC */
 	regs->CTRLA.bit.SWRST = 1;
diff -u -p a/drivers/gpio/gpio_stm32.c b/drivers/gpio/gpio_stm32.c
--- a/drivers/gpio/gpio_stm32.c
+++ b/drivers/gpio/gpio_stm32.c
@@ -92,14 +92,14 @@ static inline uint32_t stm32_pinval_get(
 	uint32_t pinval;
 
 #ifdef CONFIG_SOC_SERIES_STM32F1X
-	pinval = (1 << pin) << GPIO_PIN_MASK_POS;
+	pinval = BIT(pin) << GPIO_PIN_MASK_POS;
 	if (pin < 8) {
-		pinval |= 1 << pin;
+		pinval |= BIT(pin);
 	} else {
-		pinval |= (1 << (pin % 8)) | 0x04000000;
+		pinval |= BIT((pin % 8)) | 0x04000000;
 	}
 #else
-	pinval = 1 << pin;
+	pinval = BIT(pin);
 #endif
 	return pinval;
 }
diff -u -p a/drivers/gpio/gpio_intel_apl.c b/drivers/gpio/gpio_intel_apl.c
--- a/drivers/gpio/gpio_intel_apl.c
+++ b/drivers/gpio/gpio_intel_apl.c
@@ -67,7 +67,7 @@ BUILD_ASSERT(DT_INST_IRQN(0) == 14);
 #define PAD_CFG0_RXEVCFG_POS		25
 #define PAD_CFG0_RXEVCFG_MASK		(0x03 << PAD_CFG0_RXEVCFG_POS)
 #define PAD_CFG0_RXEVCFG_LEVEL		(0 << PAD_CFG0_RXEVCFG_POS)
-#define PAD_CFG0_RXEVCFG_EDGE		(1 << PAD_CFG0_RXEVCFG_POS)
+#define PAD_CFG0_RXEVCFG_EDGE		BIT(PAD_CFG0_RXEVCFG_POS)
 #define PAD_CFG0_RXEVCFG_DRIVE0		(2 << PAD_CFG0_RXEVCFG_POS)
 
 #define PAD_CFG0_PREGFRXSEL		BIT(24)
@@ -83,7 +83,7 @@ BUILD_ASSERT(DT_INST_IRQN(0) == 14);
 #define PAD_CFG1_IOSTERM_POS		8
 #define PAD_CFG1_IOSTERM_MASK		(0x03 << PAD_CFG1_IOSTERM_POS)
 #define PAD_CFG1_IOSTERM_FUNC		(0 << PAD_CFG1_IOSTERM_POS)
-#define PAD_CFG1_IOSTERM_DISPUD		(1 << PAD_CFG1_IOSTERM_POS)
+#define PAD_CFG1_IOSTERM_DISPUD		BIT(PAD_CFG1_IOSTERM_POS)
 #define PAD_CFG1_IOSTERM_PU		(2 << PAD_CFG1_IOSTERM_POS)
 #define PAD_CFG1_IOSTERM_PD		(3 << PAD_CFG1_IOSTERM_POS)
 
diff -u -p a/drivers/serial/uart_ns16550.c b/drivers/serial/uart_ns16550.c
--- a/drivers/serial/uart_ns16550.c
+++ b/drivers/serial/uart_ns16550.c
@@ -226,7 +226,7 @@ BUILD_ASSERT(IS_ENABLED(CONFIG_PCIE), "N
 #define IIRC(dev) (DEV_DATA(dev)->iir_cache)
 
 #if DT_INST_NODE_HAS_PROP(0, reg_shift)
-#define UART_REG_ADDR_INTERVAL (1<<DT_INST_PROP(0, reg_shift))
+#define UART_REG_ADDR_INTERVAL BIT(DT_INST_PROP(0, reg_shift))
 #endif
 
 #ifdef UART_NS16550_ACCESS_IOPORT
diff -u -p a/soc/arm/ti_simplelink/cc13x2_cc26x2/power.c b/soc/arm/ti_simplelink/cc13x2_cc26x2/power.c
--- a/soc/arm/ti_simplelink/cc13x2_cc26x2/power.c
+++ b/soc/arm/ti_simplelink/cc13x2_cc26x2/power.c
@@ -79,7 +79,7 @@ void sys_set_power_state(enum power_stat
 		 * 5. Ensure any possible outstanding AON writes complete
 		 * 6. Enter IDLE
 		 */
-		if ((constraints & (1 << PowerCC26XX_NEED_FLASH_IN_IDLE)) ||
+		if ((constraints & BIT(PowerCC26XX_NEED_FLASH_IN_IDLE)) ||
 			(modeVIMS == VIMS_MODE_DISABLED)) {
 			SysCtrlIdle(VIMS_ON_BUS_ON_MODE);
 		} else {
diff -u -p a/soc/arc/snps_arc_iot/sysconf.c b/soc/arc/snps_arc_iot/sysconf.c
--- a/soc/arc/snps_arc_iot/sysconf.c
+++ b/soc/arc/snps_arc_iot/sysconf.c
@@ -57,10 +57,10 @@ void arc_iot_pll_conf_reg(uint32_t val)
 	/* 0x52000000 is not described in spec. */
 	sysconf_reg_ptr->PLLCON = val | (0x52000000);
 
-	sysconf_reg_ptr->PLLCON = val | (1 << PLLCON_BIT_OFFSET_PLLRST);
-	sysconf_reg_ptr->PLLCON = val & (~(1 << PLLCON_BIT_OFFSET_PLLRST));
+	sysconf_reg_ptr->PLLCON = val | BIT(PLLCON_BIT_OFFSET_PLLRST);
+	sysconf_reg_ptr->PLLCON = val & (~BIT(PLLCON_BIT_OFFSET_PLLRST));
 
-	while (!(sysconf_reg_ptr->PLLSTAT & (1 << PLLSTAT_BIT_OFFSET_PLLSTB)))
+	while (!(sysconf_reg_ptr->PLLSTAT & BIT(PLLSTAT_BIT_OFFSET_PLLSTB)))
 		;
 
 	sysconf_reg_ptr->CLKSEL = CLKSEL_PLL;
@@ -111,7 +111,7 @@ void arc_iot_ahb_clk_enable(uint8_t dev)
 		return;
 	}
 
-	sysconf_reg_ptr->AHBCLKEN |= (1 << dev);
+	sysconf_reg_ptr->AHBCLKEN |= BIT(dev);
 }
 
 void arc_iot_ahb_clk_disable(uint8_t dev)
@@ -120,7 +120,7 @@ void arc_iot_ahb_clk_disable(uint8_t dev
 		return;
 	}
 
-	sysconf_reg_ptr->AHBCLKEN &= (~(1 << dev));
+	sysconf_reg_ptr->AHBCLKEN &= (~BIT(dev));
 }
 
 void arc_iot_apb_clk_divisor(uint8_t div)
@@ -134,7 +134,7 @@ void arc_iot_apb_clk_enable(uint8_t dev)
 		return;
 	}
 
-	sysconf_reg_ptr->APBCLKEN |= (1 << dev);
+	sysconf_reg_ptr->APBCLKEN |= BIT(dev);
 }
 
 void arc_iot_apb_clk_disable(uint8_t dev)
@@ -143,7 +143,7 @@ void arc_iot_apb_clk_disable(uint8_t dev
 		return;
 	}
 
-	sysconf_reg_ptr->APBCLKEN &= (~(1 << dev));
+	sysconf_reg_ptr->APBCLKEN &= (~BIT(dev));
 }
 
 void arc_iot_dio_clk_divisor(uint8_t div)
@@ -290,9 +290,9 @@ void arc_iot_pwm_timer_pause(uint32_t id
 	}
 
 	if (pause) {
-		val |= (1 << id);
+		val |= BIT(id);
 	} else {
-		val &= (~(1 << id));
+		val &= (~BIT(id));
 	}
 
 	sysconf_reg_ptr->TIMER_PAUSE = val;
diff -u -p a/subsys/net/l2/ppp/misc.c b/subsys/net/l2/ppp/misc.c
--- a/subsys/net/l2/ppp/misc.c
+++ b/subsys/net/l2/ppp/misc.c
@@ -45,20 +45,20 @@ static void validate_phase_transition(en
 				      enum ppp_phase new)
 {
 	static const uint8_t valid_transitions[] = {
-		[PPP_DEAD] = 1 << PPP_ESTABLISH,
-		[PPP_ESTABLISH] = 1 << PPP_DEAD |
-				1 << PPP_AUTH |
-				1 << PPP_TERMINATE,
-		[PPP_AUTH] = 1 << PPP_TERMINATE |
-				1 << PPP_NETWORK,
-		[PPP_NETWORK] = 1 << PPP_TERMINATE |
-				1 << PPP_RUNNING,
-		[PPP_RUNNING] = 1 << PPP_TERMINATE |
-				1 << PPP_NETWORK,
-		[PPP_TERMINATE] = 1 << PPP_DEAD,
+		[PPP_DEAD] = BIT(PPP_ESTABLISH),
+		[PPP_ESTABLISH] = BIT(PPP_DEAD) |
+		BIT(PPP_AUTH) |
+		BIT(PPP_TERMINATE),
+		[PPP_AUTH] = BIT(PPP_TERMINATE) |
+		BIT(PPP_NETWORK),
+		[PPP_NETWORK] = BIT(PPP_TERMINATE) |
+		BIT(PPP_RUNNING),
+		[PPP_RUNNING] = BIT(PPP_TERMINATE) |
+		BIT(PPP_NETWORK),
+		[PPP_TERMINATE] = BIT(PPP_DEAD),
 	};
 
-	if (!(valid_transitions[current] & 1 << new)) {
+	if (!(valid_transitions[current] & BIT(new))) {
 		NET_DBG("Invalid phase transition: %s (%d) => %s (%d)",
 			ppp_phase_str(current), current,
 			ppp_phase_str(new), new);
@@ -204,46 +204,46 @@ static void validate_state_transition(en
 {
 	/* See RFC 1661 ch. 4.1 */
 	static const uint16_t valid_transitions[] = {
-		[PPP_INITIAL] = 1 << PPP_CLOSED |
-				1 << PPP_STARTING,
-		[PPP_STARTING] = 1 << PPP_INITIAL |
-				1 << PPP_REQUEST_SENT,
-		[PPP_CLOSED] = 1 << PPP_INITIAL |
-				1 << PPP_REQUEST_SENT,
-		[PPP_STOPPED] = 1 << PPP_STARTING |
-				1 << PPP_CLOSED |
-				1 << PPP_ACK_RECEIVED |
-				1 << PPP_REQUEST_SENT,
-		[PPP_CLOSING] = 1 << PPP_INITIAL |
-				1 << PPP_STOPPING |
-				1 << PPP_CLOSED,
-		[PPP_STOPPING] = 1 << PPP_STARTING |
-				1 << PPP_CLOSING |
-				1 << PPP_STOPPED,
-		[PPP_REQUEST_SENT] = 1 << PPP_STARTING |
-				1 << PPP_CLOSING |
-				1 << PPP_STOPPED |
-				1 << PPP_ACK_SENT |
-				1 << PPP_ACK_RECEIVED,
-		[PPP_ACK_RECEIVED] = 1 << PPP_STARTING |
-				1 << PPP_CLOSING |
-				1 << PPP_OPENED |
-				1 << PPP_REQUEST_SENT |
-				1 << PPP_STOPPED,
-		[PPP_ACK_SENT] = 1 << PPP_STARTING |
-				1 << PPP_CLOSING |
-				1 << PPP_STOPPED |
-				1 << PPP_REQUEST_SENT |
-				1 << PPP_OPENED,
-		[PPP_OPENED] = 1 << PPP_STARTING |
-				1 << PPP_CLOSING |
-				1 << PPP_ACK_SENT |
-				1 << PPP_REQUEST_SENT |
-				1 << PPP_CLOSING |
-				1 << PPP_STOPPING,
+		[PPP_INITIAL] = BIT(PPP_CLOSED) |
+		BIT(PPP_STARTING),
+		[PPP_STARTING] = BIT(PPP_INITIAL) |
+		BIT(PPP_REQUEST_SENT),
+		[PPP_CLOSED] = BIT(PPP_INITIAL) |
+		BIT(PPP_REQUEST_SENT),
+		[PPP_STOPPED] = BIT(PPP_STARTING) |
+		BIT(PPP_CLOSED) |
+		BIT(PPP_ACK_RECEIVED) |
+		BIT(PPP_REQUEST_SENT),
+		[PPP_CLOSING] = BIT(PPP_INITIAL) |
+		BIT(PPP_STOPPING) |
+		BIT(PPP_CLOSED),
+		[PPP_STOPPING] = BIT(PPP_STARTING) |
+		BIT(PPP_CLOSING) |
+		BIT(PPP_STOPPED),
+		[PPP_REQUEST_SENT] = BIT(PPP_STARTING) |
+		BIT(PPP_CLOSING) |
+		BIT(PPP_STOPPED) |
+		BIT(PPP_ACK_SENT) |
+		BIT(PPP_ACK_RECEIVED),
+		[PPP_ACK_RECEIVED] = BIT(PPP_STARTING) |
+		BIT(PPP_CLOSING) |
+		BIT(PPP_OPENED) |
+		BIT(PPP_REQUEST_SENT) |
+		BIT(PPP_STOPPED),
+		[PPP_ACK_SENT] = BIT(PPP_STARTING) |
+		BIT(PPP_CLOSING) |
+		BIT(PPP_STOPPED) |
+		BIT(PPP_REQUEST_SENT) |
+		BIT(PPP_OPENED),
+		[PPP_OPENED] = BIT(PPP_STARTING) |
+		BIT(PPP_CLOSING) |
+		BIT(PPP_ACK_SENT) |
+		BIT(PPP_REQUEST_SENT) |
+		BIT(PPP_CLOSING) |
+		BIT(PPP_STOPPING),
 	};
 
-	if (!(valid_transitions[current] & 1 << new)) {
+	if (!(valid_transitions[current] & BIT(new))) {
 		NET_DBG("Invalid state transition: %s (%d) => %s (%d)",
 			ppp_state_str(current), current,
 			ppp_state_str(new), new);
diff -u -p a/subsys/net/lib/lwm2m/lwm2m_rw_oma_tlv.c b/subsys/net/lib/lwm2m/lwm2m_rw_oma_tlv.c
--- a/subsys/net/lib/lwm2m/lwm2m_rw_oma_tlv.c
+++ b/subsys/net/lib/lwm2m/lwm2m_rw_oma_tlv.c
@@ -172,7 +172,7 @@ static size_t oma_tlv_put(const struct o
 
 	/* first type byte in TLV header */
 	tmp = (tlv->type << 6) |
-	      (tlv->id > 255 ? (1 << 5) : 0) |
+	      (tlv->id > 255 ? BIT(5) : 0) |
 	      (len_type << 3) |
 	      (len_type == 0U ? tlv->length : 0);
 
@@ -246,7 +246,7 @@ static size_t oma_tlv_get(struct oma_tlv
 
 	tlv->type = (buf[0] >> 6) & 3;
 	len_type = (buf[0] >> 3) & 3;
-	len_pos = 1 + (((buf[0] & (1 << 5)) != 0U) ? 2 : 1);
+	len_pos = 1 + (((buf[0] & BIT(5)) != 0U) ? 2 : 1);
 
 	if (buf_read_u8(&buf[1], CPKT_BUF_READ(in->in_cpkt), &tmp_offset) < 0) {
 		return 0;
diff -u -p a/subsys/bluetooth/mesh/cfg_srv.c b/subsys/bluetooth/mesh/cfg_srv.c
--- a/subsys/bluetooth/mesh/cfg_srv.c
+++ b/subsys/bluetooth/mesh/cfg_srv.c
@@ -2884,7 +2884,7 @@ static uint16_t hb_pwr2(uint8_t val, uin
 	} else if (val == 0xff || val == 0x11) {
 		return 0xffff;
 	} else {
-		return (1 << (val - sub));
+		return BIT((val - sub));
 	}
 }
 
diff -u -p a/subsys/disk/disk_access_usdhc.c b/subsys/disk/disk_access_usdhc.c
--- a/subsys/disk/disk_access_usdhc.c
+++ b/subsys/disk/disk_access_usdhc.c
@@ -1722,7 +1722,7 @@ static int usdhc_select_fun(struct usdhc
 		(fun_status[4U] >> 24U);
 
 	/* check if function is support */
-	if (((fun_grp_info[group] & (1 << function)) == 0U) ||
+	if (((fun_grp_info[group] & BIT(function)) == 0U) ||
 		((current_fun_status >>
 		(group * 4U)) & 0xFU) != function) {
 		return -ENOTSUP;
diff -u -p a/tests/lib/json/src/main.c b/tests/lib/json/src/main.c
--- a/tests/lib/json/src/main.c
+++ b/tests/lib/json/src/main.c
@@ -180,8 +180,8 @@ static void test_json_decoding(void)
 	ret = json_obj_parse(encoded, sizeof(encoded) - 1, test_descr,
 			     ARRAY_SIZE(test_descr), &ts);
 
-	zassert_equal(ret, (1 << ARRAY_SIZE(test_descr)) - 1,
-		     "All fields decoded correctly");
+	zassert_equal(ret, BIT(ARRAY_SIZE(test_descr)) - 1,
+		      "All fields decoded correctly");
 
 	zassert_true(!strcmp(ts.some_string, "zephyr 123\\uABCD456"),
 		    "String decoded correctly");
@@ -312,7 +312,7 @@ static void test_json_obj_arr_decoding(v
 	ret = json_obj_parse(encoded, sizeof(encoded) - 1, obj_array_descr,
 			     ARRAY_SIZE(obj_array_descr), &oa);
 
-	zassert_equal(ret, (1 << ARRAY_SIZE(obj_array_descr)) - 1,
+	zassert_equal(ret, BIT(ARRAY_SIZE(obj_array_descr)) - 1,
 		      "Array of object fields decoded correctly");
 	zassert_equal(oa.num_elements, 10,
 		      "Number of object fields decoded correctly");
diff -u -p a/tests/lib/cmsis_dsp/statistics/src/q15.c b/tests/lib/cmsis_dsp/statistics/src/q15.c
--- a/tests/lib/cmsis_dsp/statistics/src/q15.c
+++ b/tests/lib/cmsis_dsp/statistics/src/q15.c
@@ -15,7 +15,7 @@
 
 #define SNR_ERROR_THRESH	((float32_t)50)
 #define ABS_ERROR_THRESH_Q15	((q15_t)100)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 17))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(17)))
 
 static void test_arm_max_q15(
 	const q15_t *input1, int ref_index, size_t length)
diff -u -p a/tests/lib/cmsis_dsp/basicmath/src/q15.c b/tests/lib/cmsis_dsp/basicmath/src/q15.c
--- a/tests/lib/cmsis_dsp/basicmath/src/q15.c
+++ b/tests/lib/cmsis_dsp/basicmath/src/q15.c
@@ -16,7 +16,7 @@
 #define SNR_ERROR_THRESH	((float32_t)70)
 #define SNR_ERROR_THRESH_HIGH	((float32_t)60)
 #define ABS_ERROR_THRESH_Q15	((q15_t)2)
-#define ABS_ERROR_THRESH_Q63	((q63_t)(1 << 17))
+#define ABS_ERROR_THRESH_Q63	((q63_t)(BIT(17)))
 
 static void test_arm_add_q15(
 	const q15_t *input1, const q15_t *input2, const q15_t *ref,
diff -u -p a/tests/lib/cmsis_dsp/matrix/src/binary_q15.c b/tests/lib/cmsis_dsp/matrix/src/binary_q15.c
--- a/tests/lib/cmsis_dsp/matrix/src/binary_q15.c
+++ b/tests/lib/cmsis_dsp/matrix/src/binary_q15.c
@@ -17,7 +17,7 @@
 #define SNR_LOW_ERROR_THRESH		((float32_t)30)
 #define ABS_ERROR_THRESH_Q15		((q15_t)1000)
 #define ABS_HIGH_ERROR_THRESH_Q15	((q15_t)2000)
-#define ABS_ERROR_THRESH_Q63		((q63_t)(1 << 16))
+#define ABS_ERROR_THRESH_Q63		((q63_t)(BIT(16)))
 
 #define NUM_MATRICES			(ARRAY_SIZE(in_dims) / 3)
 #define MAX_MATRIX_DIM			(40)
diff -u -p a/tests/kernel/common/src/bitfield.c b/tests/kernel/common/src/bitfield.c
--- a/tests/kernel/common/src/bitfield.c
+++ b/tests/kernel/common/src/bitfield.c
@@ -11,7 +11,7 @@
 #include <tc_util.h>
 
 #define BIT_INDEX(bit)  (bit >> 3)
-#define BIT_VAL(bit)    (1 << (bit & 0x7))
+#define BIT_VAL(bit)    BIT((bit & 0x7))
 #define BITFIELD_SIZE   512
 
 /**
@@ -39,7 +39,7 @@ void test_bitfield(void)
 	for (bit = 0U; bit < 32; ++bit) {
 		sys_set_bit((mem_addr_t)&b1, bit);
 
-		zassert_equal(b1, (1 << bit),
+		zassert_equal(b1, BIT(bit),
 			      "sys_set_bit failed on bit %d\n", bit);
 
 		zassert_true(sys_test_bit((mem_addr_t)&b1, bit),
@@ -55,13 +55,13 @@ void test_bitfield(void)
 		zassert_false(sys_test_and_set_bit((mem_addr_t)&b1, bit),
 			      "sys_test_and_set_bit erroneously"
 			      " detected bit %d\n", bit);
-		zassert_equal(b1, (1 << bit),
+		zassert_equal(b1, BIT(bit),
 			      "sys_test_and_set_bit did not set bit %d\n",
 			      bit);
 		zassert_true(sys_test_and_set_bit((mem_addr_t)&b1, bit),
 			     "sys_test_and_set_bit did not detect bit %d\n",
 			     bit);
-		zassert_equal(b1, (1 << bit),
+		zassert_equal(b1, BIT(bit),
 			      "sys_test_and_set_bit cleared bit %d\n", bit);
 
 		zassert_true(sys_test_and_clear_bit((mem_addr_t)&b1, bit),
diff -u -p a/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c b/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c
--- a/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c
+++ b/samples/boards/intel_s1000_crb/i2s/src/i2s_sample.c
@@ -48,7 +48,7 @@ LOG_MODULE_REGISTER(i2s_sample);
 
 #define SIGNAL_AMPLITUDE_DBFS		(-36)
 #define SIGNAL_AMPLITUDE_BITS		(31 + (SIGNAL_AMPLITUDE_DBFS / 6))
-#define SIGNAL_AMPLITUDE_SCALE		(1 << SIGNAL_AMPLITUDE_BITS)
+#define SIGNAL_AMPLITUDE_SCALE		BIT(SIGNAL_AMPLITUDE_BITS)
 
 #ifdef AUDIO_PLAY_FROM_HOST
 #define APP_MODE_STRING			"host playback"
diff -u -p a/arch/arc/core/arc_smp.c b/arch/arc/core/arc_smp.c
--- a/arch/arc/core/arc_smp.c
+++ b/arch/arc/core/arc_smp.c
@@ -136,7 +136,7 @@ static int arc_smp_init(const struct dev
 		z_arc_connect_gfrc_enable();
 
 		/* when all cores halt, gfrc halt */
-		z_arc_connect_gfrc_core_set((1 << CONFIG_MP_NUM_CPUS) - 1);
+		z_arc_connect_gfrc_core_set(BIT(CONFIG_MP_NUM_CPUS) - 1);
 		z_arc_connect_gfrc_clear();
 	} else {
 		__ASSERT(0,
diff -u -p a/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c b/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c
--- a/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c
+++ b/boards/arm/nrf5340dk_nrf5340/nrf5340_cpunet_reset.c
@@ -63,7 +63,7 @@ static void remoteproc_mgr_config(void)
 	/* Retain nRF5340 Network MCU in Secure domain (bus
 	 * accesses by Network MCU will have Secure attribute set).
 	 */
-	NRF_SPU->EXTDOMAIN[0].PERM = 1 << 4;
+	NRF_SPU->EXTDOMAIN[0].PERM = BIT(4);
 }
 #endif /* !CONFIG_TRUSTED_EXECUTION_NONSECURE */
 
diff -u -p a/lib/posix/pthread.c b/lib/posix/pthread.c
--- a/lib/posix/pthread.c
+++ b/lib/posix/pthread.c
@@ -172,7 +172,7 @@ int pthread_create(pthread_t *newthread,
 	(void)pthread_mutex_init(&thread->cancel_lock, NULL);
 
 	pthread_mutex_lock(&thread->cancel_lock);
-	thread->cancel_state = (1 << _PTHREAD_CANCEL_POS) & attr->flags;
+	thread->cancel_state = BIT(_PTHREAD_CANCEL_POS) & attr->flags;
 	thread->cancel_pending = 0;
 	pthread_mutex_unlock(&thread->cancel_lock);
 
diff -u -p a/lib/os/mempool.c b/lib/os/mempool.c
--- a/lib/os/mempool.c
+++ b/lib/os/mempool.c
@@ -45,7 +45,7 @@ static void set_alloc_bit(struct sys_mem
 	uint32_t *word;
 	int bit = get_bit_ptr(p, level, bn, &word);
 
-	*word |= (1<<bit);
+	*word |= BIT(bit);
 }
 
 static void clear_alloc_bit(struct sys_mem_pool_base *p, int level, int bn)
@@ -53,7 +53,7 @@ static void clear_alloc_bit(struct sys_m
 	uint32_t *word;
 	int bit = get_bit_ptr(p, level, bn, &word);
 
-	*word &= ~(1<<bit);
+	*word &= ~BIT(bit);
 }
 
 #ifdef CONFIG_ASSERT
-------------------------------------------------------------------------

Processing unsigned_suffix.cocci
with option(s) ""

Message example to submit a patch:
 Find assignments to unsigned variables and add an 'U' to the value
 The semantic patch that makes this report is available
 in scripts/coccinelle//unsigned_suffix.cocci.

 More information about semantic patching is available at
 http://coccinelle.lip6.fr/

Running (4 in parallel): /usr/local/bin/spatch -D report --very-quiet --cocci-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle//unsigned_suffix.cocci --macro-file /Users/yangxueqi/Documents/zephyr/scripts/coccinelle/macros.h --dir /Users/yangxueqi/Documents/zephyr --jobs 4 --chunksize 1
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:234:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:216:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:211:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp_socket.c:66:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp_socket.c:37:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led_strip/ws2812_gpio.c:175:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_rf2xx_iface.c:212:11-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_rf2xx_iface.c:60:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1244:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1262:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1309:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:391:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1130:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1134:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1164:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1181:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:479:32-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:480:36-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:492:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:509:62-63: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:1012:41-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:254:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:794:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:887:31-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_dw1000.c:888:35-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_sam0_tcc.c:68:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_rv32m1_tpm.c:76:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_swerv_pic.c:27:45-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_swerv_pic.c:131:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_hsdk.c:41:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_hsdk.c:26:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_hsdk.c:27:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/nrf_clock_calibration.c:206:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/nrf_clock_calibration.c:211:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/nrf_clock_calibration.c:257:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:162:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:163:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:164:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:169:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:172:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:175:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:179:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:204:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:207:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:210:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:213:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:216:9-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:219:9-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:222:9-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:225:9-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:228:9-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:231:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:439:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_stm32_ll_h7.c:440:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/arcv2_timer0.c:259:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/arcv2_timer0.c:296:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/arcv2_timer0.c:297:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/xlnx_psttc_timer.c:92:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/xlnx_psttc_timer.c:109:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_shell.c:39:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_shell.c:51:37-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:40:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:44:10-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:47:10-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:51:10-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:201:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:249:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:30:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_lpc11u6x.c:31:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_mchp_xec.c:416:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_mchp_xec.c:357:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_mchp_xec.c:239:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_mchp_xec.c:282:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_mchp_xec.c:284:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:135:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:146:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:206:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:66:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_cc13xx_cc26xx.c:77:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_enc424j600.c:380:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_liteeth.c:222:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_liteeth.c:227:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_liteeth.c:122:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32g0x.c:35:50-51: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32g0x.c:148:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nios2_qspi.c:86:4-5: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nios2_qspi.c:280:4-5: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nios2_qspi.c:192:6-7: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/soc_flash_nios2_qspi.c:211:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_gecko.c:138:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_gecko.c:251:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_common.c:38:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_common.c:38:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_stm32.c:676:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_stm32.c:682:23-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_stm32.c:338:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/si7060/si7060.c:63:27-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ms5607/ms5607_spi.c:157:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx.c:430:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx.c:478:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/ipm_stm32wb.c:437:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/ublox-sara-r4.c:1656:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dmamux_stm32.c:165:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dmamux_stm32.c:175:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/ssd1306.c:230:4-5: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/ssd1306.c:232:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/ssd1306.c:256:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/ssd1306.c:262:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_framebuf.c:114:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_framebuf.c:92:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_dacx0508.c:377:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_dacx0508.c:260:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_mcux_pit.c:122:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/eeprom/eeprom_at2x.c:213:27-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/eeprom/eeprom_at2x.c:227:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/eeprom/eeprom_at2x.c:244:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/eeprom/eeprom_at2x.c:254:27-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/eeprom/eeprom_at2x.c:349:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/eeprom/eeprom_at2x.c:433:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_sifive.c:90:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_sifive.c:92:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_sifive.c:94:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_sifive.c:108:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_cc13xx_cc26xx.c:94:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_npcx.c:311:23-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_npcx.c:314:25-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uart.c:272:23-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uart.c:281:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc_mp.c:174:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc_mp.c:206:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc_mp.c:112:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/nordic_nrf/timing.c:77:39-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam0/common/bossa.c:30:13-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/arm/musca_a/soc.c:35:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/timing.c:65:39-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/tracing/tracing_format_common.c:80:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/osdp/src/osdp_cp.c:508:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ppp/fsm.c:390:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/openthread/platform/radio.c:573:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/openthread/platform/uart.c:122:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sockets/sockets_net_mgmt.c:148:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:279:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:280:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:281:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:1919:51-52: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_engine.c:2232:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:727:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:810:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/6lo.c:1315:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/dhcpv4.c:507:60-64: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_uart.c:84:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_telnet.c:423:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/cdc_acm.c:411:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/cdc_acm.c:412:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/audio/audio.c:317:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/audio/audio.c:227:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/audio/audio.c:255:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/audio/audio.c:263:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/audio/audio.c:392:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/class/audio/audio.c:455:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/canopen/canopen_sync.c:24:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/canopen/canopen_program.c:284:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/friend.c:1436:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/cfg_srv.c:1080:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:1280:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:1349:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:1356:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:1485:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:1425:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:811:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/gatt.c:840:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/att.c:1609:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/att.c:1609:34-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/att.c:1206:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/att.c:1206:34-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/att.c:2938:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c:642:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_scan.c:645:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_filter.c:1104:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_filter.c:1105:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_filter.c:991:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_filter.c:996:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_filter.c:589:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_filter.c:606:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:156:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:342:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:331:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:206:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:222:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:223:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:225:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:226:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:233:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:234:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:236:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:266:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:770:12-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:773:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:784:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:496:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:501:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:509:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:522:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:527:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:534:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:539:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:548:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:565:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:568:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:574:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:909:65-67: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:911:15-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_aux.c:804:8-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:161:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:313:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:334:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:342:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:346:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:369:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:375:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:388:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:240:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:241:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:251:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:265:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:278:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:283:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:283:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:289:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:300:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1449:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1450:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1283:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1284:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1262:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:179:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:183:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:188:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:835:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:836:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:584:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:601:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:761:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:761:63-64: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:510:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:540:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:545:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1522:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1538:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:846:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:942:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1171:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1198:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1160:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1165:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1145:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1103:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1110:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1022:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1034:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1037:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1040:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1049:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1063:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1117:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1010:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1011:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:620:27-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:1587:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/radio/radio.c:156:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_l2cap.c:179:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots.c:350:58-59: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_oacp.c:303:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_oacp.c:266:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_oacp.c:58:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_olcp.c:258:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/services/ots/ots_olcp.c:220:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_sdhc.h:693:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_spi_sdhc.c:545:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/fs/nvs/nvs.c:586:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/fs/nvs/nvs.c:595:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:884:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:1124:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:1125:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:1003:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:1004:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:486:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:487:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:548:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:549:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:901:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:902:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:706:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:707:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:832:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:833:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:652:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:652:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:654:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:769:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:770:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/tcp2/src/main.c:191:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/socket/tcp/src/main.c:442:44-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:31:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:203:23-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:215:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:230:17-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:109:23-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:121:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/clock_control/nrf_onoff_and_bt/src/main.c:139:17-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/flash_simulator/src/main.c:115:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/flash_simulator/src/main.c:130:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/dma/loop_transfer/src/dma.c:108:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:285:45-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:564:22-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:828:15-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:844:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:859:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:861:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:688:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:638:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:645:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:661:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:477:22-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:507:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:188:22-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:243:22-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:756:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:338:22-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/counter_basic_api/src/test_counter.c:377:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/fcb/src/settings_test_fcb.c:354:21-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/usb/desc_sections/src/desc_sections.c:163:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/usb/desc_sections/src/desc_sections.c:169:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/x86/info/src/timer.c:56:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_tz_wrap_func/src/main.c:29:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_tz_wrap_func/src/main.c:30:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_tz_wrap_func/src/main.c:31:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_tz_wrap_func/src/main.c:32:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_tz_wrap_func/src/main.c:33:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/support/src/f32.c:419:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/support/src/f32.c:423:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_map/src/main.c:25:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_map/src/main.c:74:16-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_map/src/main.c:150:16-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/mem_protect/mem_map/src/main.c:154:13-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/device/src/abstract_driver.c:23:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/device/src/abstract_driver.c:45:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/pi.c:112:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/pi.c:120:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/pi.c:151:36-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/pi.c:73:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/pi.c:79:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/websocket_client/src/main.c:219:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/jesd216/src/main.c:190:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/jesd216/src/main.c:208:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/jesd216/src/main.c:215:53-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/jesd216/src/main.c:237:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/jesd216/src/main.c:146:54-55: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/shields/x_nucleo_iks02a1/microphone/src/main.c:72:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/mgmt/osdp/src/pd_main.c:37:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/usb/console/src/main.c:18:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/ipc/openamp_rsc_table/src/main_remote.c:253:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/psa_crypto.c:64:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/peripheral_ht/src/hts.c:114:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/usb_transport.c:114:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/usb_transport.c:125:52-53: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/usb_transport.c:128:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/battery/src/battery.c:206:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/battery/src/battery.c:140:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/ti/cc13x2_cc26x2/system_off/src/ext_flash.c:32:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/smp/pi/src/main.c:112:39-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/smp/pi/src/main.c:112:46-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/zefi/zefi.c:80:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/zefi/zefi.c:39:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/pcie.c:135:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/acpi.c:32:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/acpi.c:37:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/arm_mpu_v7_internal.h:222:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/thread.c:141:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:181:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:194:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:168:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:130:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:155:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:280:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:267:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:58:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:45:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:440:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:402:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:389:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:360:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:309:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:424:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_connect.c:335:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/nios2/core/timing.c:64:39-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/libc/minimal/source/time/gmtime.c:93:20-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/libc/minimal/source/time/gmtime.c:50:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/timeutil.c:33:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/kernel/thread.c:631:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/kernel/thread.c:534:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:234:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:216:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:211:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/simplelink/simplelink.c:220:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/simplelink/simplelink.c:72:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/simplelink/simplelink.c:81:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_kw41z.c:594:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:83:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:304:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:312:60-61: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:341:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:341:56-57: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:343:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:343:58-59: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:345:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:345:56-57: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:347:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:347:56-57: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:353:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:703:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:738:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:604:6-7: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:452:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_mcp2515.c:471:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/net/ppp.c:704:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/net/ppp.c:236:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/net/ppp.c:240:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/net/ppp.c:252:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/net/ppp.c:543:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_miwu.c:324:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_dw.c:118:45-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_dw.c:122:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:31:17-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:21:17-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:42:17-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:47:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:60:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:61:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:101:29-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:103:13-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:115:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:122:47-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:123:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:127:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:132:47-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:133:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:140:47-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:142:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gic.c:144:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/mchp_xec_rtos_timer.c:376:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/mchp_xec_rtos_timer.c:106:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nrfx_twim.c:51:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nrfx_twim.c:87:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nrfx_twim.c:106:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nrfx_twim.c:173:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_esp32.c:146:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_nrfx_twi.c:69:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_litex.c:25:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_litex.c:27:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/phy_gecko.c:255:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/phy_sam_gmac.c:207:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:443:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:452:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:114:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:119:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:103:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:375:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:315:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:154:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_gecko.c:159:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_native_posix.c:259:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_mcux_ehci.c:645:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_mcux_ehci.c:692:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_mcux_ehci.c:712:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_mcux_ehci.c:312:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/usb/device/usb_dc_mcux_ehci.c:512:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:186:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:242:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:260:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:384:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:55:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:113:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32wbx.c:131:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:328:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:333:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:333:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:343:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:209:76-77: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/nrf_qspi_nor.c:210:74-75: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:208:11-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:211:11-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:224:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:230:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:236:11-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:238:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:270:11-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:142:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:172:53-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:173:53-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:181:20-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:184:20-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:35:22-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:41:22-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:64:21-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:67:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/jesd216.c:87:21-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:299:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:301:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:280:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:281:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:282:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:283:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:285:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:195:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:72:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:73:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:76:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:77:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xec_qmspi.c:267:45-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcp320x.c:244:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcp320x.c:227:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcp320x.c:91:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mcp320x.c:95:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mchp_xec.c:130:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_mchp_xec.c:240:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/vcnl4040/vcnl4040.c:174:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/vcnl4040/vcnl4040.c:132:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:176:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:182:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:183:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:185:27-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:158:15-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:257:33-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:258:42-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:265:36-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bme680/bme680.c:266:45-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:200:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:105:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:313:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:712:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:689:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:670:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:735:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:739:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:743:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:774:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:780:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:780:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:626:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:629:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:637:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:424:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:161:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:161:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:173:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_shub.c:174:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_trigger.c:103:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_trigger.c:40:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_trigger.c:67:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:137:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:141:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:169:33-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:171:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:171:45-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:224:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:239:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:285:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:304:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_pl330.c:456:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:161:40-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:162:40-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:163:32-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:210:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:137:38-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:138:38-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/display_sdl.c:139:30-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_mcux_dac32.c:71:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_mcux_dac32.c:76:14-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:103:31-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:186:10-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:187:23-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:188:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:121:13-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:121:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_cmos.c:121:35-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_mchp_xec.c:159:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_mchp_xec.c:115:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_mcux_gpt.c:92:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_mcux_gpt.c:64:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_gecko_rtcc.c:61:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_gecko_rtcc.c:64:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_gecko_rtcc.c:171:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_gecko_rtcc.c:181:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_gecko_rtcc.c:107:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pcie/endpoint/pcie_ep_bcm_iproc.c:162:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pcie/endpoint/pcie_ep_bcm_iproc.c:198:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc13xx_cc26xx.c:54:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc13xx_cc26xx.c:159:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_cc32xx.c:91:50-51: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:444:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:447:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:130:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:140:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:341:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:351:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:352:12-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:353:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:354:12-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:277:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:283:53-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:312:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_lpc11u6x.c:314:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:237:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:237:33-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:240:10-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:243:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:257:19-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:605:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:606:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:850:56-57: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:880:57-58: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:1090:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:1020:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:966:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:941:62-63: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:346:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:379:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_ps.c:385:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_xlnx_uartlite.c:79:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:84:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:96:14-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:96:30-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:109:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:256:55-56: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:513:19-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:514:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:515:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:526:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:594:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_lpc11u6x.c:681:58-59: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc.c:157:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc.c:166:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc.c:169:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc.c:172:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/soc.c:175:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/common/soc_sam4l_pm.c:70:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/common/soc_sam4l_pm.c:85:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/common/soc_sam4l_pm.c:44:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/common/soc_sam4l_pm.c:59:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/common/soc_sam4l_pm.c:96:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/device_power.c:199:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/device_power.c:174:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/microchip_mec/mec1501/device_power.c:75:62-63: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arc/snps_nsim/soc.c:32:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/emul/i2c/emul_atmel_at24.c:150:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/osdp/src/osdp_pd.c:529:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ieee802154/ieee802154_frame.c:97:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/canbus/6locan.c:1535:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/canbus/6locan.c:1735:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:42:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:82:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:227:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:231:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:232:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/tftp/tftp_client.c:187:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_shell.c:846:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_shell.c:784:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/shell/shell_help.c:162:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/access.c:453:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/access.c:836:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/prov.c:339:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/conn.c:2295:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/conn.c:2175:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/conn.c:1292:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/settings.c:108:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:1113:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:1544:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:1350:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:1432:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:730:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:731:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:2592:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/bt.c:1845:24-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_aux.c:208:12-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_master.c:124:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_slave.c:133:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv_sync.c:117:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/hal/nrf5/radio/radio.c:727:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ll_tx_pwr.c:48:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ll_tx_pwr.c:71:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ll_tx_pwr.c:146:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ll_tx_pwr.c:168:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_sync.c:299:12-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_sync.c:302:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv_sync.c:313:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_scan_aux.c:320:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_scan_aux.c:189:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_master.c:122:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c:647:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_scan.c:650:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/cntr.c:121:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/hal/RV32M1/cntr.c:122:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:428:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:1224:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:1654:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:1750:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:1762:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:794:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ticker/ticker.c:799:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_stm32_sdmmc.c:193:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_sdhc.h:693:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:2646:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:723:59-63: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:2468:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:2469:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/disk/disk_access_usdhc.c:2032:21-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/debug/coredump/coredump_core.c:79:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/timeutil.c:33:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/ppp/driver/src/main.c:390:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/ppp/driver/src/main.c:319:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/hostname/src/main.c:293:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/hostname/src/main.c:296:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/hostname/src/main.c:301:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/hostname/src/main.c:306:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:90:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:124:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:158:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:144:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:232:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:235:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:241:44-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:173:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:206:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/led/led_api/src/test_led_api.c:211:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/dac/dac_api/src/test_dac.c:74:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:796:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:800:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:393:21-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:353:22-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:354:21-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:321:22-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:322:21-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:869:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:724:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:725:23-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:825:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:827:21-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/openthread/radio_test.c:418:22-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:554:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:561:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:433:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:435:29-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:458:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:459:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:465:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:466:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:467:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:475:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:476:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:477:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:184:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:495:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:526:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:528:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:215:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:217:29-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:311:25-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:313:29-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/nvs/src/main.c:660:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:230:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:231:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:255:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:256:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:648:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:648:51-52: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:668:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/bsim_test_advx/src/main.c:677:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:185:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:218:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:68:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:328:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:343:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:368:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:456:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:442:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:416:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:536:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:538:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/hci_test_app/src/main.c:610:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/bayes/src/f32.c:37:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/bayes/src/f32.c:38:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_q15.c:165:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_q15.c:168:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_q15.c:181:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/starve/src/main.c:40:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/starve/src/main.c:41:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/starve/src/main.c:42:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/timer_api/src/main.c:621:25-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/timer_api/src/main.c:634:23-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/timer_api/src/main.c:614:66-67: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/device/src/main.c:350:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/device/src/main.c:360:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/device/src/main.c:370:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/video/capture/src/main.c:28:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/big_http_download/src/big_http_download.c:317:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/net/sockets/big_http_download/src/big_http_download.c:319:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/net/lwm2m_client/src/lwm2m-client.c:71:27-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_apa102c_bitbang/src/main.c:58:63-64: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/display/src/main.c:82:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/display/src/main.c:186:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/display/src/main.c:107:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/display/src/main.c:133:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/counter/maxim_ds3231/src/main.c:102:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/counter/maxim_ds3231/src/main.c:187:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/counter/maxim_ds3231/src/main.c:154:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/peci/src/main.c:204:9-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/peci/src/main.c:108:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/peci/src/main.c:78:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/mgmt/osdp/src/cp_main.c:65:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/mgmt/osdp/src/cp_main.c:94:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/canbus/canopen/src/main.c:128:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/canbus/canopen/src/main.c:135:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/ipc/ipm_mhu_dual_core/src/main.c:27:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/ipc/ipm_mhu_dual_core/src/main.c:38:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/fs/littlefs/src/main.c:96:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/fs/littlefs/src/main.c:106:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/util_sformat.c:16:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/util_sformat.c:50:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/util_sformat.c:51:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/util_sformat.c:57:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/util_sformat.c:66:14-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/util_sformat.c:109:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/hci_pwr_ctrl/src/main.c:234:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/hci_pwr_ctrl/src/main.c:254:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/peripheral_ots/src/main.c:191:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/peripheral_ots/src/main.c:126:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/st_ble_sensor/src/button_svc.c:94:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/st_ble_sensor/src/button_svc.c:55:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/bluetooth/mesh_provisioner/src/main.c:16:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c:97:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/intel_s1000_crb/audio/src/tuning_driver.c:120:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:83:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:83:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:87:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:87:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:90:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:90:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:95:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:95:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:98:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:99:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:103:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/bbc_microbit/line_follower_robot/src/main.c:104:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/mec15xxevb_assy6853/power_management/src/power_mgmt.c:145:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/mec15xxevb_assy6853/power_management/src/power_mgmt.c:146:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/mec15xxevb_assy6853/power_management/src/power_mgmt.c:153:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/mec15xxevb_assy6853/power_management/src/power_mgmt.c:154:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/common/sw_isr_common.c:57:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/common/sw_isr_common.c:59:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/common/sw_isr_common.c:94:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/common/sw_isr_common.c:102:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/intel64/thread.c:38:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/fatal.c:76:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/multiboot.c:134:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/core/multiboot.c:135:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/x86/timing.c:84:39-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/mpu/nxp_mpu.c:457:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/mpu/arc_mpu_v3_internal.h:843:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:226:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:234:8-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:238:8-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:242:8-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:247:8-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:251:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/nrf9160dk_nrf52840/board.c:255:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mimxrt1050_evk/pinmux.c:48:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mimxrt1060_evk/pinmux.c:51:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/posix/pthread.c:150:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/prf.c:268:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:227:45-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ieee802154/ieee802154_nrf5.c:72:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_stm32.c:340:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_stm32.c:341:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_stm32.c:342:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_stm32.c:343:27-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_stm32.c:344:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/can/can_stm32.c:345:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/kscan/kscan_mchp_xec.c:401:25-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mchp_xec.c:204:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mchp_xec.c:205:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mchp_xec.c:253:38-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mchp_xec.c:261:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mchp_xec.c:133:17-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mchp_xec.c:119:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_sam0_eic.c:145:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_sam0_eic.c:308:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_sam0_eic.c:71:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_sam0_eic.c:73:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_sam0_eic.c:244:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/ht16k33.c:116:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_lpc11u6x.c:68:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_lpc11u6x.c:46:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_nrf.c:131:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/cortex_m_systick.c:128:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/nrf_rtc_timer.c:88:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/nrf_rtc_timer.c:125:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_sam0.c:314:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_sam0.c:333:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_sam0.c:218:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_sam0.c:237:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_sam0.c:159:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_sam0.c:409:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_sam_gmac.c:259:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32g4x.c:122:18-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32g4x.c:170:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/flash_stm32f4x.c:90:15-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:764:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:770:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:771:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:776:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:785:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:555:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/flash/spi_nor.c:685:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_xlnx_axi_quadspi.c:171:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam0.c:128:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam0.c:187:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam0.c:192:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam0.c:489:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_sam0.c:445:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:144:35-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:181:47-51: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:186:52-56: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:192:45-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:197:46-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:358:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:358:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:358:60-61: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:359:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:359:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:359:55-56: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:447:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:456:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:546:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:555:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:568:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/bq274xx/bq274xx.c:588:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_trigger.c:103:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_trigger.c:40:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso_trigger.c:67:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:200:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:105:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:313:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:716:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:692:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:673:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:739:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:743:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:747:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:777:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:783:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:783:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:629:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:632:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:640:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:161:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:161:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:173:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/ism330dhcx/ism330dhcx_shub.c:174:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/spi.c:340:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/bluetooth/hci/spi.c:353:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3169:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3171:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:599:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3598:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3721:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3722:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3722:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1195:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1668:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1403:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3511:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3244:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:3245:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/hl7800.c:1295:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/lora/sx1276.c:273:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/lora/sx1276.c:369:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/lora/sx1276.c:370:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/lora/sx1276.c:259:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_timer.c:183:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_timer.c:185:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_rtc.c:254:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_rtc.c:275:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_rtc.c:277:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_rtc.c:282:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_rtc.c:311:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/counter_nrfx_rtc.c:133:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pcie/host/pcie.c:55:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_intel_apl.c:408:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_intel_apl.c:442:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_intel_apl.c:460:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_gecko.c:250:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:815:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:815:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:788:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:788:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:1247:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:1283:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:1288:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/console/gsm_mux.c:1307:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:128:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:131:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:132:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam/sam4l/soc.c:133:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam0/common/soc_samd5x.c:107:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam0/common/soc_samd5x.c:109:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/atmel_sam0/common/soc_samd5x.c:111:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arc/snps_arc_hsdk/soc.c:27:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/riscv/riscv-privilege/common/soc_common_irq.c:44:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/riscv/riscv-privilege/common/soc_common_irq.c:21:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/riscv/riscv-privilege/common/soc_common_irq.c:81:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/riscv/riscv-privilege/common/soc_common_irq.c:65:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/power/policy/policy_residency_cc13x2_cc26x2.c:71:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/power/policy/policy_residency_cc13x2_cc26x2.c:77:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/ec_host_cmd/ec_host_cmd_handler.c:26:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/ec_host_cmd/ec_host_cmd_handler.c:105:50-51: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/osdp/src/osdp_phy.c:33:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/osdp/src/osdp_phy.c:214:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/l2/ppp/link.c:72:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/ipso_onoff_switch.c:158:54-58: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/ipso_onoff_switch.c:139:54-58: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/dns/resolve.c:873:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/dns/resolve.c:355:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sntp/sntp_simple.c:46:16-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/sntp/sntp_simple.c:57:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp2.c:209:45-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp2.c:608:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp2.c:493:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp2.c:513:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp2.c:524:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp2.c:813:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/net_if.c:214:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/ipv6_nbr.c:2374:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/isotp/isotp.c:485:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/isotp/isotp.c:269:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:1922:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:1936:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:1730:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:1779:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:261:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:482:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:490:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/transport.c:495:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/hci_core.c:6574:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/ll.c:150:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/ll.c:188:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/ll.c:203:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/ll.c:216:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/ll.c:227:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/gatt.c:906:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/gatt.c:699:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/shell/gatt.c:425:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:843:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:847:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:851:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:115:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/nordic/lll/lll_adv.c:119:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv.c:96:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv.c:98:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv.c:1588:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv.c:1491:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_adv.c:1498:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:544:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:545:46-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:96:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:225:7-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:259:47-51: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:263:50-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_sched.c:182:44-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_slave.c:131:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:842:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:846:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:850:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:769:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/openisa/lll/lll_adv.c:773:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/util/util.c:204:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/random/rand32_xoroshiro128.c:102:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/random/rand32_xoroshiro128.c:103:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/random/rand32_timer.c:65:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/random/rand32_timer.c:66:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/random/rand32_entropy_device.c:84:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/random/rand32_entropy_device.c:85:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/fs/fat_fs.c:68:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_cmds.c:384:3-6: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_core.c:492:9-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_core.c:88:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_core.c:89:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/unit/util/test.inc:274:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/mgmt/src/mgmt.c:235:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/mgmt/src/mgmt.c:205:15-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/icmpv4/src/main.c:243:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1085:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1087:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1150:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1152:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1109:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1111:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1224:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1226:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1206:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/lib/dns_packet/src/main.c:1208:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/route_mcast/src/main.c:454:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/socket/udp/src/main.c:332:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/net/socket/udp/src/main.c:337:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/dac/dac_loopback/src/test_dac.c:159:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/dac/dac_loopback/src/test_dac.c:176:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:752:15-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:767:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:781:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:612:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:562:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:569:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:585:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:417:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:680:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/counter/maxim_ds3231_api/src/test_counter.c:293:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_api_1pin/src/test_pin_interrupt.c:69:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_api_1pin/src/test_pin_interrupt.c:143:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/gpio/gpio_api_1pin/src/test_pin_interrupt.c:145:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:426:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:431:23-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:439:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:440:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:441:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:442:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:443:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:455:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:463:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:464:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:465:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:466:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:467:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:475:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:91:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/mgmt/ec_host_cmd/src/main.c:74:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:523:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:567:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:342:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:396:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:772:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:421:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:460:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:618:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:820:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/main.c:717:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/conformance/src/random_data.h:95:31-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/debug/coredump/src/main.c:13:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/gatt/src/main.c:162:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/gatt/src/main.c:175:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/gatt/src/main.c:202:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/main.c:320:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/main.c:305:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/bsim_bt/edtt_ble_test_app/gatt_test_app/src/main.c:290:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/bluetooth/hci_prop_evt/src/main.c:360:20-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/data_structure_perf/rbtree_perf/src/rbtree_perf.c:14:31-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/benchmarks/data_structure_perf/rbtree_perf/src/rbtree_perf.c:108:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_sw_vector_relay/src/arm_sw_vector_relay.c:48:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/arch/arm/arm_sw_vector_relay/src/arm_sw_vector_relay.c:51:52-53: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/ringbuffer/src/main.c:448:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/ringbuffer/src/main.c:494:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/ringbuffer/src/main.c:495:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/ringbuffer/src/main.c:495:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_q31.c:154:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_q31.c:157:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_q31.c:169:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/heap/src/main.c:123:62-63: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/devicetree/api/src/main.c:1353:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/workq/work_queue_api/src/main.c:81:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/workq/work_queue_api/src/main.c:187:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/timer_api/src/timer_convert.c:160:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/timer/timer_api/src/timer_convert.c:161:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/interrupt/src/prevent_irq.c:40:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/sched/schedule_api/src/test_sched_timeslice_reset.c:62:35-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/sched/schedule_api/src/test_sched_timeslice_reset.c:65:35-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/semaphore/semaphore/src/main.c:161:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/semaphore/semaphore/src/main.c:167:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/semaphore/semaphore/src/main.c:179:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/semaphore/semaphore/src/main.c:185:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/semaphore/semaphore/src/main.c:1183:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/application_development/out_of_tree_driver/hello_world_module/zephyr/hello_world_driver.c:22:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/application_development/out_of_tree_driver/hello_world_module/zephyr/hello_world_driver.c:31:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/net/zperf/src/zperf_tcp_uploader.c:70:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:351:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:239:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:245:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:249:17-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:29:24-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:30:24-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:28:22-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/settings/src/main.c:374:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/msgdev.c:98:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/tfm_integration/psa_level_1/src/psa_attestation.c:102:21-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:484:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:207:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:269:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:499:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:543:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:557:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:513:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:528:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/nrf/mesh/onoff_level_lighting_vnd_app/src/mesh/transition.c:470:65-66: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/userspace/prod_consumer/src/app_a.c:84:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/userspace/prod_consumer/src/app_a.c:150:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/xtensa/core/xtensa-asm2.c:217:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/common/timing.c:52:39-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch32/cortex_m/timing.c:167:39-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_smp.c:106:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arc/core/arc_smp.c:64:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/qemu_cortex_m0/nrf_timer_timer.c:83:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/qemu_cortex_m0/nrf_timer_timer.c:120:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mimxrt1064_evk/pinmux.c:51:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mps2_an521/pinmux.c:120:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mps2_an521/pinmux.c:121:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mps2_an521/pinmux.c:122:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/hex.c:29:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/hex.c:31:18-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap.c:55:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap.c:315:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap.c:317:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/mempool.c:315:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:63:53-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:196:25-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:227:42-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:98:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:102:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:110:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/heap-validate.c:111:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/kernel/futex.c:30:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:234:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:216:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/esp/esp.h:211:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/wifi/eswifi/eswifi_offload.c:451:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/kscan/kscan_sdl.c:23:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/kscan/kscan_sdl.c:24:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_litex.c:37:46-47: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mcux.c:52:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mcux.c:66:14-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mcux.c:81:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mcux.c:103:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mcux_ftm.c:69:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_mcux_tpm.c:77:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_nrfx.c:116:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_nrfx.c:168:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_nrfx.c:169:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_nrfx.c:48:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pwm/pwm_nrfx.c:63:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_cavs.c:112:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gicv3.c:96:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gicv3.c:59:48-49: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/interrupt_controller/intc_gicv3.c:194:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/led_shell.c:183:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/led_shell.c:204:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/led_shell.c:276:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/led_shell.c:297:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/lp503x.c:205:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/led/lp503x.c:206:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_mchp_xec.c:87:56-57: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_mchp_xec.c:31:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_mchp_xec.c:32:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/pinmux/pinmux_mchp_xec.c:35:56-57: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:228:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:228:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:247:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:156:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:156:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:175:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:327:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:328:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:330:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:379:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:135:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:142:7-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:62:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:69:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:70:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:39:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_lpc11u6x.c:40:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_esp32.c:129:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/clock_control/clock_control_esp32.c:262:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/native_posix_timer.c:98:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/stm32_lptim_timer.c:144:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/timer/stm32_lptim_timer.c:189:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_handlers.c:52:37-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:252:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/i2c/i2c_ll_stm32_v1.c:703:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/entropy/entropy_cc13xx_cc26xx.c:142:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_stm32_hal.c:358:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ethernet/eth_stm32_hal.c:195:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_ll_stm32.c:108:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_ll_stm32.c:704:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sam0.c:556:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_sam0.c:541:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/spi/spi_litespi.c:133:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_wwdg_stm32.c:122:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_wwdg_stm32.c:123:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_wwdg_stm32.c:125:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_wwdg_stm32.c:125:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:75:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:76:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/watchdog/wdt_gecko.c:183:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:632:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:894:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:353:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:353:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:481:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/adc/adc_lmp90xxx.c:485:53-54: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/espi/espi_mchp_xec.c:742:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/espi/espi_mchp_xec.c:744:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/espi/espi_mchp_xec.c:208:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/espi/espi_mchp_xec.c:1302:26-27: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/espi/espi_mchp_xec.c:1004:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/espi/espi_mchp_xec.c:983:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/mpr/mpr.c:123:21-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/mpr/mpr.c:74:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/dps310/dps310.c:583:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/dps310/dps310.c:625:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/dps310/dps310.c:296:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:89:24-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:90:21-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:102:39-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:103:45-52: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:123:31-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:133:30-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:138:35-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/max17055/max17055.c:139:41-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c:127:38-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c:73:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/nxp_kinetis_temp/temp_kinetis.c:73:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso.c:430:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/lsm6dso/lsm6dso.c:478:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/mchp_tach_xec/tach_mchp_xec.c:51:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl345/adxl345.c:98:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl345/adxl345.c:139:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/sensor/adxl345/adxl345.c:67:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/modem/modem_socket.c:264:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:264:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:226:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:233:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:108:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:114:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_stm32_ipcc.c:143:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_cavs_idc.c:44:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_cavs_idc.c:52:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_cavs_idc.c:109:33-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/ipm/ipm_cavs_idc.c:182:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_mcux_edma.c:170:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_mcux_lpc.c:340:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:369:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:369:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:127:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:129:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:145:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dma/dma_stm32.c:145:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/display/ssd16xx.c:401:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_mcux_dac.c:66:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_mcux_dac.c:71:14-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_stm32.c:65:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/dac/dac_stm32.c:68:32-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:684:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:706:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:341:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:356:15-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:437:14-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:440:15-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:304:15-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:308:14-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:322:17-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:480:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:506:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:755:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:564:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:575:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:455:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:253:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/counter/maxim_ds3231.c:285:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/peci/peci_mchp_xec.c:203:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_lpc.c:213:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_lpc.c:344:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_lpc.c:194:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_pca95xx.c:263:45-46: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_igpio.c:139:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_igpio.c:142:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_igpio.c:145:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/gpio/gpio_mcux_igpio.c:147:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_esp32.c:192:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uarte.c:1068:23-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/drivers/serial/uart_nrfx_uarte.c:1077:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:137:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:171:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:180:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:192:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_s1000/soc_mp.c:75:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/common/bootloader/boot_loader.c:45:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/xtensa/intel_apl_adsp/common/bootloader/boot_loader.c:109:41-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/arm/musca_b1/soc.c:35:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/soc/arm/arm/mps2/soc.c:64:47-48: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/settings/src/settings_nvs.c:266:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/settings/src/settings_nvs.c:270:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/mgmt/updatehub/updatehub.c:250:36-38: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:623:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:625:19-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:626:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:629:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:761:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:857:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:858:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:487:43-44: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:536:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:539:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:540:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:541:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:542:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/websocket/websocket.c:547:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/openthread/platform/entropy.c:28:44-45: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/lwm2m/lwm2m_obj_device.c:137:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/lib/dns/dns_pack.c:90:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/udp.c:42:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/net/ip/tcp.c:2195:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/dfu/boot/mcuboot.c:232:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/testsuite/ztest/src/ztest.c:444:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/testsuite/ztest/src/ztest.c:446:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/testsuite/ztest/src/ztest.c:454:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/usb/usb_device.c:697:34-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/canopen/CO_driver.c:375:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/canopen/CO_driver.c:403:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/canbus/canopen/CO_driver.c:125:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/cdb.c:51:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/cdb.c:88:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/pb_adv.c:201:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/settings.c:1623:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/settings.c:1963:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/mesh/settings.c:765:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/l2cap.c:2553:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/host/aes_ccm.c:71:14-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:167:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:168:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:170:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:171:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:172:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:186:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:195:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:204:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:205:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:206:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:211:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:212:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:213:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:248:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:249:51-52: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:251:36-37: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_master.c:252:51-52: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:5611:13-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:5713:12-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:6076:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:6077:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:6109:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:6110:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:5085:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3147:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3148:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3149:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3150:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3157:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3164:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3167:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3168:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:2189:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:2230:27-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3225:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3226:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3306:40-41: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:597:32-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:4113:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:4116:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:4125:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:3913:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:1039:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:1047:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:1089:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:1175:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:1204:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/bluetooth/controller/ll_sw/ull_conn.c:1475:59-60: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/fs/fuse_fs_access.c:49:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_msg.c:112:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_msg.c:114:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_msg.c:118:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/logging/log_msg.c:128:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/debug/coredump/coredump_backend_logging.c:52:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/debug/coredump/coredump_backend_logging.c:81:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/debug/gdbstub.c:80:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/debug/gdbstub.c:84:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/subsys/debug/gdbstub.c:43:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/posix/common/src/nanosleep.c:193:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/posix/common/src/nanosleep.c:198:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/uart/uart_async_api/src/test_uart_async.c:453:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/drivers/uart/uart_async_api/src/test_uart_async.c:570:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:410:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:513:42-43: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:420:7-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:422:7-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:424:7-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:450:23-24: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:451:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:232:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:248:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:248:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:248:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:266:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:266:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:266:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:279:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:279:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:279:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:296:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:296:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:296:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:308:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:308:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:308:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:320:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:320:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:320:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:332:21-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:332:41-42: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:332:61-62: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:173:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:190:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/settings/functional/src/settings_basic_test.c:207:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/canbus/isotp/implementation/src/random_data.h:95:31-35: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:289:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:430:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:346:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:347:24-25: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:405:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:120:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/subsys/fs/littlefs/src/testfs_util.c:190:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_f32.c:156:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_f32.c:159:9-10: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/lib/cmsis_dsp/matrix/src/binary_f32.c:171:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/float_regs_arc_gcc.h:42:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/float_regs_arc_gcc.h:76:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:225:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:246:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:283:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:113:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:118:29-30: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:164:11-12: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/tests/kernel/fpu_sharing/generic/src/load_store.c:204:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/can/src/main.c:196:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/can/src/main.c:197:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:219:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:229:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:265:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:122:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:127:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:128:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:147:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:162:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:163:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:177:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:178:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:196:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:197:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:55:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/led_lp503x/src/main.c:86:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:437:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:452:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:493:20-21: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:374:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:380:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:316:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:264:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:296:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:401:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/drivers/espi/src/main.c:408:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/logging/logger/src/main.c:226:8-9: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/logging/logger/src/main.c:254:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/logging/logger/src/main.c:255:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/logging/logger/src/main.c:259:28-29: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/subsys/logging/logger/src/main.c:260:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:90:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:90:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:93:7-8: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:100:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:108:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:117:49-50: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:140:25-26: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/scheduler/metairq_dispatch/src/main.c:152:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/samples/boards/sensortile_box/src/main.c:257:16-17: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:432:27-28: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:442:33-34: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:447:12-13: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:292:39-40: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:293:32-33: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:189:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:358:19-20: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:358:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:360:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:372:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:379:14-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:259:18-19: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/arch/arm/core/aarch64/arm_mmu.c:267:10-11: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/posix/native_posix/hw_counter.c:28:17-18: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/boards/arm/mm_swiftio/pinmux.c:48:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/gui/lvgl/lvgl.c:132:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/gui/lvgl/lvgl.c:135:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/gui/lvgl/lvgl.c:138:13-14: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/gui/lvgl/lvgl.c:142:30-31: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/gui/lvgl/lvgl.c:143:38-39: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/onoff.c:526:35-36: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/dec.c:11:19-22: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/dec.c:12:22-23: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/dec.c:17:15-16: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/dec.c:17:31-32: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/dec.c:17:50-51: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/lib/os/dec.c:25:13-15: WARNING: Unsigned 'U' suffix missing
/Users/yangxueqi/Documents/zephyr/kernel/mempool_sys.c:51:16-17: WARNING: Unsigned 'U' suffix missing
-------------------------------------------------------------------------

